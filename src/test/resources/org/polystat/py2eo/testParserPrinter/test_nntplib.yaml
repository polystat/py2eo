python: |
  import io
  import socket
  import datetime
  import textwrap
  import unittest
  import functools
  import contextlib
  import os.path
  import re
  import threading
  
  from test import support
  from nntplib import NNTP, GroupInfo
  import nntplib
  from unittest.mock import patch
  try:
      import ssl
  except ImportError:
      ssl = None
  
  
  TIMEOUT = 30
  certfile = os.path.join(os.path.dirname(__file__), 'keycert3.pem')
  
  if ssl is not None:
      SSLError = ssl.SSLError
  else:
      class SSLError(Exception):
          """Non-existent exception class when we lack SSL support."""
          reason = "This will never be raised."
  
  # TODO:
  # - test the `file` arg to more commands
  # - test error conditions
  # - test auth and `usenetrc`
  
  
  class NetworkedNNTPTestsMixin:
  
      def test_welcome(self):
          welcome = self.server.getwelcome()
          self.assertEqual(str, type(welcome))
  
      def test_help(self):
          resp, lines = self.server.help()
          self.assertTrue(resp.startswith("100 "), resp)
          for line in lines:
              self.assertEqual(str, type(line))
  
      def test_list(self):
          resp, groups = self.server.list()
          if len(groups) > 0:
              self.assertEqual(GroupInfo, type(groups[0]))
              self.assertEqual(str, type(groups[0].group))
  
      def test_list_active(self):
          resp, groups = self.server.list(self.GROUP_PAT)
          if len(groups) > 0:
              self.assertEqual(GroupInfo, type(groups[0]))
              self.assertEqual(str, type(groups[0].group))
  
      def test_unknown_command(self):
          with self.assertRaises(nntplib.NNTPPermanentError) as cm:
              self.server._shortcmd("XYZZY")
          resp = cm.exception.response
          self.assertTrue(resp.startswith("500 "), resp)
  
      def test_newgroups(self):
          # gmane gets a constant influx of new groups.  In order not to stress
          # the server too much, we choose a recent date in the past.
          dt = datetime.date.today() - datetime.timedelta(days=7)
          resp, groups = self.server.newgroups(dt)
          if len(groups) > 0:
              self.assertIsInstance(groups[0], GroupInfo)
              self.assertIsInstance(groups[0].group, str)
  
      def test_description(self):
          def _check_desc(desc):
              # Sanity checks
              self.assertIsInstance(desc, str)
              self.assertNotIn(self.GROUP_NAME, desc)
          desc = self.server.description(self.GROUP_NAME)
          _check_desc(desc)
          # Another sanity check
          self.assertIn(self.DESC, desc)
          # With a pattern
          desc = self.server.description(self.GROUP_PAT)
          _check_desc(desc)
          # Shouldn't exist
          desc = self.server.description("zk.brrtt.baz")
          self.assertEqual(desc, '')
  
      def test_descriptions(self):
          resp, descs = self.server.descriptions(self.GROUP_PAT)
          # 215 for LIST NEWSGROUPS, 282 for XGTITLE
          self.assertTrue(
              resp.startswith("215 ") or resp.startswith("282 "), resp)
          self.assertIsInstance(descs, dict)
          desc = descs[self.GROUP_NAME]
          self.assertEqual(desc, self.server.description(self.GROUP_NAME))
  
      def test_group(self):
          result = self.server.group(self.GROUP_NAME)
          self.assertEqual(5, len(result))
          resp, count, first, last, group = result
          self.assertEqual(group, self.GROUP_NAME)
          self.assertIsInstance(count, int)
          self.assertIsInstance(first, int)
          self.assertIsInstance(last, int)
          self.assertLessEqual(first, last)
          self.assertTrue(resp.startswith("211 "), resp)
  
      def test_date(self):
          resp, date = self.server.date()
          self.assertIsInstance(date, datetime.datetime)
          # Sanity check
          self.assertGreaterEqual(date.year, 1995)
          self.assertLessEqual(date.year, 2030)
  
      def _check_art_dict(self, art_dict):
          # Some sanity checks for a field dictionary returned by OVER / XOVER
          self.assertIsInstance(art_dict, dict)
          # NNTP has 7 mandatory fields
          self.assertGreaterEqual(art_dict.keys(),
              {"subject", "from", "date", "message-id",
               "references", ":bytes", ":lines"}
              )
          for v in art_dict.values():
              self.assertIsInstance(v, (str, type(None)))
  
      def test_xover(self):
          resp, count, first, last, name = self.server.group(self.GROUP_NAME)
          resp, lines = self.server.xover(last - 5, last)
          if len(lines) == 0:
              self.skipTest("no articles retrieved")
          # The 'last' article is not necessarily part of the output (cancelled?)
          art_num, art_dict = lines[0]
          self.assertGreaterEqual(art_num, last - 5)
          self.assertLessEqual(art_num, last)
          self._check_art_dict(art_dict)
  
      @unittest.skipIf(True, 'temporarily skipped until a permanent solution'
                             ' is found for issue #28971')
      def test_over(self):
          resp, count, first, last, name = self.server.group(self.GROUP_NAME)
          start = last - 10
          # The "start-" article range form
          resp, lines = self.server.over((start, None))
          art_num, art_dict = lines[0]
          self._check_art_dict(art_dict)
          # The "start-end" article range form
          resp, lines = self.server.over((start, last))
          art_num, art_dict = lines[-1]
          # The 'last' article is not necessarily part of the output (cancelled?)
          self.assertGreaterEqual(art_num, start)
          self.assertLessEqual(art_num, last)
          self._check_art_dict(art_dict)
          # XXX The "message_id" form is unsupported by gmane
          # 503 Overview by message-ID unsupported
  
      def test_xhdr(self):
          resp, count, first, last, name = self.server.group(self.GROUP_NAME)
          resp, lines = self.server.xhdr('subject', last)
          for line in lines:
              self.assertEqual(str, type(line[1]))
  
      def check_article_resp(self, resp, article, art_num=None):
          self.assertIsInstance(article, nntplib.ArticleInfo)
          if art_num is not None:
              self.assertEqual(article.number, art_num)
          for line in article.lines:
              self.assertIsInstance(line, bytes)
          # XXX this could exceptionally happen...
          self.assertNotIn(article.lines[-1], (b".", b".\n", b".\r\n"))
  
      @unittest.skipIf(True, "FIXME: see bpo-32128")
      def test_article_head_body(self):
          resp, count, first, last, name = self.server.group(self.GROUP_NAME)
          # Try to find an available article
          for art_num in (last, first, last - 1):
              try:
                  resp, head = self.server.head(art_num)
              except nntplib.NNTPTemporaryError as e:
                  if not e.response.startswith("423 "):
                      raise
                  # "423 No such article" => choose another one
                  continue
              break
          else:
              self.skipTest("could not find a suitable article number")
          self.assertTrue(resp.startswith("221 "), resp)
          self.check_article_resp(resp, head, art_num)
          resp, body = self.server.body(art_num)
          self.assertTrue(resp.startswith("222 "), resp)
          self.check_article_resp(resp, body, art_num)
          resp, article = self.server.article(art_num)
          self.assertTrue(resp.startswith("220 "), resp)
          self.check_article_resp(resp, article, art_num)
          # Tolerate running the tests from behind a NNTP virus checker
          blacklist = lambda line: line.startswith(b'X-Antivirus')
          filtered_head_lines = [line for line in head.lines
                                 if not blacklist(line)]
          filtered_lines = [line for line in article.lines
                            if not blacklist(line)]
          self.assertEqual(filtered_lines, filtered_head_lines + [b''] + body.lines)
  
      def test_capabilities(self):
          # The server under test implements NNTP version 2 and has a
          # couple of well-known capabilities. Just sanity check that we
          # got them.
          def _check_caps(caps):
              caps_list = caps['LIST']
              self.assertIsInstance(caps_list, (list, tuple))
              self.assertIn('OVERVIEW.FMT', caps_list)
          self.assertGreaterEqual(self.server.nntp_version, 2)
          _check_caps(self.server.getcapabilities())
          # This re-emits the command
          resp, caps = self.server.capabilities()
          _check_caps(caps)
  
      def test_zlogin(self):
          # This test must be the penultimate because further commands will be
          # refused.
          baduser = "notarealuser"
          badpw = "notarealpassword"
          # Check that bogus credentials cause failure
          self.assertRaises(nntplib.NNTPError, self.server.login,
                            user=baduser, password=badpw, usenetrc=False)
          # FIXME: We should check that correct credentials succeed, but that
          # would require valid details for some server somewhere to be in the
          # test suite, I think. Gmane is anonymous, at least as used for the
          # other tests.
  
      def test_zzquit(self):
          # This test must be called last, hence the name
          cls = type(self)
          try:
              self.server.quit()
          finally:
              cls.server = None
  
      @classmethod
      def wrap_methods(cls):
          # Wrap all methods in a transient_internet() exception catcher
          # XXX put a generic version in test.support?
          def wrap_meth(meth):
              @functools.wraps(meth)
              def wrapped(self):
                  with support.transient_internet(self.NNTP_HOST):
                      meth(self)
              return wrapped
          for name in dir(cls):
              if not name.startswith('test_'):
                  continue
              meth = getattr(cls, name)
              if not callable(meth):
                  continue
              # Need to use a closure so that meth remains bound to its current
              # value
              setattr(cls, name, wrap_meth(meth))
  
      def test_with_statement(self):
          def is_connected():
              if not hasattr(server, 'file'):
                  return False
              try:
                  server.help()
              except (OSError, EOFError):
                  return False
              return True
  
          try:
              with self.NNTP_CLASS(self.NNTP_HOST, timeout=TIMEOUT, usenetrc=False) as server:
                  self.assertTrue(is_connected())
                  self.assertTrue(server.help())
              self.assertFalse(is_connected())
  
              with self.NNTP_CLASS(self.NNTP_HOST, timeout=TIMEOUT, usenetrc=False) as server:
                  server.quit()
              self.assertFalse(is_connected())
          except SSLError as ssl_err:
              # matches "[SSL: DH_KEY_TOO_SMALL] dh key too small"
              if re.search(r'(?i)KEY.TOO.SMALL', ssl_err.reason):
                  raise unittest.SkipTest(f"Got {ssl_err} connecting "
                                          f"to {self.NNTP_HOST!r}")
              raise
  
  
  NetworkedNNTPTestsMixin.wrap_methods()
  
  
  EOF_ERRORS = (EOFError,)
  if ssl is not None:
      EOF_ERRORS += (ssl.SSLEOFError,)
  
  
  class NetworkedNNTPTests(NetworkedNNTPTestsMixin, unittest.TestCase):
      # This server supports STARTTLS (gmane doesn't)
      NNTP_HOST = 'news.trigofacile.com'
      GROUP_NAME = 'fr.comp.lang.python'
      GROUP_PAT = 'fr.comp.lang.*'
      DESC = 'Python'
  
      NNTP_CLASS = NNTP
  
      @classmethod
      def setUpClass(cls):
          support.requires("network")
          with support.transient_internet(cls.NNTP_HOST):
              try:
                  cls.server = cls.NNTP_CLASS(cls.NNTP_HOST, timeout=TIMEOUT,
                                              usenetrc=False)
              except SSLError as ssl_err:
                  # matches "[SSL: DH_KEY_TOO_SMALL] dh key too small"
                  if re.search(r'(?i)KEY.TOO.SMALL', ssl_err.reason):
                      raise unittest.SkipTest(f"{cls} got {ssl_err} connecting "
                                              f"to {cls.NNTP_HOST!r}")
                  raise
              except EOF_ERRORS:
                  raise unittest.SkipTest(f"{cls} got EOF error on connecting "
                                          f"to {cls.NNTP_HOST!r}")
  
      @classmethod
      def tearDownClass(cls):
          if cls.server is not None:
              cls.server.quit()
  
  @unittest.skipUnless(ssl, 'requires SSL support')
  class NetworkedNNTP_SSLTests(NetworkedNNTPTests):
  
      # Technical limits for this public NNTP server (see http://www.aioe.org):
      # "Only two concurrent connections per IP address are allowed and
      # 400 connections per day are accepted from each IP address."
  
      NNTP_HOST = 'nntp.aioe.org'
      # bpo-42794: aioe.test is one of the official groups on this server
      # used for testing: https://news.aioe.org/manual/aioe-hierarchy/
      GROUP_NAME = 'aioe.test'
      GROUP_PAT = 'aioe.*'
      DESC = 'test'
  
      NNTP_CLASS = getattr(nntplib, 'NNTP_SSL', None)
  
      # Disabled as it produces too much data
      test_list = None
  
      # Disabled as the connection will already be encrypted.
      test_starttls = None
  
  
  #
  # Non-networked tests using a local server (or something mocking it).
  #
  
  class _NNTPServerIO(io.RawIOBase):
      """A raw IO object allowing NNTP commands to be received and processed
      by a handler.  The handler can push responses which can then be read
      from the IO object."""
  
      def __init__(self, handler):
          io.RawIOBase.__init__(self)
          # The channel from the client
          self.c2s = io.BytesIO()
          # The channel to the client
          self.s2c = io.BytesIO()
          self.handler = handler
          self.handler.start(self.c2s.readline, self.push_data)
  
      def readable(self):
          return True
  
      def writable(self):
          return True
  
      def push_data(self, data):
          """Push (buffer) some data to send to the client."""
          pos = self.s2c.tell()
          self.s2c.seek(0, 2)
          self.s2c.write(data)
          self.s2c.seek(pos)
  
      def write(self, b):
          """The client sends us some data"""
          pos = self.c2s.tell()
          self.c2s.write(b)
          self.c2s.seek(pos)
          self.handler.process_pending()
          return len(b)
  
      def readinto(self, buf):
          """The client wants to read a response"""
          self.handler.process_pending()
          b = self.s2c.read(len(buf))
          n = len(b)
          buf[:n] = b
          return n
  
  
  def make_mock_file(handler):
      sio = _NNTPServerIO(handler)
      # Using BufferedRWPair instead of BufferedRandom ensures the file
      # isn't seekable.
      file = io.BufferedRWPair(sio, sio)
      return (sio, file)
  
  
  class MockedNNTPTestsMixin:
      # Override in derived classes
      handler_class = None
  
      def setUp(self):
          super().setUp()
          self.make_server()
  
      def tearDown(self):
          super().tearDown()
          del self.server
  
      def make_server(self, *args, **kwargs):
          self.handler = self.handler_class()
          self.sio, file = make_mock_file(self.handler)
          self.server = nntplib._NNTPBase(file, 'test.server', *args, **kwargs)
          return self.server
  
  
  class MockedNNTPWithReaderModeMixin(MockedNNTPTestsMixin):
      def setUp(self):
          super().setUp()
          self.make_server(readermode=True)
  
  
  class NNTPv1Handler:
      """A handler for RFC 977"""
  
      welcome = "200 NNTP mock server"
  
      def start(self, readline, push_data):
          self.in_body = False
          self.allow_posting = True
          self._readline = readline
          self._push_data = push_data
          self._logged_in = False
          self._user_sent = False
          # Our welcome
          self.handle_welcome()
  
      def _decode(self, data):
          return str(data, "utf-8", "surrogateescape")
  
      def process_pending(self):
          if self.in_body:
              while True:
                  line = self._readline()
                  if not line:
                      return
                  self.body.append(line)
                  if line == b".\r\n":
                      break
              try:
                  meth, tokens = self.body_callback
                  meth(*tokens, body=self.body)
              finally:
                  self.body_callback = None
                  self.body = None
                  self.in_body = False
          while True:
              line = self._decode(self._readline())
              if not line:
                  return
              if not line.endswith("\r\n"):
                  raise ValueError("line doesn't end with \\r\\n: {!r}".format(line))
              line = line[:-2]
              cmd, *tokens = line.split()
              #meth = getattr(self.handler, "handle_" + cmd.upper(), None)
              meth = getattr(self, "handle_" + cmd.upper(), None)
              if meth is None:
                  self.handle_unknown()
              else:
                  try:
                      meth(*tokens)
                  except Exception as e:
                      raise ValueError("command failed: {!r}".format(line)) from e
                  else:
                      if self.in_body:
                          self.body_callback = meth, tokens
                          self.body = []
  
      def expect_body(self):
          """Flag that the client is expected to post a request body"""
          self.in_body = True
  
      def push_data(self, data):
          """Push some binary data"""
          self._push_data(data)
  
      def push_lit(self, lit):
          """Push a string literal"""
          lit = textwrap.dedent(lit)
          lit = "\r\n".join(lit.splitlines()) + "\r\n"
          lit = lit.encode('utf-8')
          self.push_data(lit)
  
      def handle_unknown(self):
          self.push_lit("500 What?")
  
      def handle_welcome(self):
          self.push_lit(self.welcome)
  
      def handle_QUIT(self):
          self.push_lit("205 Bye!")
  
      def handle_DATE(self):
          self.push_lit("111 20100914001155")
  
      def handle_GROUP(self, group):
          if group == "fr.comp.lang.python":
              self.push_lit("211 486 761 1265 fr.comp.lang.python")
          else:
              self.push_lit("411 No such group {}".format(group))
  
      def handle_HELP(self):
          self.push_lit("""\
              100 Legal commands
                authinfo user Name|pass Password|generic <prog> <args>
                date
                help
              Report problems to <root@example.org>
              .""")
  
      def handle_STAT(self, message_spec=None):
          if message_spec is None:
              self.push_lit("412 No newsgroup selected")
          elif message_spec == "3000234":
              self.push_lit("223 3000234 <45223423@example.com>")
          elif message_spec == "<45223423@example.com>":
              self.push_lit("223 0 <45223423@example.com>")
          else:
              self.push_lit("430 No Such Article Found")
  
      def handle_NEXT(self):
          self.push_lit("223 3000237 <668929@example.org> retrieved")
  
      def handle_LAST(self):
          self.push_lit("223 3000234 <45223423@example.com> retrieved")
  
      def handle_LIST(self, action=None, param=None):
          if action is None:
              self.push_lit("""\
                  215 Newsgroups in form "group high low flags".
                  comp.lang.python 0000052340 0000002828 y
                  comp.lang.python.announce 0000001153 0000000993 m
                  free.it.comp.lang.python 0000000002 0000000002 y
                  fr.comp.lang.python 0000001254 0000000760 y
                  free.it.comp.lang.python.learner 0000000000 0000000001 y
                  tw.bbs.comp.lang.python 0000000304 0000000304 y
                  .""")
          elif action == "ACTIVE":
              if param == "*distutils*":
                  self.push_lit("""\
                      215 Newsgroups in form "group high low flags"
                      gmane.comp.python.distutils.devel 0000014104 0000000001 m
                      gmane.comp.python.distutils.cvs 0000000000 0000000001 m
                      .""")
              else:
                  self.push_lit("""\
                      215 Newsgroups in form "group high low flags"
                      .""")
          elif action == "OVERVIEW.FMT":
              self.push_lit("""\
                  215 Order of fields in overview database.
                  Subject:
                  From:
                  Date:
                  Message-ID:
                  References:
                  Bytes:
                  Lines:
                  Xref:full
                  .""")
          elif action == "NEWSGROUPS":
              assert param is not None
              if param == "comp.lang.python":
                  self.push_lit("""\
                      215 Descriptions in form "group description".
                      comp.lang.python\tThe Python computer language.
                      .""")
              elif param == "comp.lang.python*":
                  self.push_lit("""\
                      215 Descriptions in form "group description".
                      comp.lang.python.announce\tAnnouncements about the Python language. (Moderated)
                      comp.lang.python\tThe Python computer language.
                      .""")
              else:
                  self.push_lit("""\
                      215 Descriptions in form "group description".
                      .""")
          else:
              self.push_lit('501 Unknown LIST keyword')
  
      def handle_NEWNEWS(self, group, date_str, time_str):
          # We hard code different return messages depending on passed
          # argument and date syntax.
          if (group == "comp.lang.python" and date_str == "20100913"
              and time_str == "082004"):
              # Date was passed in RFC 3977 format (NNTP "v2")
              self.push_lit("""\
                  230 list of newsarticles (NNTP v2) created after Mon Sep 13 08:20:04 2010 follows
                  <a4929a40-6328-491a-aaaf-cb79ed7309a2@q2g2000vbk.googlegroups.com>
                  <f30c0419-f549-4218-848f-d7d0131da931@y3g2000vbm.googlegroups.com>
                  .""")
          elif (group == "comp.lang.python" and date_str == "100913"
              and time_str == "082004"):
              # Date was passed in RFC 977 format (NNTP "v1")
              self.push_lit("""\
                  230 list of newsarticles (NNTP v1) created after Mon Sep 13 08:20:04 2010 follows
                  <a4929a40-6328-491a-aaaf-cb79ed7309a2@q2g2000vbk.googlegroups.com>
                  <f30c0419-f549-4218-848f-d7d0131da931@y3g2000vbm.googlegroups.com>
                  .""")
          elif (group == 'comp.lang.python' and
                date_str in ('20100101', '100101') and
                time_str == '090000'):
              self.push_lit('too long line' * 3000 +
                            '\n.')
          else:
              self.push_lit("""\
                  230 An empty list of newsarticles follows
                  .""")
          # (Note for experiments: many servers disable NEWNEWS.
          #  As of this writing, sicinfo3.epfl.ch doesn't.)
  
      def handle_XOVER(self, message_spec):
          if message_spec == "57-59":
              self.push_lit(
                  "224 Overview information for 57-58 follows\n"
                  "57\tRe: ANN: New Plone book with strong Python (and Zope) themes throughout"
                      "\tDoug Hellmann <doug.hellmann-Re5JQEeQqe8AvxtiuMwx3w@public.gmane.org>"
                      "\tSat, 19 Jun 2010 18:04:08 -0400"
                      "\t<4FD05F05-F98B-44DC-8111-C6009C925F0C@gmail.com>"
                      "\t<hvalf7$ort$1@dough.gmane.org>\t7103\t16"
                      "\tXref: news.gmane.io gmane.comp.python.authors:57"
                      "\n"
                  "58\tLooking for a few good bloggers"
                      "\tDoug Hellmann <doug.hellmann-Re5JQEeQqe8AvxtiuMwx3w@public.gmane.org>"
                      "\tThu, 22 Jul 2010 09:14:14 -0400"
                      "\t<A29863FA-F388-40C3-AA25-0FD06B09B5BF@gmail.com>"
                      "\t\t6683\t16"
                      "\t"
                      "\n"
                  # A UTF-8 overview line from fr.comp.lang.python
