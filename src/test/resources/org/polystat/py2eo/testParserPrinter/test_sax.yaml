python: |
  # regression test for SAX 2.0
  # $Id$
  
  from xml.sax import make_parser, ContentHandler, \
                      SAXException, SAXReaderNotAvailable, SAXParseException
  import unittest
  from unittest import mock
  try:
      make_parser()
  except SAXReaderNotAvailable:
      # don't try to test this module if we cannot create a parser
      raise unittest.SkipTest("no XML parsers available")
  from xml.sax.saxutils import XMLGenerator, escape, unescape, quoteattr, \
                               XMLFilterBase, prepare_input_source
  from xml.sax.expatreader import create_parser
  from xml.sax.handler import feature_namespaces, feature_external_ges
  from xml.sax.xmlreader import InputSource, AttributesImpl, AttributesNSImpl
  from io import BytesIO, StringIO
  import codecs
  import os.path
  import shutil
  from urllib.error import URLError
  from test import support
  from test.support import findfile, run_unittest, FakePath, TESTFN
  
  TEST_XMLFILE = findfile("test.xml", subdir="xmltestdata")
  TEST_XMLFILE_OUT = findfile("test.xml.out", subdir="xmltestdata")
  try:
      TEST_XMLFILE.encode("utf-8")
      TEST_XMLFILE_OUT.encode("utf-8")
  except UnicodeEncodeError:
      raise unittest.SkipTest("filename is not encodable to utf8")
  
  supports_nonascii_filenames = True
  if not os.path.supports_unicode_filenames:
      try:
          support.TESTFN_UNICODE.encode(support.TESTFN_ENCODING)
      except (UnicodeError, TypeError):
          # Either the file system encoding is None, or the file name
          # cannot be encoded in the file system encoding.
          supports_nonascii_filenames = False
  requires_nonascii_filenames = unittest.skipUnless(
          supports_nonascii_filenames,
          'Requires non-ascii filenames support')
  
  ns_uri = "http://www.python.org/xml-ns/saxtest/"
  
  class XmlTestBase(unittest.TestCase):
      def verify_empty_attrs(self, attrs):
          self.assertRaises(KeyError, attrs.getValue, "attr")
          self.assertRaises(KeyError, attrs.getValueByQName, "attr")
          self.assertRaises(KeyError, attrs.getNameByQName, "attr")
          self.assertRaises(KeyError, attrs.getQNameByName, "attr")
          self.assertRaises(KeyError, attrs.__getitem__, "attr")
          self.assertEqual(attrs.getLength(), 0)
          self.assertEqual(attrs.getNames(), [])
          self.assertEqual(attrs.getQNames(), [])
          self.assertEqual(len(attrs), 0)
          self.assertNotIn("attr", attrs)
          self.assertEqual(list(attrs.keys()), [])
          self.assertEqual(attrs.get("attrs"), None)
          self.assertEqual(attrs.get("attrs", 25), 25)
          self.assertEqual(list(attrs.items()), [])
          self.assertEqual(list(attrs.values()), [])
  
      def verify_empty_nsattrs(self, attrs):
          self.assertRaises(KeyError, attrs.getValue, (ns_uri, "attr"))
          self.assertRaises(KeyError, attrs.getValueByQName, "ns:attr")
          self.assertRaises(KeyError, attrs.getNameByQName, "ns:attr")
          self.assertRaises(KeyError, attrs.getQNameByName, (ns_uri, "attr"))
          self.assertRaises(KeyError, attrs.__getitem__, (ns_uri, "attr"))
          self.assertEqual(attrs.getLength(), 0)
          self.assertEqual(attrs.getNames(), [])
          self.assertEqual(attrs.getQNames(), [])
          self.assertEqual(len(attrs), 0)
          self.assertNotIn((ns_uri, "attr"), attrs)
          self.assertEqual(list(attrs.keys()), [])
          self.assertEqual(attrs.get((ns_uri, "attr")), None)
          self.assertEqual(attrs.get((ns_uri, "attr"), 25), 25)
          self.assertEqual(list(attrs.items()), [])
          self.assertEqual(list(attrs.values()), [])
  
      def verify_attrs_wattr(self, attrs):
          self.assertEqual(attrs.getLength(), 1)
          self.assertEqual(attrs.getNames(), ["attr"])
          self.assertEqual(attrs.getQNames(), ["attr"])
          self.assertEqual(len(attrs), 1)
          self.assertIn("attr", attrs)
          self.assertEqual(list(attrs.keys()), ["attr"])
          self.assertEqual(attrs.get("attr"), "val")
          self.assertEqual(attrs.get("attr", 25), "val")
          self.assertEqual(list(attrs.items()), [("attr", "val")])
          self.assertEqual(list(attrs.values()), ["val"])
          self.assertEqual(attrs.getValue("attr"), "val")
          self.assertEqual(attrs.getValueByQName("attr"), "val")
          self.assertEqual(attrs.getNameByQName("attr"), "attr")
          self.assertEqual(attrs["attr"], "val")
          self.assertEqual(attrs.getQNameByName("attr"), "attr")
  
  
  def xml_str(doc, encoding=None):
      if encoding is None:
          return doc
      return '<?xml version="1.0" encoding="%s"?>\n%s' % (encoding, doc)
  
  def xml_bytes(doc, encoding, decl_encoding=...):
      if decl_encoding is ...:
          decl_encoding = encoding
      return xml_str(doc, decl_encoding).encode(encoding, 'xmlcharrefreplace')
  
  def make_xml_file(doc, encoding, decl_encoding=...):
      if decl_encoding is ...:
          decl_encoding = encoding
      with open(TESTFN, 'w', encoding=encoding, errors='xmlcharrefreplace') as f:
          f.write(xml_str(doc, decl_encoding))
  
  
  class ParseTest(unittest.TestCase):
      data = '<money value="$\xa3\u20ac\U0001017b">$\xa3\u20ac\U0001017b</money>'
  
      def tearDown(self):
          support.unlink(TESTFN)
  
      def check_parse(self, f):
          from xml.sax import parse
          result = StringIO()
          parse(f, XMLGenerator(result, 'utf-8'))
          self.assertEqual(result.getvalue(), xml_str(self.data, 'utf-8'))
  
      def test_parse_text(self):
          encodings = ('us-ascii', 'iso-8859-1', 'utf-8',
                       'utf-16', 'utf-16le', 'utf-16be')
          for encoding in encodings:
              self.check_parse(StringIO(xml_str(self.data, encoding)))
              make_xml_file(self.data, encoding)
              with open(TESTFN, 'r', encoding=encoding) as f:
                  self.check_parse(f)
              self.check_parse(StringIO(self.data))
              make_xml_file(self.data, encoding, None)
              with open(TESTFN, 'r', encoding=encoding) as f:
                  self.check_parse(f)
  
      def test_parse_bytes(self):
          # UTF-8 is default encoding, US-ASCII is compatible with UTF-8,
          # UTF-16 is autodetected
          encodings = ('us-ascii', 'utf-8', 'utf-16', 'utf-16le', 'utf-16be')
          for encoding in encodings:
              self.check_parse(BytesIO(xml_bytes(self.data, encoding)))
              make_xml_file(self.data, encoding)
              self.check_parse(TESTFN)
              with open(TESTFN, 'rb') as f:
                  self.check_parse(f)
              self.check_parse(BytesIO(xml_bytes(self.data, encoding, None)))
              make_xml_file(self.data, encoding, None)
              self.check_parse(TESTFN)
              with open(TESTFN, 'rb') as f:
                  self.check_parse(f)
          # accept UTF-8 with BOM
          self.check_parse(BytesIO(xml_bytes(self.data, 'utf-8-sig', 'utf-8')))
          make_xml_file(self.data, 'utf-8-sig', 'utf-8')
          self.check_parse(TESTFN)
          with open(TESTFN, 'rb') as f:
              self.check_parse(f)
          self.check_parse(BytesIO(xml_bytes(self.data, 'utf-8-sig', None)))
          make_xml_file(self.data, 'utf-8-sig', None)
          self.check_parse(TESTFN)
          with open(TESTFN, 'rb') as f:
              self.check_parse(f)
          # accept data with declared encoding
          self.check_parse(BytesIO(xml_bytes(self.data, 'iso-8859-1')))
          make_xml_file(self.data, 'iso-8859-1')
          self.check_parse(TESTFN)
          with open(TESTFN, 'rb') as f:
              self.check_parse(f)
          # fail on non-UTF-8 incompatible data without declared encoding
          with self.assertRaises(SAXException):
              self.check_parse(BytesIO(xml_bytes(self.data, 'iso-8859-1', None)))
          make_xml_file(self.data, 'iso-8859-1', None)
          with self.assertRaises(SAXException):
              self.check_parse(TESTFN)
          with open(TESTFN, 'rb') as f:
              with self.assertRaises(SAXException):
                  self.check_parse(f)
  
      def test_parse_path_object(self):
          make_xml_file(self.data, 'utf-8', None)
          self.check_parse(FakePath(TESTFN))
  
      def test_parse_InputSource(self):
          # accept data without declared but with explicitly specified encoding
          make_xml_file(self.data, 'iso-8859-1', None)
          with open(TESTFN, 'rb') as f:
              input = InputSource()
              input.setByteStream(f)
              input.setEncoding('iso-8859-1')
              self.check_parse(input)
  
      def test_parse_close_source(self):
          builtin_open = open
          fileobj = None
  
          def mock_open(*args):
              nonlocal fileobj
              fileobj = builtin_open(*args)
              return fileobj
  
          with mock.patch('xml.sax.saxutils.open', side_effect=mock_open):
              make_xml_file(self.data, 'iso-8859-1', None)
              with self.assertRaises(SAXException):
                  self.check_parse(TESTFN)
              self.assertTrue(fileobj.closed)
  
      def check_parseString(self, s):
          from xml.sax import parseString
          result = StringIO()
          parseString(s, XMLGenerator(result, 'utf-8'))
          self.assertEqual(result.getvalue(), xml_str(self.data, 'utf-8'))
  
      def test_parseString_text(self):
          encodings = ('us-ascii', 'iso-8859-1', 'utf-8',
                       'utf-16', 'utf-16le', 'utf-16be')
          for encoding in encodings:
              self.check_parseString(xml_str(self.data, encoding))
          self.check_parseString(self.data)
  
      def test_parseString_bytes(self):
          # UTF-8 is default encoding, US-ASCII is compatible with UTF-8,
          # UTF-16 is autodetected
          encodings = ('us-ascii', 'utf-8', 'utf-16', 'utf-16le', 'utf-16be')
          for encoding in encodings:
              self.check_parseString(xml_bytes(self.data, encoding))
              self.check_parseString(xml_bytes(self.data, encoding, None))
          # accept UTF-8 with BOM
          self.check_parseString(xml_bytes(self.data, 'utf-8-sig', 'utf-8'))
          self.check_parseString(xml_bytes(self.data, 'utf-8-sig', None))
          # accept data with declared encoding
          self.check_parseString(xml_bytes(self.data, 'iso-8859-1'))
          # fail on non-UTF-8 incompatible data without declared encoding
          with self.assertRaises(SAXException):
              self.check_parseString(xml_bytes(self.data, 'iso-8859-1', None))
  
  class MakeParserTest(unittest.TestCase):
      def test_make_parser2(self):
          # Creating parsers several times in a row should succeed.
          # Testing this because there have been failures of this kind
          # before.
          from xml.sax import make_parser
          p = make_parser()
          from xml.sax import make_parser
          p = make_parser()
          from xml.sax import make_parser
          p = make_parser()
          from xml.sax import make_parser
          p = make_parser()
          from xml.sax import make_parser
          p = make_parser()
          from xml.sax import make_parser
          p = make_parser()
  
      def test_make_parser3(self):
          # Testing that make_parser can handle different types of
          # iterables.
          make_parser(['module'])
          make_parser(('module', ))
          make_parser({'module'})
          make_parser(frozenset({'module'}))
          make_parser({'module': None})
          make_parser(iter(['module']))
  
      def test_make_parser4(self):
          # Testing that make_parser can handle empty iterables.
          make_parser([])
          make_parser(tuple())
          make_parser(set())
          make_parser(frozenset())
          make_parser({})
          make_parser(iter([]))
  
      def test_make_parser5(self):
          # Testing that make_parser can handle iterables with more than
          # one item.
          make_parser(['module1', 'module2'])
          make_parser(('module1', 'module2'))
          make_parser({'module1', 'module2'})
          make_parser(frozenset({'module1', 'module2'}))
          make_parser({'module1': None, 'module2': None})
          make_parser(iter(['module1', 'module2']))
  
  # ===========================================================================
  #
  #   saxutils tests
  #
  # ===========================================================================
  
  class SaxutilsTest(unittest.TestCase):
      # ===== escape
      def test_escape_basic(self):
          self.assertEqual(escape("Donald Duck & Co"), "Donald Duck &amp; Co")
  
      def test_escape_all(self):
          self.assertEqual(escape("<Donald Duck & Co>"),
                           "&lt;Donald Duck &amp; Co&gt;")
  
      def test_escape_extra(self):
