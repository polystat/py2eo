python: |
  from collections import namedtuple
  import contextlib
  import itertools
  import os
  import pickle
  import sys
  from textwrap import dedent
  import threading
  import time
  import unittest
  
  from test import support
  from test.support import script_helper
  
  
  interpreters = support.import_module('_xxsubinterpreters')
  
  
  ##################################
  # helpers
  
  def powerset(*sets):
      return itertools.chain.from_iterable(
          combinations(sets, r)
          for r in range(len(sets)+1))
  
  
  def _captured_script(script):
      r, w = os.pipe()
      indented = script.replace('\n', '\n                ')
      wrapped = dedent(f"""
          import contextlib
          with open({w}, 'w') as spipe:
              with contextlib.redirect_stdout(spipe):
                  {indented}
          """)
      return wrapped, open(r)
  
  
  def _run_output(interp, request, shared=None):
      script, rpipe = _captured_script(request)
      with rpipe:
          interpreters.run_string(interp, script, shared)
          return rpipe.read()
  
  
  @contextlib.contextmanager
  def _running(interp):
      r, w = os.pipe()
      def run():
          interpreters.run_string(interp, dedent(f"""
              # wait for "signal"
              with open({r}) as rpipe:
                  rpipe.read()
              """))
  
      t = threading.Thread(target=run)
      t.start()
  
      yield
  
      with open(w, 'w') as spipe:
          spipe.write('done')
      t.join()
  
  
  #@contextmanager
  #def run_threaded(id, source, **shared):
  #    def run():
  #        run_interp(id, source, **shared)
  #    t = threading.Thread(target=run)
  #    t.start()
  #    yield
  #    t.join()
  
  
  def run_interp(id, source, **shared):
      _run_interp(id, source, shared)
  
  
  def _run_interp(id, source, shared, _mainns={}):
      source = dedent(source)
      main = interpreters.get_main()
      if main == id:
          if interpreters.get_current() != main:
              raise RuntimeError
          # XXX Run a func?
          exec(source, _mainns)
      else:
          interpreters.run_string(id, source, shared)
  
  
  def run_interp_threaded(id, source, **shared):
      def run():
          _run(id, source, shared)
      t = threading.Thread(target=run)
      t.start()
      t.join()
  
  
  class Interpreter(namedtuple('Interpreter', 'name id')):
  
      @classmethod
      def from_raw(cls, raw):
          if isinstance(raw, cls):
              return raw
          elif isinstance(raw, str):
              return cls(raw)
          else:
              raise NotImplementedError
  
      def __new__(cls, name=None, id=None):
          main = interpreters.get_main()
          if id == main:
              if not name:
                  name = 'main'
              elif name != 'main':
                  raise ValueError(
                      'name mismatch (expected "main", got "{}")'.format(name))
              id = main
          elif id is not None:
              if not name:
                  name = 'interp'
              elif name == 'main':
                  raise ValueError('name mismatch (unexpected "main")')
              if not isinstance(id, interpreters.InterpreterID):
                  id = interpreters.InterpreterID(id)
          elif not name or name == 'main':
              name = 'main'
              id = main
          else:
              id = interpreters.create()
          self = super().__new__(cls, name, id)
          return self
  
  
  # XXX expect_channel_closed() is unnecessary once we improve exc propagation.
  
  @contextlib.contextmanager
  def expect_channel_closed():
      try:
          yield
      except interpreters.ChannelClosedError:
          pass
      else:
          assert False, 'channel not closed'
  
  
  class ChannelAction(namedtuple('ChannelAction', 'action end interp')):
  
      def __new__(cls, action, end=None, interp=None):
          if not end:
              end = 'both'
          if not interp:
              interp = 'main'
          self = super().__new__(cls, action, end, interp)
          return self
  
      def __init__(self, *args, **kwargs):
          if self.action == 'use':
              if self.end not in ('same', 'opposite', 'send', 'recv'):
                  raise ValueError(self.end)
          elif self.action in ('close', 'force-close'):
              if self.end not in ('both', 'same', 'opposite', 'send', 'recv'):
                  raise ValueError(self.end)
          else:
              raise ValueError(self.action)
          if self.interp not in ('main', 'same', 'other', 'extra'):
              raise ValueError(self.interp)
  
      def resolve_end(self, end):
          if self.end == 'same':
              return end
          elif self.end == 'opposite':
              return 'recv' if end == 'send' else 'send'
          else:
              return self.end
  
      def resolve_interp(self, interp, other, extra):
          if self.interp == 'same':
              return interp
          elif self.interp == 'other':
              if other is None:
                  raise RuntimeError
              return other
          elif self.interp == 'extra':
              if extra is None:
                  raise RuntimeError
              return extra
          elif self.interp == 'main':
              if interp.name == 'main':
                  return interp
              elif other and other.name == 'main':
                  return other
              else:
                  raise RuntimeError
          # Per __init__(), there aren't any others.
  
  
  class ChannelState(namedtuple('ChannelState', 'pending closed')):
  
      def __new__(cls, pending=0, *, closed=False):
          self = super().__new__(cls, pending, closed)
          return self
  
      def incr(self):
          return type(self)(self.pending + 1, closed=self.closed)
  
      def decr(self):
          return type(self)(self.pending - 1, closed=self.closed)
  
      def close(self, *, force=True):
          if self.closed:
              if not force or self.pending == 0:
                  return self
          return type(self)(0 if force else self.pending, closed=True)
  
  
  def run_action(cid, action, end, state, *, hideclosed=True):
      if state.closed:
          if action == 'use' and end == 'recv' and state.pending:
              expectfail = False
          else:
              expectfail = True
      else:
          expectfail = False
  
      try:
          result = _run_action(cid, action, end, state)
      except interpreters.ChannelClosedError:
          if not hideclosed and not expectfail:
              raise
          result = state.close()
      else:
          if expectfail:
              raise ...  # XXX
      return result
  
  
  def _run_action(cid, action, end, state):
      if action == 'use':
          if end == 'send':
              interpreters.channel_send(cid, b'spam')
              return state.incr()
          elif end == 'recv':
              if not state.pending:
                  try:
                      interpreters.channel_recv(cid)
                  except interpreters.ChannelEmptyError:
                      return state
                  else:
                      raise Exception('expected ChannelEmptyError')
              else:
                  interpreters.channel_recv(cid)
                  return state.decr()
          else:
              raise ValueError(end)
      elif action == 'close':
          kwargs = {}
          if end in ('recv', 'send'):
              kwargs[end] = True
          interpreters.channel_close(cid, **kwargs)
          return state.close()
      elif action == 'force-close':
          kwargs = {
              'force': True,
              }
          if end in ('recv', 'send'):
              kwargs[end] = True
          interpreters.channel_close(cid, **kwargs)
          return state.close(force=True)
      else:
          raise ValueError(action)
  
  
  def clean_up_interpreters():
      for id in interpreters.list_all():
          if id == 0:  # main
              continue
          try:
              interpreters.destroy(id)
          except RuntimeError:
              pass  # already destroyed
  
  
  def clean_up_channels():
      for cid in interpreters.channel_list_all():
          try:
              interpreters.channel_destroy(cid)
          except interpreters.ChannelNotFoundError:
              pass  # already destroyed
  
  
  class TestBase(unittest.TestCase):
  
      def tearDown(self):
          clean_up_interpreters()
          clean_up_channels()
  
  
  ##################################
  # misc. tests
  
  class IsShareableTests(unittest.TestCase):
  
      def test_default_shareables(self):
          shareables = [
                  # singletons
                  None,
                  # builtin objects
                  b'spam',
                  'spam',
                  10,
                  -10,
                  ]
          for obj in shareables:
              with self.subTest(obj):
                  self.assertTrue(
                      interpreters.is_shareable(obj))
  
      def test_not_shareable(self):
          class Cheese:
              def __init__(self, name):
                  self.name = name
              def __str__(self):
                  return self.name
  
          class SubBytes(bytes):
              """A subclass of a shareable type."""
  
          not_shareables = [
                  # singletons
                  True,
                  False,
                  NotImplemented,
                  ...,
                  # builtin types and objects
                  type,
                  object,
                  object(),
                  Exception(),
                  100.0,
                  # user-defined types and objects
                  Cheese,
                  Cheese('Wensleydale'),
                  SubBytes(b'spam'),
                  ]
          for obj in not_shareables:
              with self.subTest(repr(obj)):
                  self.assertFalse(
                      interpreters.is_shareable(obj))
  
  
  class ShareableTypeTests(unittest.TestCase):
  
      def setUp(self):
          super().setUp()
          self.cid = interpreters.channel_create()
  
      def tearDown(self):
          interpreters.channel_destroy(self.cid)
          super().tearDown()
  
      def _assert_values(self, values):
          for obj in values:
              with self.subTest(obj):
                  interpreters.channel_send(self.cid, obj)
                  got = interpreters.channel_recv(self.cid)
  
                  self.assertEqual(got, obj)
                  self.assertIs(type(got), type(obj))
                  # XXX Check the following in the channel tests?
                  #self.assertIsNot(got, obj)
  
      def test_singletons(self):
          for obj in [None]:
              with self.subTest(obj):
                  interpreters.channel_send(self.cid, obj)
                  got = interpreters.channel_recv(self.cid)
  
                  # XXX What about between interpreters?
                  self.assertIs(got, obj)
  
      def test_types(self):
          self._assert_values([
              b'spam',
              9999,
              self.cid,
              ])
  
      def test_bytes(self):
          self._assert_values(i.to_bytes(2, 'little', signed=True)
                              for i in range(-1, 258))
  
      def test_strs(self):
