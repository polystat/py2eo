python: |
  import asyncore
  import base64
  import email.mime.text
  from email.message import EmailMessage
  from email.base64mime import body_encode as encode_base64
  import email.utils
  import hashlib
  import hmac
  import socket
  import smtpd
  import smtplib
  import io
  import re
  import sys
  import time
  import select
  import errno
  import textwrap
  import threading
  
  import unittest
  from test import support, mock_socket
  from test.support import HOST
  from test.support import threading_setup, threading_cleanup, join_thread
  from test.support import requires_hashdigest
  from unittest.mock import Mock
  
  
  if sys.platform == 'darwin':
      # select.poll returns a select.POLLHUP at the end of the tests
      # on darwin, so just ignore it
      def handle_expt(self):
          pass
      smtpd.SMTPChannel.handle_expt = handle_expt
  
  
  def server(evt, buf, serv):
      serv.listen()
      evt.set()
      try:
          conn, addr = serv.accept()
      except socket.timeout:
          pass
      else:
          n = 500
          while buf and n > 0:
              r, w, e = select.select([], [conn], [])
              if w:
                  sent = conn.send(buf)
                  buf = buf[sent:]
  
              n -= 1
  
          conn.close()
      finally:
          serv.close()
          evt.set()
  
  class GeneralTests(unittest.TestCase):
  
      def setUp(self):
          smtplib.socket = mock_socket
          self.port = 25
  
      def tearDown(self):
          smtplib.socket = socket
  
      # This method is no longer used but is retained for backward compatibility,
      # so test to make sure it still works.
      def testQuoteData(self):
          teststr  = "abc\n.jkl\rfoo\r\n..blue"
          expected = "abc\r\n..jkl\r\nfoo\r\n...blue"
          self.assertEqual(expected, smtplib.quotedata(teststr))
  
      def testBasic1(self):
          mock_socket.reply_with(b"220 Hola mundo")
          # connects
          smtp = smtplib.SMTP(HOST, self.port)
          smtp.close()
  
      def testSourceAddress(self):
          mock_socket.reply_with(b"220 Hola mundo")
          # connects
          smtp = smtplib.SMTP(HOST, self.port,
                  source_address=('127.0.0.1',19876))
          self.assertEqual(smtp.source_address, ('127.0.0.1', 19876))
          smtp.close()
  
      def testBasic2(self):
          mock_socket.reply_with(b"220 Hola mundo")
          # connects, include port in host name
          smtp = smtplib.SMTP("%s:%s" % (HOST, self.port))
          smtp.close()
  
      def testLocalHostName(self):
          mock_socket.reply_with(b"220 Hola mundo")
          # check that supplied local_hostname is used
          smtp = smtplib.SMTP(HOST, self.port, local_hostname="testhost")
          self.assertEqual(smtp.local_hostname, "testhost")
          smtp.close()
  
      def testTimeoutDefault(self):
          mock_socket.reply_with(b"220 Hola mundo")
          self.assertIsNone(mock_socket.getdefaulttimeout())
          mock_socket.setdefaulttimeout(30)
          self.assertEqual(mock_socket.getdefaulttimeout(), 30)
          try:
              smtp = smtplib.SMTP(HOST, self.port)
          finally:
              mock_socket.setdefaulttimeout(None)
          self.assertEqual(smtp.sock.gettimeout(), 30)
          smtp.close()
  
      def testTimeoutNone(self):
          mock_socket.reply_with(b"220 Hola mundo")
          self.assertIsNone(socket.getdefaulttimeout())
          socket.setdefaulttimeout(30)
          try:
              smtp = smtplib.SMTP(HOST, self.port, timeout=None)
          finally:
              socket.setdefaulttimeout(None)
          self.assertIsNone(smtp.sock.gettimeout())
          smtp.close()
  
      def testTimeoutValue(self):
          mock_socket.reply_with(b"220 Hola mundo")
          smtp = smtplib.SMTP(HOST, self.port, timeout=30)
          self.assertEqual(smtp.sock.gettimeout(), 30)
          smtp.close()
  
      def test_debuglevel(self):
          mock_socket.reply_with(b"220 Hello world")
          smtp = smtplib.SMTP()
          smtp.set_debuglevel(1)
          with support.captured_stderr() as stderr:
              smtp.connect(HOST, self.port)
          smtp.close()
          expected = re.compile(r"^connect:", re.MULTILINE)
          self.assertRegex(stderr.getvalue(), expected)
  
      def test_debuglevel_2(self):
          mock_socket.reply_with(b"220 Hello world")
          smtp = smtplib.SMTP()
          smtp.set_debuglevel(2)
          with support.captured_stderr() as stderr:
              smtp.connect(HOST, self.port)
          smtp.close()
          expected = re.compile(r"^\d{2}:\d{2}:\d{2}\.\d{6} connect: ",
                                re.MULTILINE)
          self.assertRegex(stderr.getvalue(), expected)
  
  
  # Test server thread using the specified SMTP server class
  def debugging_server(serv, serv_evt, client_evt):
      serv_evt.set()
  
      try:
          if hasattr(select, 'poll'):
              poll_fun = asyncore.poll2
          else:
              poll_fun = asyncore.poll
  
          n = 1000
          while asyncore.socket_map and n > 0:
              poll_fun(0.01, asyncore.socket_map)
  
              # when the client conversation is finished, it will
              # set client_evt, and it's then ok to kill the server
              if client_evt.is_set():
                  serv.close()
                  break
  
              n -= 1
  
      except socket.timeout:
          pass
      finally:
          if not client_evt.is_set():
              # allow some time for the client to read the result
              time.sleep(0.5)
              serv.close()
          asyncore.close_all()
          serv_evt.set()
  
  MSG_BEGIN = '---------- MESSAGE FOLLOWS ----------\n'
  MSG_END = '------------ END MESSAGE ------------\n'
  
  # NOTE: Some SMTP objects in the tests below are created with a non-default
  # local_hostname argument to the constructor, since (on some systems) the FQDN
  # lookup caused by the default local_hostname sometimes takes so long that the
  # test server times out, causing the test to fail.
  
  # Test behavior of smtpd.DebuggingServer
  class DebuggingServerTests(unittest.TestCase):
  
      maxDiff = None
  
      def setUp(self):
          self.thread_key = threading_setup()
          self.real_getfqdn = socket.getfqdn
          socket.getfqdn = mock_socket.getfqdn
          # temporarily replace sys.stdout to capture DebuggingServer output
          self.old_stdout = sys.stdout
          self.output = io.StringIO()
          sys.stdout = self.output
  
          self.serv_evt = threading.Event()
          self.client_evt = threading.Event()
          # Capture SMTPChannel debug output
          self.old_DEBUGSTREAM = smtpd.DEBUGSTREAM
          smtpd.DEBUGSTREAM = io.StringIO()
          # Pick a random unused port by passing 0 for the port number
          self.serv = smtpd.DebuggingServer((HOST, 0), ('nowhere', -1),
                                            decode_data=True)
          # Keep a note of what server host and port were assigned
          self.host, self.port = self.serv.socket.getsockname()[:2]
          serv_args = (self.serv, self.serv_evt, self.client_evt)
          self.thread = threading.Thread(target=debugging_server, args=serv_args)
          self.thread.start()
  
          # wait until server thread has assigned a port number
          self.serv_evt.wait()
          self.serv_evt.clear()
  
      def tearDown(self):
          socket.getfqdn = self.real_getfqdn
          # indicate that the client is finished
          self.client_evt.set()
          # wait for the server thread to terminate
          self.serv_evt.wait()
          join_thread(self.thread)
          # restore sys.stdout
          sys.stdout = self.old_stdout
          # restore DEBUGSTREAM
          smtpd.DEBUGSTREAM.close()
          smtpd.DEBUGSTREAM = self.old_DEBUGSTREAM
          del self.thread
          self.doCleanups()
          threading_cleanup(*self.thread_key)
  
      def get_output_without_xpeer(self):
          test_output = self.output.getvalue()
          return re.sub(r'(.*?)^X-Peer:\s*\S+\n(.*)', r'\1\2',
                        test_output, flags=re.MULTILINE|re.DOTALL)
  
      def testBasic(self):
          # connect
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          smtp.quit()
  
      def testSourceAddress(self):
          # connect
          src_port = support.find_unused_port()
          try:
              smtp = smtplib.SMTP(self.host, self.port, local_hostname='localhost',
                                  timeout=3, source_address=(self.host, src_port))
              self.addCleanup(smtp.close)
              self.assertEqual(smtp.source_address, (self.host, src_port))
              self.assertEqual(smtp.local_hostname, 'localhost')
              smtp.quit()
          except OSError as e:
              if e.errno == errno.EADDRINUSE:
                  self.skipTest("couldn't bind to source port %d" % src_port)
              raise
  
      def testNOOP(self):
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          expected = (250, b'OK')
          self.assertEqual(smtp.noop(), expected)
          smtp.quit()
  
      def testRSET(self):
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          expected = (250, b'OK')
          self.assertEqual(smtp.rset(), expected)
          smtp.quit()
  
      def testELHO(self):
          # EHLO isn't implemented in DebuggingServer
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          expected = (250, b'\nSIZE 33554432\nHELP')
          self.assertEqual(smtp.ehlo(), expected)
          smtp.quit()
  
      def testEXPNNotImplemented(self):
          # EXPN isn't implemented in DebuggingServer
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          expected = (502, b'EXPN not implemented')
          smtp.putcmd('EXPN')
          self.assertEqual(smtp.getreply(), expected)
          smtp.quit()
  
      def testVRFY(self):
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          expected = (252, b'Cannot VRFY user, but will accept message ' + \
                           b'and attempt delivery')
          self.assertEqual(smtp.vrfy('nobody@nowhere.com'), expected)
          self.assertEqual(smtp.verify('nobody@nowhere.com'), expected)
          smtp.quit()
  
      def testSecondHELO(self):
          # check that a second HELO returns a message that it's a duplicate
          # (this behavior is specific to smtpd.SMTPChannel)
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          smtp.helo()
          expected = (503, b'Duplicate HELO/EHLO')
          self.assertEqual(smtp.helo(), expected)
          smtp.quit()
  
      def testHELP(self):
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          self.assertEqual(smtp.help(), b'Supported commands: EHLO HELO MAIL ' + \
                                        b'RCPT DATA RSET NOOP QUIT VRFY')
          smtp.quit()
  
      def testSend(self):
          # connect and send mail
          m = 'A test message'
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          smtp.sendmail('John', 'Sally', m)
          # XXX(nnorwitz): this test is flaky and dies with a bad file descriptor
          # in asyncore.  This sleep might help, but should really be fixed
          # properly by using an Event variable.
          time.sleep(0.01)
          smtp.quit()
  
          self.client_evt.set()
          self.serv_evt.wait()
          self.output.flush()
          mexpect = '%s%s\n%s' % (MSG_BEGIN, m, MSG_END)
          self.assertEqual(self.output.getvalue(), mexpect)
  
      def testSendBinary(self):
          m = b'A test message'
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          smtp.sendmail('John', 'Sally', m)
          # XXX (see comment in testSend)
          time.sleep(0.01)
          smtp.quit()
  
          self.client_evt.set()
          self.serv_evt.wait()
          self.output.flush()
          mexpect = '%s%s\n%s' % (MSG_BEGIN, m.decode('ascii'), MSG_END)
          self.assertEqual(self.output.getvalue(), mexpect)
  
      def testSendNeedingDotQuote(self):
          # Issue 12283
          m = '.A test\n.mes.sage.'
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          smtp.sendmail('John', 'Sally', m)
          # XXX (see comment in testSend)
          time.sleep(0.01)
          smtp.quit()
  
          self.client_evt.set()
          self.serv_evt.wait()
          self.output.flush()
          mexpect = '%s%s\n%s' % (MSG_BEGIN, m, MSG_END)
          self.assertEqual(self.output.getvalue(), mexpect)
  
      def testSendNullSender(self):
          m = 'A test message'
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          smtp.sendmail('<>', 'Sally', m)
          # XXX (see comment in testSend)
          time.sleep(0.01)
          smtp.quit()
  
          self.client_evt.set()
          self.serv_evt.wait()
          self.output.flush()
          mexpect = '%s%s\n%s' % (MSG_BEGIN, m, MSG_END)
          self.assertEqual(self.output.getvalue(), mexpect)
          debugout = smtpd.DEBUGSTREAM.getvalue()
          sender = re.compile("^sender: <>$", re.MULTILINE)
          self.assertRegex(debugout, sender)
  
      def testSendMessage(self):
          m = email.mime.text.MIMEText('A test message')
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          smtp.send_message(m, from_addr='John', to_addrs='Sally')
          # XXX (see comment in testSend)
          time.sleep(0.01)
          smtp.quit()
  
          self.client_evt.set()
          self.serv_evt.wait()
          self.output.flush()
          # Remove the X-Peer header that DebuggingServer adds as figuring out
          # exactly what IP address format is put there is not easy (and
          # irrelevant to our test).  Typically 127.0.0.1 or ::1, but it is
          # not always the same as socket.gethostbyname(HOST). :(
          test_output = self.get_output_without_xpeer()
          del m['X-Peer']
          mexpect = '%s%s\n%s' % (MSG_BEGIN, m.as_string(), MSG_END)
          self.assertEqual(test_output, mexpect)
  
      def testSendMessageWithAddresses(self):
          m = email.mime.text.MIMEText('A test message')
          m['From'] = 'foo@bar.com'
          m['To'] = 'John'
          m['CC'] = 'Sally, Fred'
          m['Bcc'] = 'John Root <root@localhost>, "Dinsdale" <warped@silly.walks.com>'
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          smtp.send_message(m)
          # XXX (see comment in testSend)
          time.sleep(0.01)
          smtp.quit()
          # make sure the Bcc header is still in the message.
          self.assertEqual(m['Bcc'], 'John Root <root@localhost>, "Dinsdale" '
                                      '<warped@silly.walks.com>')
  
          self.client_evt.set()
          self.serv_evt.wait()
          self.output.flush()
          # Remove the X-Peer header that DebuggingServer adds.
          test_output = self.get_output_without_xpeer()
          del m['X-Peer']
          # The Bcc header should not be transmitted.
          del m['Bcc']
          mexpect = '%s%s\n%s' % (MSG_BEGIN, m.as_string(), MSG_END)
          self.assertEqual(test_output, mexpect)
          debugout = smtpd.DEBUGSTREAM.getvalue()
          sender = re.compile("^sender: foo@bar.com$", re.MULTILINE)
          self.assertRegex(debugout, sender)
          for addr in ('John', 'Sally', 'Fred', 'root@localhost',
                       'warped@silly.walks.com'):
              to_addr = re.compile(r"^recips: .*'{}'.*$".format(addr),
                                   re.MULTILINE)
              self.assertRegex(debugout, to_addr)
  
      def testSendMessageWithSomeAddresses(self):
          # Make sure nothing breaks if not all of the three 'to' headers exist
          m = email.mime.text.MIMEText('A test message')
          m['From'] = 'foo@bar.com'
          m['To'] = 'John, Dinsdale'
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          smtp.send_message(m)
          # XXX (see comment in testSend)
          time.sleep(0.01)
          smtp.quit()
  
          self.client_evt.set()
          self.serv_evt.wait()
          self.output.flush()
          # Remove the X-Peer header that DebuggingServer adds.
          test_output = self.get_output_without_xpeer()
          del m['X-Peer']
          mexpect = '%s%s\n%s' % (MSG_BEGIN, m.as_string(), MSG_END)
          self.assertEqual(test_output, mexpect)
          debugout = smtpd.DEBUGSTREAM.getvalue()
          sender = re.compile("^sender: foo@bar.com$", re.MULTILINE)
          self.assertRegex(debugout, sender)
          for addr in ('John', 'Dinsdale'):
              to_addr = re.compile(r"^recips: .*'{}'.*$".format(addr),
                                   re.MULTILINE)
              self.assertRegex(debugout, to_addr)
  
      def testSendMessageWithSpecifiedAddresses(self):
          # Make sure addresses specified in call override those in message.
          m = email.mime.text.MIMEText('A test message')
          m['From'] = 'foo@bar.com'
          m['To'] = 'John, Dinsdale'
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          smtp.send_message(m, from_addr='joe@example.com', to_addrs='foo@example.net')
          # XXX (see comment in testSend)
          time.sleep(0.01)
          smtp.quit()
  
          self.client_evt.set()
          self.serv_evt.wait()
          self.output.flush()
          # Remove the X-Peer header that DebuggingServer adds.
          test_output = self.get_output_without_xpeer()
          del m['X-Peer']
          mexpect = '%s%s\n%s' % (MSG_BEGIN, m.as_string(), MSG_END)
          self.assertEqual(test_output, mexpect)
          debugout = smtpd.DEBUGSTREAM.getvalue()
          sender = re.compile("^sender: joe@example.com$", re.MULTILINE)
          self.assertRegex(debugout, sender)
          for addr in ('John', 'Dinsdale'):
              to_addr = re.compile(r"^recips: .*'{}'.*$".format(addr),
                                   re.MULTILINE)
              self.assertNotRegex(debugout, to_addr)
          recip = re.compile(r"^recips: .*'foo@example.net'.*$", re.MULTILINE)
          self.assertRegex(debugout, recip)
  
      def testSendMessageWithMultipleFrom(self):
          # Sender overrides To
          m = email.mime.text.MIMEText('A test message')
          m['From'] = 'Bernard, Bianca'
          m['Sender'] = 'the_rescuers@Rescue-Aid-Society.com'
          m['To'] = 'John, Dinsdale'
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          smtp.send_message(m)
          # XXX (see comment in testSend)
          time.sleep(0.01)
          smtp.quit()
  
          self.client_evt.set()
          self.serv_evt.wait()
          self.output.flush()
          # Remove the X-Peer header that DebuggingServer adds.
          test_output = self.get_output_without_xpeer()
          del m['X-Peer']
          mexpect = '%s%s\n%s' % (MSG_BEGIN, m.as_string(), MSG_END)
          self.assertEqual(test_output, mexpect)
          debugout = smtpd.DEBUGSTREAM.getvalue()
          sender = re.compile("^sender: the_rescuers@Rescue-Aid-Society.com$", re.MULTILINE)
          self.assertRegex(debugout, sender)
          for addr in ('John', 'Dinsdale'):
              to_addr = re.compile(r"^recips: .*'{}'.*$".format(addr),
                                   re.MULTILINE)
              self.assertRegex(debugout, to_addr)
  
      def testSendMessageResent(self):
          m = email.mime.text.MIMEText('A test message')
          m['From'] = 'foo@bar.com'
          m['To'] = 'John'
          m['CC'] = 'Sally, Fred'
          m['Bcc'] = 'John Root <root@localhost>, "Dinsdale" <warped@silly.walks.com>'
          m['Resent-Date'] = 'Thu, 1 Jan 1970 17:42:00 +0000'
          m['Resent-From'] = 'holy@grail.net'
          m['Resent-To'] = 'Martha <my_mom@great.cooker.com>, Jeff'
          m['Resent-Bcc'] = 'doe@losthope.net'
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          smtp.send_message(m)
          # XXX (see comment in testSend)
          time.sleep(0.01)
          smtp.quit()
  
          self.client_evt.set()
          self.serv_evt.wait()
          self.output.flush()
          # The Resent-Bcc headers are deleted before serialization.
          del m['Bcc']
          del m['Resent-Bcc']
          # Remove the X-Peer header that DebuggingServer adds.
          test_output = self.get_output_without_xpeer()
          del m['X-Peer']
          mexpect = '%s%s\n%s' % (MSG_BEGIN, m.as_string(), MSG_END)
          self.assertEqual(test_output, mexpect)
          debugout = smtpd.DEBUGSTREAM.getvalue()
          sender = re.compile("^sender: holy@grail.net$", re.MULTILINE)
          self.assertRegex(debugout, sender)
          for addr in ('my_mom@great.cooker.com', 'Jeff', 'doe@losthope.net'):
              to_addr = re.compile(r"^recips: .*'{}'.*$".format(addr),
                                   re.MULTILINE)
              self.assertRegex(debugout, to_addr)
  
      def testSendMessageMultipleResentRaises(self):
          m = email.mime.text.MIMEText('A test message')
          m['From'] = 'foo@bar.com'
          m['To'] = 'John'
          m['CC'] = 'Sally, Fred'
          m['Bcc'] = 'John Root <root@localhost>, "Dinsdale" <warped@silly.walks.com>'
          m['Resent-Date'] = 'Thu, 1 Jan 1970 17:42:00 +0000'
          m['Resent-From'] = 'holy@grail.net'
          m['Resent-To'] = 'Martha <my_mom@great.cooker.com>, Jeff'
          m['Resent-Bcc'] = 'doe@losthope.net'
          m['Resent-Date'] = 'Thu, 2 Jan 1970 17:42:00 +0000'
          m['Resent-To'] = 'holy@grail.net'
          m['Resent-From'] = 'Martha <my_mom@great.cooker.com>, Jeff'
          smtp = smtplib.SMTP(HOST, self.port, local_hostname='localhost', timeout=3)
          self.addCleanup(smtp.close)
          with self.assertRaises(ValueError):
              smtp.send_message(m)
          smtp.close()
  
  class NonConnectingTests(unittest.TestCase):
  
      def testNotConnected(self):
          # Test various operations on an unconnected SMTP object that
          # should raise exceptions (at present the attempt in SMTP.send
          # to reference the nonexistent 'sock' attribute of the SMTP object
          # causes an AttributeError)
          smtp = smtplib.SMTP()
          self.assertRaises(smtplib.SMTPServerDisconnected, smtp.ehlo)
          self.assertRaises(smtplib.SMTPServerDisconnected,
                            smtp.send, 'test msg')
  
      def testNonnumericPort(self):
          # check that non-numeric port raises OSError
          self.assertRaises(OSError, smtplib.SMTP,
                            "localhost", "bogus")
          self.assertRaises(OSError, smtplib.SMTP,
                            "localhost:bogus")
  
      def testSockAttributeExists(self):
          # check that sock attribute is present outside of a connect() call
          # (regression test, the previous behavior raised an
          #  AttributeError: 'SMTP' object has no attribute 'sock')
          with smtplib.SMTP() as smtp:
              self.assertIsNone(smtp.sock)
  
  
  class DefaultArgumentsTests(unittest.TestCase):
  
      def setUp(self):
          self.msg = EmailMessage()
