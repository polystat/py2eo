python: |
  from test import support
  
  from contextlib import contextmanager
  import imaplib
  import os.path
  import socketserver
  import time
  import calendar
  import threading
  import socket
  
  from test.support import (reap_threads, verbose, transient_internet,
                            run_with_tz, run_with_locale, cpython_only,
                            requires_hashdigest)
  import unittest
  from unittest import mock
  from datetime import datetime, timezone, timedelta
  try:
      import ssl
  except ImportError:
      ssl = None
  
  CERTFILE = os.path.join(os.path.dirname(__file__) or os.curdir, "keycert3.pem")
  CAFILE = os.path.join(os.path.dirname(__file__) or os.curdir, "pycacert.pem")
  
  
  class TestImaplib(unittest.TestCase):
  
      def test_Internaldate2tuple(self):
          t0 = calendar.timegm((2000, 1, 1, 0, 0, 0, -1, -1, -1))
          tt = imaplib.Internaldate2tuple(
              b'25 (INTERNALDATE "01-Jan-2000 00:00:00 +0000")')
          self.assertEqual(time.mktime(tt), t0)
          tt = imaplib.Internaldate2tuple(
              b'25 (INTERNALDATE "01-Jan-2000 11:30:00 +1130")')
          self.assertEqual(time.mktime(tt), t0)
          tt = imaplib.Internaldate2tuple(
              b'25 (INTERNALDATE "31-Dec-1999 12:30:00 -1130")')
          self.assertEqual(time.mktime(tt), t0)
  
      @run_with_tz('MST+07MDT,M4.1.0,M10.5.0')
      def test_Internaldate2tuple_issue10941(self):
          self.assertNotEqual(imaplib.Internaldate2tuple(
              b'25 (INTERNALDATE "02-Apr-2000 02:30:00 +0000")'),
              imaplib.Internaldate2tuple(
                  b'25 (INTERNALDATE "02-Apr-2000 03:30:00 +0000")'))
  
      def timevalues(self):
          return [2000000000, 2000000000.0, time.localtime(2000000000),
                  (2033, 5, 18, 5, 33, 20, -1, -1, -1),
                  (2033, 5, 18, 5, 33, 20, -1, -1, 1),
                  datetime.fromtimestamp(2000000000,
                                         timezone(timedelta(0, 2 * 60 * 60))),
                  '"18-May-2033 05:33:20 +0200"']
  
      @run_with_locale('LC_ALL', 'de_DE', 'fr_FR')
      # DST rules included to work around quirk where the Gnu C library may not
      # otherwise restore the previous time zone
      @run_with_tz('STD-1DST,M3.2.0,M11.1.0')
      def test_Time2Internaldate(self):
          expected = '"18-May-2033 05:33:20 +0200"'
  
          for t in self.timevalues():
              internal = imaplib.Time2Internaldate(t)
              self.assertEqual(internal, expected)
  
      def test_that_Time2Internaldate_returns_a_result(self):
          # Without tzset, we can check only that it successfully
          # produces a result, not the correctness of the result itself,
          # since the result depends on the timezone the machine is in.
          for t in self.timevalues():
              imaplib.Time2Internaldate(t)
  
      def test_imap4_host_default_value(self):
          # Check whether the IMAP4_PORT is truly unavailable.
          with socket.socket() as s:
              try:
                  s.connect(('', imaplib.IMAP4_PORT))
                  self.skipTest(
                      "Cannot run the test with local IMAP server running.")
              except socket.error:
                  pass
  
          # This is the exception that should be raised.
          expected_errnos = support.get_socket_conn_refused_errs()
          with self.assertRaises(OSError) as cm:
              imaplib.IMAP4()
          self.assertIn(cm.exception.errno, expected_errnos)
  
  
  if ssl:
      class SecureTCPServer(socketserver.TCPServer):
  
          def get_request(self):
              newsocket, fromaddr = self.socket.accept()
              context = ssl.SSLContext()
              context.load_cert_chain(CERTFILE)
              connstream = context.wrap_socket(newsocket, server_side=True)
              return connstream, fromaddr
  
      IMAP4_SSL = imaplib.IMAP4_SSL
  
  else:
  
      class SecureTCPServer:
          pass
  
      IMAP4_SSL = None
  
  
  class SimpleIMAPHandler(socketserver.StreamRequestHandler):
      timeout = 1
      continuation = None
      capabilities = ''
  
      def setup(self):
          super().setup()
          self.server.logged = None
  
      def _send(self, message):
          if verbose:
              print("SENT: %r" % message.strip())
          self.wfile.write(message)
  
      def _send_line(self, message):
          self._send(message + b'\r\n')
  
      def _send_textline(self, message):
          self._send_line(message.encode('ASCII'))
  
      def _send_tagged(self, tag, code, message):
          self._send_textline(' '.join((tag, code, message)))
  
      def handle(self):
          # Send a welcome message.
          self._send_textline('* OK IMAP4rev1')
          while 1:
              # Gather up input until we receive a line terminator or we timeout.
              # Accumulate read(1) because it's simpler to handle the differences
              # between naked sockets and SSL sockets.
              line = b''
              while 1:
                  try:
                      part = self.rfile.read(1)
                      if part == b'':
                          # Naked sockets return empty strings..
                          return
                      line += part
                  except OSError:
                      # ..but SSLSockets raise exceptions.
                      return
                  if line.endswith(b'\r\n'):
                      break
  
              if verbose:
                  print('GOT: %r' % line.strip())
              if self.continuation:
                  try:
                      self.continuation.send(line)
                  except StopIteration:
                      self.continuation = None
                  continue
              splitline = line.decode('ASCII').split()
              tag = splitline[0]
              cmd = splitline[1]
              args = splitline[2:]
  
              if hasattr(self, 'cmd_' + cmd):
                  continuation = getattr(self, 'cmd_' + cmd)(tag, args)
                  if continuation:
                      self.continuation = continuation
                      next(continuation)
              else:
                  self._send_tagged(tag, 'BAD', cmd + ' unknown')
  
      def cmd_CAPABILITY(self, tag, args):
          caps = ('IMAP4rev1 ' + self.capabilities
                  if self.capabilities
                  else 'IMAP4rev1')
          self._send_textline('* CAPABILITY ' + caps)
          self._send_tagged(tag, 'OK', 'CAPABILITY completed')
  
      def cmd_LOGOUT(self, tag, args):
          self.server.logged = None
          self._send_textline('* BYE IMAP4ref1 Server logging out')
          self._send_tagged(tag, 'OK', 'LOGOUT completed')
  
      def cmd_LOGIN(self, tag, args):
          self.server.logged = args[0]
          self._send_tagged(tag, 'OK', 'LOGIN completed')
  
  
  class NewIMAPTestsMixin():
      client = None
  
      def _setup(self, imap_handler, connect=True):
          """
          Sets up imap_handler for tests. imap_handler should inherit from either:
          - SimpleIMAPHandler - for testing IMAP commands,
          - socketserver.StreamRequestHandler - if raw access to stream is needed.
          Returns (client, server).
          """
          class TestTCPServer(self.server_class):
              def handle_error(self, request, client_address):
                  """
                  End request and raise the error if one occurs.
                  """
                  self.close_request(request)
                  self.server_close()
                  raise
  
          self.addCleanup(self._cleanup)
          self.server = self.server_class((support.HOST, 0), imap_handler)
          self.thread = threading.Thread(
              name=self._testMethodName+'-server',
              target=self.server.serve_forever,
              # Short poll interval to make the test finish quickly.
              # Time between requests is short enough that we won't wake
              # up spuriously too many times.
              kwargs={'poll_interval': 0.01})
          self.thread.daemon = True  # In case this function raises.
          self.thread.start()
  
          if connect:
              self.client = self.imap_class(*self.server.server_address)
  
          return self.client, self.server
  
      def _cleanup(self):
          """
          Cleans up the test server. This method should not be called manually,
          it is added to the cleanup queue in the _setup method already.
          """
          # if logout was called already we'd raise an exception trying to
          # shutdown the client once again
          if self.client is not None and self.client.state != 'LOGOUT':
              self.client.shutdown()
          # cleanup the server
          self.server.shutdown()
          self.server.server_close()
          support.join_thread(self.thread, 3.0)
          # Explicitly clear the attribute to prevent dangling thread
          self.thread = None
  
      def test_EOF_without_complete_welcome_message(self):
          # http://bugs.python.org/issue5949
          class EOFHandler(socketserver.StreamRequestHandler):
              def handle(self):
                  self.wfile.write(b'* OK')
          _, server = self._setup(EOFHandler, connect=False)
          self.assertRaises(imaplib.IMAP4.abort, self.imap_class,
                            *server.server_address)
  
      def test_line_termination(self):
          class BadNewlineHandler(SimpleIMAPHandler):
              def cmd_CAPABILITY(self, tag, args):
                  self._send(b'* CAPABILITY IMAP4rev1 AUTH\n')
                  self._send_tagged(tag, 'OK', 'CAPABILITY completed')
          _, server = self._setup(BadNewlineHandler, connect=False)
          self.assertRaises(imaplib.IMAP4.abort, self.imap_class,
                            *server.server_address)
  
      def test_enable_raises_error_if_not_AUTH(self):
          class EnableHandler(SimpleIMAPHandler):
              capabilities = 'AUTH ENABLE UTF8=ACCEPT'
          client, _ = self._setup(EnableHandler)
          self.assertFalse(client.utf8_enabled)
          with self.assertRaisesRegex(imaplib.IMAP4.error, 'ENABLE.*NONAUTH'):
              client.enable('foo')
          self.assertFalse(client.utf8_enabled)
  
      def test_enable_raises_error_if_no_capability(self):
          client, _ = self._setup(SimpleIMAPHandler)
          with self.assertRaisesRegex(imaplib.IMAP4.error,
                  'does not support ENABLE'):
              client.enable('foo')
  
      def test_enable_UTF8_raises_error_if_not_supported(self):
          client, _ = self._setup(SimpleIMAPHandler)
          typ, data = client.login('user', 'pass')
          self.assertEqual(typ, 'OK')
          with self.assertRaisesRegex(imaplib.IMAP4.error,
                  'does not support ENABLE'):
              client.enable('UTF8=ACCEPT')
  
      def test_enable_UTF8_True_append(self):
          class UTF8AppendServer(SimpleIMAPHandler):
              capabilities = 'ENABLE UTF8=ACCEPT'
              def cmd_ENABLE(self, tag, args):
                  self._send_tagged(tag, 'OK', 'ENABLE successful')
              def cmd_AUTHENTICATE(self, tag, args):
                  self._send_textline('+')
                  self.server.response = yield
                  self._send_tagged(tag, 'OK', 'FAKEAUTH successful')
              def cmd_APPEND(self, tag, args):
                  self._send_textline('+')
                  self.server.response = yield
                  self._send_tagged(tag, 'OK', 'okay')
          client, server = self._setup(UTF8AppendServer)
          self.assertEqual(client._encoding, 'ascii')
          code, _ = client.authenticate('MYAUTH', lambda x: b'fake')
          self.assertEqual(code, 'OK')
          self.assertEqual(server.response, b'ZmFrZQ==\r\n')  # b64 encoded 'fake'
          code, _ = client.enable('UTF8=ACCEPT')
          self.assertEqual(code, 'OK')
          self.assertEqual(client._encoding, 'utf-8')
