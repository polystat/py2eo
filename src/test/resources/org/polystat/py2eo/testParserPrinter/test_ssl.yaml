python: |
  # Test the support for SSL and sockets
  
  import sys
  import unittest
  import unittest.mock
  from test import support
  import socket
  import select
  import time
  import datetime
  import gc
  import os
  import errno
  import pprint
  import urllib.request
  import threading
  import traceback
  import asyncore
  import weakref
  import platform
  import sysconfig
  import functools
  try:
      import ctypes
  except ImportError:
      ctypes = None
  
  ssl = support.import_module("ssl")
  
  from ssl import TLSVersion, _TLSContentType, _TLSMessageType
  
  PROTOCOLS = sorted(ssl._PROTOCOL_NAMES)
  HOST = support.HOST
  IS_LIBRESSL = ssl.OPENSSL_VERSION.startswith('LibreSSL')
  IS_OPENSSL_1_1_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 0)
  IS_OPENSSL_1_1_1 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 1)
  IS_OPENSSL_3_0_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (3, 0, 0)
  PY_SSL_DEFAULT_CIPHERS = sysconfig.get_config_var('PY_SSL_DEFAULT_CIPHERS')
  
  PROTOCOL_TO_TLS_VERSION = {}
  for proto, ver in (
      ("PROTOCOL_SSLv23", "SSLv3"),
      ("PROTOCOL_TLSv1", "TLSv1"),
      ("PROTOCOL_TLSv1_1", "TLSv1_1"),
  ):
      try:
          proto = getattr(ssl, proto)
          ver = getattr(ssl.TLSVersion, ver)
      except AttributeError:
          continue
      PROTOCOL_TO_TLS_VERSION[proto] = ver
  
  def data_file(*name):
      return os.path.join(os.path.dirname(__file__), *name)
  
  # The custom key and certificate files used in test_ssl are generated
  # using Lib/test/make_ssl_certs.py.
  # Other certificates are simply fetched from the Internet servers they
  # are meant to authenticate.
  
  CERTFILE = data_file("keycert.pem")
  BYTES_CERTFILE = os.fsencode(CERTFILE)
  ONLYCERT = data_file("ssl_cert.pem")
  ONLYKEY = data_file("ssl_key.pem")
  BYTES_ONLYCERT = os.fsencode(ONLYCERT)
  BYTES_ONLYKEY = os.fsencode(ONLYKEY)
  CERTFILE_PROTECTED = data_file("keycert.passwd.pem")
  ONLYKEY_PROTECTED = data_file("ssl_key.passwd.pem")
  KEY_PASSWORD = "somepass"
  CAPATH = data_file("capath")
  BYTES_CAPATH = os.fsencode(CAPATH)
  CAFILE_NEURONIO = data_file("capath", "4e1295a3.0")
  CAFILE_CACERT = data_file("capath", "5ed36f99.0")
  
  CERTFILE_INFO = {
      'issuer': ((('countryName', 'XY'),),
                 (('localityName', 'Castle Anthrax'),),
                 (('organizationName', 'Python Software Foundation'),),
                 (('commonName', 'localhost'),)),
      'notAfter': 'Aug 26 14:23:15 2028 GMT',
      'notBefore': 'Aug 29 14:23:15 2018 GMT',
      'serialNumber': '98A7CF88C74A32ED',
      'subject': ((('countryName', 'XY'),),
               (('localityName', 'Castle Anthrax'),),
               (('organizationName', 'Python Software Foundation'),),
               (('commonName', 'localhost'),)),
      'subjectAltName': (('DNS', 'localhost'),),
      'version': 3
  }
  
  # empty CRL
  CRLFILE = data_file("revocation.crl")
  
  # Two keys and certs signed by the same CA (for SNI tests)
  SIGNED_CERTFILE = data_file("keycert3.pem")
  SIGNED_CERTFILE_HOSTNAME = 'localhost'
  
  SIGNED_CERTFILE_INFO = {
      'OCSP': ('http://testca.pythontest.net/testca/ocsp/',),
      'caIssuers': ('http://testca.pythontest.net/testca/pycacert.cer',),
      'crlDistributionPoints': ('http://testca.pythontest.net/testca/revocation.crl',),
      'issuer': ((('countryName', 'XY'),),
              (('organizationName', 'Python Software Foundation CA'),),
              (('commonName', 'our-ca-server'),)),
      'notAfter': 'Oct 28 14:23:16 2037 GMT',
      'notBefore': 'Aug 29 14:23:16 2018 GMT',
      'serialNumber': 'CB2D80995A69525C',
      'subject': ((('countryName', 'XY'),),
               (('localityName', 'Castle Anthrax'),),
               (('organizationName', 'Python Software Foundation'),),
               (('commonName', 'localhost'),)),
      'subjectAltName': (('DNS', 'localhost'),),
      'version': 3
  }
  
  SIGNED_CERTFILE2 = data_file("keycert4.pem")
  SIGNED_CERTFILE2_HOSTNAME = 'fakehostname'
  SIGNED_CERTFILE_ECC = data_file("keycertecc.pem")
  SIGNED_CERTFILE_ECC_HOSTNAME = 'localhost-ecc'
  
  # Same certificate as pycacert.pem, but without extra text in file
  SIGNING_CA = data_file("capath", "ceff1710.0")
  # cert with all kinds of subject alt names
  ALLSANFILE = data_file("allsans.pem")
  IDNSANSFILE = data_file("idnsans.pem")
  NOSANFILE = data_file("nosan.pem")
  NOSAN_HOSTNAME = 'localhost'
  
  REMOTE_HOST = "self-signed.pythontest.net"
  
  EMPTYCERT = data_file("nullcert.pem")
  BADCERT = data_file("badcert.pem")
  NONEXISTINGCERT = data_file("XXXnonexisting.pem")
  BADKEY = data_file("badkey.pem")
  NOKIACERT = data_file("nokia.pem")
  NULLBYTECERT = data_file("nullbytecert.pem")
  TALOS_INVALID_CRLDP = data_file("talos-2019-0758.pem")
  
  DHFILE = data_file("ffdh3072.pem")
  BYTES_DHFILE = os.fsencode(DHFILE)
  
  # Not defined in all versions of OpenSSL
  OP_NO_COMPRESSION = getattr(ssl, "OP_NO_COMPRESSION", 0)
  OP_SINGLE_DH_USE = getattr(ssl, "OP_SINGLE_DH_USE", 0)
  OP_SINGLE_ECDH_USE = getattr(ssl, "OP_SINGLE_ECDH_USE", 0)
  OP_CIPHER_SERVER_PREFERENCE = getattr(ssl, "OP_CIPHER_SERVER_PREFERENCE", 0)
  OP_ENABLE_MIDDLEBOX_COMPAT = getattr(ssl, "OP_ENABLE_MIDDLEBOX_COMPAT", 0)
  OP_IGNORE_UNEXPECTED_EOF = getattr(ssl, "OP_IGNORE_UNEXPECTED_EOF", 0)
  
  # Ubuntu has patched OpenSSL and changed behavior of security level 2
  # see https://bugs.python.org/issue41561#msg389003
  def is_ubuntu():
      try:
          # Assume that any references of "ubuntu" implies Ubuntu-like distro
          # The workaround is not required for 18.04, but doesn't hurt either.
          with open("/etc/os-release", encoding="utf-8") as f:
              return "ubuntu" in f.read()
      except FileNotFoundError:
          return False
  
  if is_ubuntu():
      def seclevel_workaround(*ctxs):
          """"Lower security level to '1' and allow all ciphers for TLS 1.0/1"""
          for ctx in ctxs:
              if (
                  hasattr(ctx, "minimum_version") and
                  ctx.minimum_version <= ssl.TLSVersion.TLSv1_1
              ):
                  ctx.set_ciphers("@SECLEVEL=1:ALL")
  else:
      def seclevel_workaround(*ctxs):
          pass
  
  
  def has_tls_protocol(protocol):
      """Check if a TLS protocol is available and enabled
  
      :param protocol: enum ssl._SSLMethod member or name
      :return: bool
      """
      if isinstance(protocol, str):
          assert protocol.startswith('PROTOCOL_')
          protocol = getattr(ssl, protocol, None)
          if protocol is None:
              return False
      if protocol in {
          ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLS_SERVER,
          ssl.PROTOCOL_TLS_CLIENT
      }:
          # auto-negotiate protocols are always available
          return True
      name = protocol.name
      return has_tls_version(name[len('PROTOCOL_'):])
  
  
  @functools.lru_cache
  def has_tls_version(version):
      """Check if a TLS/SSL version is enabled
  
      :param version: TLS version name or ssl.TLSVersion member
      :return: bool
      """
      if version == "SSLv2":
          # never supported and not even in TLSVersion enum
          return False
  
      if isinstance(version, str):
          version = ssl.TLSVersion.__members__[version]
  
      # check compile time flags like ssl.HAS_TLSv1_2
      if not getattr(ssl, f'HAS_{version.name}'):
          return False
  
      if IS_OPENSSL_3_0_0 and version < ssl.TLSVersion.TLSv1_2:
          # bpo43791: 3.0.0-alpha14 fails with TLSV1_ALERT_INTERNAL_ERROR
          return False
  
      # check runtime and dynamic crypto policy settings. A TLS version may
      # be compiled in but disabled by a policy or config option.
      ctx = ssl.SSLContext()
      if (
              hasattr(ctx, 'minimum_version') and
              ctx.minimum_version != ssl.TLSVersion.MINIMUM_SUPPORTED and
              version < ctx.minimum_version
      ):
          return False
      if (
          hasattr(ctx, 'maximum_version') and
          ctx.maximum_version != ssl.TLSVersion.MAXIMUM_SUPPORTED and
          version > ctx.maximum_version
      ):
          return False
  
      return True
  
  
  def requires_tls_version(version):
      """Decorator to skip tests when a required TLS version is not available
  
      :param version: TLS version name or ssl.TLSVersion member
      :return:
      """
      def decorator(func):
          @functools.wraps(func)
          def wrapper(*args, **kw):
              if not has_tls_version(version):
                  raise unittest.SkipTest(f"{version} is not available.")
              else:
                  return func(*args, **kw)
          return wrapper
      return decorator
  
  
  requires_minimum_version = unittest.skipUnless(
      hasattr(ssl.SSLContext, 'minimum_version'),
      "required OpenSSL >= 1.1.0g"
  )
  
  
  def handle_error(prefix):
      exc_format = ' '.join(traceback.format_exception(*sys.exc_info()))
      if support.verbose:
          sys.stdout.write(prefix + exc_format)
  
  def can_clear_options():
      # 0.9.8m or higher
      return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)
  
  def no_sslv2_implies_sslv3_hello():
      # 0.9.7h or higher
      return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)
  
  def have_verify_flags():
      # 0.9.8 or higher
      return ssl.OPENSSL_VERSION_INFO >= (0, 9, 8, 0, 15)
  
  def _have_secp_curves():
      if not ssl.HAS_ECDH:
          return False
      ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
      try:
          ctx.set_ecdh_curve("secp384r1")
      except ValueError:
          return False
      else:
          return True
  
  
  HAVE_SECP_CURVES = _have_secp_curves()
  
  
  def utc_offset(): #NOTE: ignore issues like #1647654
      # local time = utc time + utc offset
      if time.daylight and time.localtime().tm_isdst > 0:
          return -time.altzone  # seconds
      return -time.timezone
  
  def asn1time(cert_time):
      # Some versions of OpenSSL ignore seconds, see #18207
      # 0.9.8.i
      if ssl._OPENSSL_API_VERSION == (0, 9, 8, 9, 15):
          fmt = "%b %d %H:%M:%S %Y GMT"
          dt = datetime.datetime.strptime(cert_time, fmt)
          dt = dt.replace(second=0)
          cert_time = dt.strftime(fmt)
          # %d adds leading zero but ASN1_TIME_print() uses leading space
          if cert_time[4] == "0":
              cert_time = cert_time[:4] + " " + cert_time[5:]
  
      return cert_time
  
  needs_sni = unittest.skipUnless(ssl.HAS_SNI, "SNI support needed for this test")
  
  
  def test_wrap_socket(sock, ssl_version=ssl.PROTOCOL_TLS, *,
                       cert_reqs=ssl.CERT_NONE, ca_certs=None,
                       ciphers=None, certfile=None, keyfile=None,
                       **kwargs):
      context = ssl.SSLContext(ssl_version)
      if cert_reqs is not None:
          if cert_reqs == ssl.CERT_NONE:
              context.check_hostname = False
          context.verify_mode = cert_reqs
      if ca_certs is not None:
          context.load_verify_locations(ca_certs)
      if certfile is not None or keyfile is not None:
          context.load_cert_chain(certfile, keyfile)
      if ciphers is not None:
          context.set_ciphers(ciphers)
      return context.wrap_socket(sock, **kwargs)
  
  
  def testing_context(server_cert=SIGNED_CERTFILE):
      """Create context
  
      client_context, server_context, hostname = testing_context()
      """
      if server_cert == SIGNED_CERTFILE:
          hostname = SIGNED_CERTFILE_HOSTNAME
      elif server_cert == SIGNED_CERTFILE2:
          hostname = SIGNED_CERTFILE2_HOSTNAME
      elif server_cert == NOSANFILE:
          hostname = NOSAN_HOSTNAME
      else:
          raise ValueError(server_cert)
  
      client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
      client_context.load_verify_locations(SIGNING_CA)
  
      server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
      server_context.load_cert_chain(server_cert)
      server_context.load_verify_locations(SIGNING_CA)
  
      return client_context, server_context, hostname
  
  
  class BasicSocketTests(unittest.TestCase):
  
      def test_constants(self):
          ssl.CERT_NONE
          ssl.CERT_OPTIONAL
          ssl.CERT_REQUIRED
          ssl.OP_CIPHER_SERVER_PREFERENCE
          ssl.OP_SINGLE_DH_USE
          if ssl.HAS_ECDH:
              ssl.OP_SINGLE_ECDH_USE
          if ssl.OPENSSL_VERSION_INFO >= (1, 0):
              ssl.OP_NO_COMPRESSION
          self.assertIn(ssl.HAS_SNI, {True, False})
          self.assertIn(ssl.HAS_ECDH, {True, False})
          ssl.OP_NO_SSLv2
          ssl.OP_NO_SSLv3
          ssl.OP_NO_TLSv1
          ssl.OP_NO_TLSv1_3
          if ssl.OPENSSL_VERSION_INFO >= (1, 0, 1):
              ssl.OP_NO_TLSv1_1
              ssl.OP_NO_TLSv1_2
          self.assertEqual(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv23)
  
      def test_private_init(self):
          with self.assertRaisesRegex(TypeError, "public constructor"):
              with socket.socket() as s:
                  ssl.SSLSocket(s)
  
      def test_str_for_enums(self):
          # Make sure that the PROTOCOL_* constants have enum-like string
          # reprs.
          proto = ssl.PROTOCOL_TLS
          self.assertEqual(str(proto), '_SSLMethod.PROTOCOL_TLS')
          ctx = ssl.SSLContext(proto)
          self.assertIs(ctx.protocol, proto)
  
      def test_random(self):
          v = ssl.RAND_status()
          if support.verbose:
              sys.stdout.write("\n RAND_status is %d (%s)\n"
                               % (v, (v and "sufficient randomness") or
                                  "insufficient randomness"))
  
          data, is_cryptographic = ssl.RAND_pseudo_bytes(16)
          self.assertEqual(len(data), 16)
          self.assertEqual(is_cryptographic, v == 1)
          if v:
              data = ssl.RAND_bytes(16)
              self.assertEqual(len(data), 16)
          else:
              self.assertRaises(ssl.SSLError, ssl.RAND_bytes, 16)
  
          # negative num is invalid
          self.assertRaises(ValueError, ssl.RAND_bytes, -5)
          self.assertRaises(ValueError, ssl.RAND_pseudo_bytes, -5)
  
          if hasattr(ssl, 'RAND_egd'):
              self.assertRaises(TypeError, ssl.RAND_egd, 1)
              self.assertRaises(TypeError, ssl.RAND_egd, 'foo', 1)
          ssl.RAND_add("this is a random string", 75.0)
          ssl.RAND_add(b"this is a random bytes object", 75.0)
          ssl.RAND_add(bytearray(b"this is a random bytearray object"), 75.0)
  
      @unittest.skipUnless(os.name == 'posix', 'requires posix')
      def test_random_fork(self):
          status = ssl.RAND_status()
          if not status:
              self.fail("OpenSSL's PRNG has insufficient randomness")
  
          rfd, wfd = os.pipe()
          pid = os.fork()
          if pid == 0:
              try:
                  os.close(rfd)
                  child_random = ssl.RAND_pseudo_bytes(16)[0]
                  self.assertEqual(len(child_random), 16)
                  os.write(wfd, child_random)
                  os.close(wfd)
              except BaseException:
                  os._exit(1)
              else:
                  os._exit(0)
          else:
              os.close(wfd)
              self.addCleanup(os.close, rfd)
              _, status = os.waitpid(pid, 0)
              self.assertEqual(status, 0)
  
              child_random = os.read(rfd, 16)
              self.assertEqual(len(child_random), 16)
              parent_random = ssl.RAND_pseudo_bytes(16)[0]
              self.assertEqual(len(parent_random), 16)
  
              self.assertNotEqual(child_random, parent_random)
  
      maxDiff = None
  
      def test_parse_cert(self):
          # note that this uses an 'unofficial' function in _ssl.c,
          # provided solely for this test, to exercise the certificate
          # parsing code
          self.assertEqual(
              ssl._ssl._test_decode_cert(CERTFILE),
              CERTFILE_INFO
          )
          self.assertEqual(
              ssl._ssl._test_decode_cert(SIGNED_CERTFILE),
              SIGNED_CERTFILE_INFO
          )
  
          # Issue #13034: the subjectAltName in some certificates
          # (notably projects.developer.nokia.com:443) wasn't parsed
          p = ssl._ssl._test_decode_cert(NOKIACERT)
          if support.verbose:
              sys.stdout.write("\n" + pprint.pformat(p) + "\n")
          self.assertEqual(p['subjectAltName'],
                           (('DNS', 'projects.developer.nokia.com'),
                            ('DNS', 'projects.forum.nokia.com'))
                          )
          # extra OCSP and AIA fields
          self.assertEqual(p['OCSP'], ('http://ocsp.verisign.com',))
          self.assertEqual(p['caIssuers'],
                           ('http://SVRIntl-G3-aia.verisign.com/SVRIntlG3.cer',))
          self.assertEqual(p['crlDistributionPoints'],
                           ('http://SVRIntl-G3-crl.verisign.com/SVRIntlG3.crl',))
  
      def test_parse_cert_CVE_2019_5010(self):
          p = ssl._ssl._test_decode_cert(TALOS_INVALID_CRLDP)
          if support.verbose:
              sys.stdout.write("\n" + pprint.pformat(p) + "\n")
          self.assertEqual(
              p,
              {
                  'issuer': (
                      (('countryName', 'UK'),), (('commonName', 'cody-ca'),)),
                  'notAfter': 'Jun 14 18:00:58 2028 GMT',
                  'notBefore': 'Jun 18 18:00:58 2018 GMT',
                  'serialNumber': '02',
                  'subject': ((('countryName', 'UK'),),
                              (('commonName',
                                'codenomicon-vm-2.test.lal.cisco.com'),)),
                  'subjectAltName': (
                      ('DNS', 'codenomicon-vm-2.test.lal.cisco.com'),),
                  'version': 3
              }
          )
  
      def test_parse_cert_CVE_2013_4238(self):
          p = ssl._ssl._test_decode_cert(NULLBYTECERT)
          if support.verbose:
              sys.stdout.write("\n" + pprint.pformat(p) + "\n")
          subject = ((('countryName', 'US'),),
                     (('stateOrProvinceName', 'Oregon'),),
                     (('localityName', 'Beaverton'),),
                     (('organizationName', 'Python Software Foundation'),),
                     (('organizationalUnitName', 'Python Core Development'),),
                     (('commonName', 'null.python.org\x00example.org'),),
                     (('emailAddress', 'python-dev@python.org'),))
          self.assertEqual(p['subject'], subject)
          self.assertEqual(p['issuer'], subject)
          if ssl._OPENSSL_API_VERSION >= (0, 9, 8):
              san = (('DNS', 'altnull.python.org\x00example.com'),
                     ('email', 'null@python.org\x00user@example.org'),
                     ('URI', 'http://null.python.org\x00http://example.org'),
                     ('IP Address', '192.0.2.1'),
                     ('IP Address', '2001:DB8:0:0:0:0:0:1'))
          else:
              # OpenSSL 0.9.7 doesn't support IPv6 addresses in subjectAltName
              san = (('DNS', 'altnull.python.org\x00example.com'),
                     ('email', 'null@python.org\x00user@example.org'),
                     ('URI', 'http://null.python.org\x00http://example.org'),
                     ('IP Address', '192.0.2.1'),
                     ('IP Address', '<invalid>'))
  
          self.assertEqual(p['subjectAltName'], san)
  
      def test_parse_all_sans(self):
          p = ssl._ssl._test_decode_cert(ALLSANFILE)
          self.assertEqual(p['subjectAltName'],
              (
                  ('DNS', 'allsans'),
                  ('othername', '<unsupported>'),
                  ('othername', '<unsupported>'),
                  ('email', 'user@example.org'),
                  ('DNS', 'www.example.org'),
                  ('DirName',
                      ((('countryName', 'XY'),),
                      (('localityName', 'Castle Anthrax'),),
                      (('organizationName', 'Python Software Foundation'),),
                      (('commonName', 'dirname example'),))),
                  ('URI', 'https://www.python.org/'),
                  ('IP Address', '127.0.0.1'),
                  ('IP Address', '0:0:0:0:0:0:0:1'),
                  ('Registered ID', '1.2.3.4.5')
              )
          )
  
      def test_DER_to_PEM(self):
          with open(CAFILE_CACERT, 'r') as f:
              pem = f.read()
          d1 = ssl.PEM_cert_to_DER_cert(pem)
          p2 = ssl.DER_cert_to_PEM_cert(d1)
          d2 = ssl.PEM_cert_to_DER_cert(p2)
          self.assertEqual(d1, d2)
          if not p2.startswith(ssl.PEM_HEADER + '\n'):
              self.fail("DER-to-PEM didn't include correct header:\n%r\n" % p2)
          if not p2.endswith('\n' + ssl.PEM_FOOTER + '\n'):
              self.fail("DER-to-PEM didn't include correct footer:\n%r\n" % p2)
  
      def test_openssl_version(self):
          n = ssl.OPENSSL_VERSION_NUMBER
          t = ssl.OPENSSL_VERSION_INFO
          s = ssl.OPENSSL_VERSION
          self.assertIsInstance(n, int)
          self.assertIsInstance(t, tuple)
          self.assertIsInstance(s, str)
          # Some sanity checks follow
          # >= 0.9
          self.assertGreaterEqual(n, 0x900000)
          # < 4.0
          self.assertLess(n, 0x40000000)
          major, minor, fix, patch, status = t
          self.assertGreaterEqual(major, 1)
          self.assertLess(major, 4)
          self.assertGreaterEqual(minor, 0)
          self.assertLess(minor, 256)
          self.assertGreaterEqual(fix, 0)
          self.assertLess(fix, 256)
          self.assertGreaterEqual(patch, 0)
          self.assertLessEqual(patch, 63)
          self.assertGreaterEqual(status, 0)
          self.assertLessEqual(status, 15)
          # Version string as returned by {Open,Libre}SSL, the format might change
          if IS_LIBRESSL:
              self.assertTrue(s.startswith("LibreSSL {:d}".format(major)),
                              (s, t, hex(n)))
          else:
              self.assertTrue(s.startswith("OpenSSL {:d}.{:d}.{:d}".format(major, minor, fix)),
                              (s, t, hex(n)))
  
      @support.cpython_only
      def test_refcycle(self):
          # Issue #7943: an SSL object doesn't create reference cycles with
          # itself.
          s = socket.socket(socket.AF_INET)
          ss = test_wrap_socket(s)
          wr = weakref.ref(ss)
          with support.check_warnings(("", ResourceWarning)):
              del ss
          self.assertEqual(wr(), None)
  
      def test_wrapped_unconnected(self):
          # Methods on an unconnected SSLSocket propagate the original
          # OSError raise by the underlying socket object.
          s = socket.socket(socket.AF_INET)
          with test_wrap_socket(s) as ss:
              self.assertRaises(OSError, ss.recv, 1)
              self.assertRaises(OSError, ss.recv_into, bytearray(b'x'))
              self.assertRaises(OSError, ss.recvfrom, 1)
              self.assertRaises(OSError, ss.recvfrom_into, bytearray(b'x'), 1)
              self.assertRaises(OSError, ss.send, b'x')
              self.assertRaises(OSError, ss.sendto, b'x', ('0.0.0.0', 0))
              self.assertRaises(NotImplementedError, ss.dup)
              self.assertRaises(NotImplementedError, ss.sendmsg,
                                [b'x'], (), 0, ('0.0.0.0', 0))
              self.assertRaises(NotImplementedError, ss.recvmsg, 100)
              self.assertRaises(NotImplementedError, ss.recvmsg_into,
                                [bytearray(100)])
  
      def test_timeout(self):
          # Issue #8524: when creating an SSL socket, the timeout of the
          # original socket should be retained.
          for timeout in (None, 0.0, 5.0):
              s = socket.socket(socket.AF_INET)
              s.settimeout(timeout)
              with test_wrap_socket(s) as ss:
                  self.assertEqual(timeout, ss.gettimeout())
  
      def test_errors_sslwrap(self):
          sock = socket.socket()
          self.assertRaisesRegex(ValueError,
                          "certfile must be specified",
                          ssl.wrap_socket, sock, keyfile=CERTFILE)
          self.assertRaisesRegex(ValueError,
                          "certfile must be specified for server-side operations",
                          ssl.wrap_socket, sock, server_side=True)
          self.assertRaisesRegex(ValueError,
                          "certfile must be specified for server-side operations",
                           ssl.wrap_socket, sock, server_side=True, certfile="")
          with ssl.wrap_socket(sock, server_side=True, certfile=CERTFILE) as s:
              self.assertRaisesRegex(ValueError, "can't connect in server-side mode",
                                       s.connect, (HOST, 8080))
          with self.assertRaises(OSError) as cm:
              with socket.socket() as sock:
                  ssl.wrap_socket(sock, certfile=NONEXISTINGCERT)
          self.assertEqual(cm.exception.errno, errno.ENOENT)
          with self.assertRaises(OSError) as cm:
              with socket.socket() as sock:
                  ssl.wrap_socket(sock,
                      certfile=CERTFILE, keyfile=NONEXISTINGCERT)
          self.assertEqual(cm.exception.errno, errno.ENOENT)
          with self.assertRaises(OSError) as cm:
              with socket.socket() as sock:
                  ssl.wrap_socket(sock,
                      certfile=NONEXISTINGCERT, keyfile=NONEXISTINGCERT)
          self.assertEqual(cm.exception.errno, errno.ENOENT)
  
      def bad_cert_test(self, certfile):
          """Check that trying to use the given client certificate fails"""
          certfile = os.path.join(os.path.dirname(__file__) or os.curdir,
                                     certfile)
          sock = socket.socket()
          self.addCleanup(sock.close)
          with self.assertRaises(ssl.SSLError):
              test_wrap_socket(sock,
                               certfile=certfile)
  
      def test_empty_cert(self):
          """Wrapping with an empty cert file"""
          self.bad_cert_test("nullcert.pem")
  
      def test_malformed_cert(self):
          """Wrapping with a badly formatted certificate (syntax error)"""
          self.bad_cert_test("badcert.pem")
  
      def test_malformed_key(self):
          """Wrapping with a badly formatted key (syntax error)"""
          self.bad_cert_test("badkey.pem")
  
      def test_match_hostname(self):
          def ok(cert, hostname):
              ssl.match_hostname(cert, hostname)
          def fail(cert, hostname):
              self.assertRaises(ssl.CertificateError,
                                ssl.match_hostname, cert, hostname)
  
          # -- Hostname matching --
  
          cert = {'subject': ((('commonName', 'example.com'),),)}
          ok(cert, 'example.com')
          ok(cert, 'ExAmple.cOm')
          fail(cert, 'www.example.com')
          fail(cert, '.example.com')
          fail(cert, 'example.org')
          fail(cert, 'exampleXcom')
  
          cert = {'subject': ((('commonName', '*.a.com'),),)}
          ok(cert, 'foo.a.com')
          fail(cert, 'bar.foo.a.com')
          fail(cert, 'a.com')
          fail(cert, 'Xa.com')
          fail(cert, '.a.com')
  
          # only match wildcards when they are the only thing
          # in left-most segment
          cert = {'subject': ((('commonName', 'f*.com'),),)}
          fail(cert, 'foo.com')
          fail(cert, 'f.com')
          fail(cert, 'bar.com')
          fail(cert, 'foo.a.com')
          fail(cert, 'bar.foo.com')
  
          # NULL bytes are bad, CVE-2013-4073
          cert = {'subject': ((('commonName',
                                'null.python.org\x00example.org'),),)}
          ok(cert, 'null.python.org\x00example.org') # or raise an error?
          fail(cert, 'example.org')
          fail(cert, 'null.python.org')
  
          # error cases with wildcards
          cert = {'subject': ((('commonName', '*.*.a.com'),),)}
          fail(cert, 'bar.foo.a.com')
          fail(cert, 'a.com')
          fail(cert, 'Xa.com')
          fail(cert, '.a.com')
  
          cert = {'subject': ((('commonName', 'a.*.com'),),)}
          fail(cert, 'a.foo.com')
          fail(cert, 'a..com')
          fail(cert, 'a.com')
  
          # wildcard doesn't match IDNA prefix 'xn--'
