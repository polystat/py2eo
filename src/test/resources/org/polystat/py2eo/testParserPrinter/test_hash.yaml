python: |
  # test the invariant that
  #   iff a==b then hash(a)==hash(b)
  #
  # Also test that hash implementations are inherited as expected
  
  import datetime
  import os
  import sys
  import unittest
  from test.support.script_helper import assert_python_ok
  from collections.abc import Hashable
  
  IS_64BIT = sys.maxsize > 2**32
  
  def lcg(x, length=16):
      """Linear congruential generator"""
      if x == 0:
          return bytes(length)
      out = bytearray(length)
      for i in range(length):
          x = (214013 * x + 2531011) & 0x7fffffff
          out[i] = (x >> 16) & 0xff
      return bytes(out)
  
  def pysiphash(uint64):
      """Convert SipHash24 output to Py_hash_t
      """
      assert 0 <= uint64 < (1 << 64)
      # simple unsigned to signed int64
      if uint64 > (1 << 63) - 1:
          int64 = uint64 - (1 << 64)
      else:
          int64 = uint64
      # mangle uint64 to uint32
      uint32 = (uint64 ^ uint64 >> 32) & 0xffffffff
      # simple unsigned to signed int32
      if uint32 > (1 << 31) - 1:
          int32 = uint32 - (1 << 32)
      else:
          int32 = uint32
      return int32, int64
  
  def skip_unless_internalhash(test):
      """Skip decorator for tests that depend on SipHash24 or FNV"""
      ok = sys.hash_info.algorithm in {"fnv", "siphash24"}
      msg = "Requires SipHash24 or FNV"
      return test if ok else unittest.skip(msg)(test)
  
  
  class HashEqualityTestCase(unittest.TestCase):
  
      def same_hash(self, *objlist):
          # Hash each object given and fail if
          # the hash values are not all the same.
          hashed = list(map(hash, objlist))
          for h in hashed[1:]:
              if h != hashed[0]:
                  self.fail("hashed values differ: %r" % (objlist,))
  
      def test_numeric_literals(self):
          self.same_hash(1, 1, 1.0, 1.0+0.0j)
          self.same_hash(0, 0.0, 0.0+0.0j)
          self.same_hash(-1, -1.0, -1.0+0.0j)
          self.same_hash(-2, -2.0, -2.0+0.0j)
  
      def test_coerced_integers(self):
          self.same_hash(int(1), int(1), float(1), complex(1),
                         int('1'), float('1.0'))
          self.same_hash(int(-2**31), float(-2**31))
          self.same_hash(int(1-2**31), float(1-2**31))
          self.same_hash(int(2**31-1), float(2**31-1))
          # for 64-bit platforms
          self.same_hash(int(2**31), float(2**31))
          self.same_hash(int(-2**63), float(-2**63))
          self.same_hash(int(2**63), float(2**63))
  
      def test_coerced_floats(self):
          self.same_hash(int(1.23e300), float(1.23e300))
          self.same_hash(float(0.5), complex(0.5, 0.0))
  
      def test_unaligned_buffers(self):
          # The hash function for bytes-like objects shouldn't have
          # alignment-dependent results (example in issue #16427).
          b = b"123456789abcdefghijklmnopqrstuvwxyz" * 128
          for i in range(16):
              for j in range(16):
                  aligned = b[i:128+j]
                  unaligned = memoryview(b)[i:128+j]
                  self.assertEqual(hash(aligned), hash(unaligned))
  
  
  _default_hash = object.__hash__
  class DefaultHash(object): pass
  
  _FIXED_HASH_VALUE = 42
  class FixedHash(object):
      def __hash__(self):
          return _FIXED_HASH_VALUE
  
  class OnlyEquality(object):
      def __eq__(self, other):
          return self is other
  
  class OnlyInequality(object):
      def __ne__(self, other):
          return self is not other
  
  class InheritedHashWithEquality(FixedHash, OnlyEquality): pass
  class InheritedHashWithInequality(FixedHash, OnlyInequality): pass
  
  class NoHash(object):
      __hash__ = None
  
  class HashInheritanceTestCase(unittest.TestCase):
      default_expected = [object(),
                          DefaultHash(),
                          OnlyInequality(),
                         ]
      fixed_expected = [FixedHash(),
                        InheritedHashWithEquality(),
                        InheritedHashWithInequality(),
                        ]
      error_expected = [NoHash(),
                        OnlyEquality(),
                        ]
  
      def test_default_hash(self):
          for obj in self.default_expected:
              self.assertEqual(hash(obj), _default_hash(obj))
  
      def test_fixed_hash(self):
          for obj in self.fixed_expected:
              self.assertEqual(hash(obj), _FIXED_HASH_VALUE)
  
      def test_error_hash(self):
          for obj in self.error_expected:
              self.assertRaises(TypeError, hash, obj)
  
      def test_hashable(self):
          objects = (self.default_expected +
                     self.fixed_expected)
          for obj in objects:
              self.assertIsInstance(obj, Hashable)
  
      def test_not_hashable(self):
          for obj in self.error_expected:
              self.assertNotIsInstance(obj, Hashable)
  
  
  # Issue #4701: Check that some builtin types are correctly hashable
  class DefaultIterSeq(object):
      seq = range(10)
      def __len__(self):
          return len(self.seq)
      def __getitem__(self, index):
          return self.seq[index]
  
  class HashBuiltinsTestCase(unittest.TestCase):
      hashes_to_check = [enumerate(range(10)),
                         iter(DefaultIterSeq()),
                         iter(lambda: 0, 0),
                        ]
  
      def test_hashes(self):
          _default_hash = object.__hash__
          for obj in self.hashes_to_check:
              self.assertEqual(hash(obj), _default_hash(obj))
  
  class HashRandomizationTests:
  
      # Each subclass should define a field "repr_", containing the repr() of
      # an object to be tested
  
      def get_hash_command(self, repr_):
          return 'print(hash(eval(%a)))' % repr_
  
      def get_hash(self, repr_, seed=None):
          env = os.environ.copy()
          env['__cleanenv'] = True  # signal to assert_python not to do a copy
                                    # of os.environ on its own
          if seed is not None:
              env['PYTHONHASHSEED'] = str(seed)
          else:
              env.pop('PYTHONHASHSEED', None)
          out = assert_python_ok(
              '-c', self.get_hash_command(repr_),
              **env)
          stdout = out[1].strip()
          return int(stdout)
  
      def test_randomized_hash(self):
          # two runs should return different hashes
          run1 = self.get_hash(self.repr_, seed='random')
          run2 = self.get_hash(self.repr_, seed='random')
          self.assertNotEqual(run1, run2)
  
  class StringlikeHashRandomizationTests(HashRandomizationTests):
      repr_ = None
      repr_long = None
  
      # 32bit little, 64bit little, 32bit big, 64bit big
      known_hashes = {
          'djba33x': [ # only used for small strings
              # seed 0, 'abc'
              [193485960, 193485960,  193485960, 193485960],
              # seed 42, 'abc'
              [-678966196, 573763426263223372, -820489388, -4282905804826039665],
              ],
          'siphash24': [
              # NOTE: PyUCS2 layout depends on endianness
              # seed 0, 'abc'
              [1198583518, 4596069200710135518, 1198583518, 4596069200710135518],
              # seed 42, 'abc'
              [273876886, -4501618152524544106, 273876886, -4501618152524544106],
              # seed 42, 'abcdefghijk'
              [-1745215313, 4436719588892876975, -1745215313, 4436719588892876975],
