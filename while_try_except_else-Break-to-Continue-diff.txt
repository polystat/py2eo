Diff between original (left) and mutated (right) python files
12c12
<             break # 12:12-12:16
---
>             continue # 12:12-12:16

Diff between original (left) and mutated (right) eo files
2,8d1
< +alias goto org.eolang.gray.goto
< +alias stdout org.eolang.io.stdout
< +alias sprintf org.eolang.txt.sprintf
< +alias cage org.eolang.gray.cage
< +alias pyint preface.pyint
< +alias pystring preface.pystring
< +alias pybool preface.pybool
10,225c3,39
< 
< [unused] > while_try_except_else
<   [] > apply
<     [stackUp] > @
<       [x] > mkCopy
<         x' > copy
<         copy.< > @
<       [] > newUID
<         memory > cur
<         [unused] > apply
<           seq > @
<             cur.write (cur.is-empty.if (5) (cur.add (1)))
<             (pyint cur)
<       [] > raiseEmpty
<         [] > xclass
<           (pyint 4) > xid
<       [res] > return
<         res > result
<         [] > xclass
<           (pyint 3) > xid
<       [] > break
<         [] > xclass
<           (pyint 2) > xid
<       [] > continue
<         [] > xclass
<           (pyint 1) > xid
<       [] > raiseNothing
<         [] > xclass
<           (pyint 0) > xid
<       [id] > is-exception
<         id.greater (pyint 3) > @
<       [id] > is-break-continue-return
<         (id.greater (pyint 0)).and (id.less (pyint 4)) > @
<       cage > xcurrent-exception
<       cage > xcaught
<       pyint 0 > dummy-int-usage
<       pybool TRUE > dummy-bool-usage
<       pystring (sprintf "") > dummy-bool-string
<       [] > xmyArray
<         [initValue] > apply
<           [stackUp] > @
<             cage > pResult
<             [] > result
<               cage > value
<               [] > xlength
<                 [self] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (pyint (self.value.length)))
<                       123
<               [] > xget
<                 [self i] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (self.value.get i))
<                       123
<               [] > xappend
<                 [self x] > apply
<                   [stackUp] > @
<                     seq > @
<                       mkCopy (self.value) > tmp
<                       self.value.write (tmp.copy.append x)
<                       stackUp.forward (return 0)
<             seq > @
<               result.value.write initValue
<               pResult.write result
<               stackUp.forward (return pResult)
<       cage > tmp
<       cage > toReturn
<       cage > assertMe
<       cage > xwhile_try_except_else
<       seq > @
<         stdout "while_try_except_else\n"
<         write.
<           xwhile_try_except_else
<           []
<             [] > apply
<               [stackUp] > @
<                 cage > tmp
<                 cage > toReturn
<                 cage > e6
<                 cage > e5
<                 cage > e7
<                 cage > e0
<                 cage > xres
<                 cage > e10
<                 cage > xcaught
<                 cage > xx
<                 cage > e1
<                 cage > lhs5
<                 cage > e4
<                 cage > xarr
<                 cage > e8
<                 cage > lhs2
<                 cage > lhs8
<                 cage > e3
<                 cage > lhs3
<                 cage > e9
<                 cage > e2
<                 cage > lhs7
<                 cage > e11
<                 seq > @
<                   stdout "xwhile_try_except_else\n"
<                   tmp.write (goto ((((xmyArray)).apply ((*))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e0).write (tmp.result)
<                   ((e0).<)
<                   mkCopy (e0) > tmp1
<                   (xarr).write (tmp1.copy)
<                   write.
<                     xcurrent-exception
<                     goto
<                       [stackUp]
<                         seq > @
<                           (pybool TRUE).while
<                             [unused]
<                               seq > @
<                                 (xcaught).write ((pybool FALSE))
<                                 (xcaught).force
<                                 xcaught.write (pybool TRUE)
<                                 write.
<                                   xcurrent-exception
<                                   goto
<                                     [stackUp]
<                                       seq > @
<                                         tmp.write (goto ((((xint)).apply ((pyint 1))).@))
<                                         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                         (e1).write (tmp.result)
<                                         ((e1).<)
<                                         mkCopy (e1) > tmp2
<                                         (xx).write (tmp2.copy)
<                                         stdout (sprintf "%s\n" ((xx).as-string))
<                                         ((e2).<)
<                                         stackUp.forward raiseNothing
<                                 seq
<                                   if.
<                                     is-exception (xcurrent-exception.xclass.xid)
<                                     seq
<                                       mkCopy (xcurrent-exception.xclass) > tmp3
<                                       (e4).write (tmp3.copy)
<                                       ((e4).<)
<                                       mkCopy (e4.xid) > tmp4
<                                       (e5).write (tmp4.copy)
<                                       ((e5).<)
<                                       mkCopy (xValueError.xid) > tmp5
<                                       (e6).write (tmp5.copy)
<                                       ((e6).<)
<                                       (e7).write (((e5).eq (e6)))
<                                       (e7).force
<                                       ((e7).<)
<                                       (e7).if
<                                         seq
<                                           stdout (sprintf "%s\n" ((pystring "Oops!  That was not a valid number.  Try again...").as-string))
<                                           ((e3).<)
<                                           (xcaught).write ((pybool TRUE))
<                                           (xcaught).force
<                                           (pybool TRUE)
<                                         seq
<                                           (pybool TRUE)
<                                       0
<                                     0
<                                   if.
<                                     xcurrent-exception.xclass.xid.eq (raiseNothing.xclass.xid)
<                                     seq
<                                       (xres).write ((pybool TRUE))
<                                       (xres).force
<                                       mkCopy (xarr.xappend) > tmp6
<                                       (e8).write (tmp6.copy)
<                                       ((e8).<)
<                                       mkCopy (xarr) > tmp7
<                                       (lhs2).write (tmp7.copy)
<                                       (lhs3).write ((pyint 1))
<                                       (lhs3).force
<                                       tmp.write (goto ((((e8)).apply ((lhs2)) ((lhs3))).@))
<                                       (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                       (e9).write (tmp.result)
<                                       ((e9).<)
<                                       stackUp.forward break
<                                       0
<                                     0
<                                   ((is-break-continue-return (xcurrent-exception.xclass.xid)).or ((is-exception (xcurrent-exception.xclass.xid)).and (xcaught.not))).if (stackUp.forward xcurrent-exception) 0
<                                 (pybool TRUE)
<                           stackUp.forward raiseNothing
<                   if.
<                     xcurrent-exception.xclass.xid.neq (break.xclass.xid)
<                     stackUp.forward xcurrent-exception
<                     0
<                   mkCopy (xres) > tmp8
<                   (lhs7).write (tmp8.copy)
<                   (lhs7).if
<                     seq
<                       mkCopy (xarr) > tmp9
<                       (lhs5).write (tmp9.copy)
<                       tmp.write (goto ((((xmyArray)).apply ((* (pyint 1)))).@))
<                       (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                       (e10).write (tmp.result)
<                       ((e10).<)
<                       (e11).write (((lhs5).eq (e10)))
<                       (e11).force
<                       ((e11).<)
<                       (pybool TRUE)
<                     seq
<                       (lhs8).write ((pybool FALSE))
<                       (lhs8).force
<                       mkCopy (lhs8) > tmp10
<                       (e11).write (tmp10.copy)
<                       (pybool TRUE)
<                   toReturn.write ((e11))
<                   stackUp.forward (return toReturn)
<                   123
<         tmp.write (goto ((((xwhile_try_except_else)).apply).@))
<         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<         (assertMe).write (tmp.result)
<         toReturn.write ((assertMe))
<         stackUp.forward (return toReturn)
<   (goto (apply.@)).result > @
\ No newline at end of file
---
> memory > xValueError
> memory > xprint
> memory > xint
> memory > xmyArray
> [] > while_try_except_else
>   [args...] > unsupported
>   [args...] > xunsupported
>   memory > bogusForceDataize
>   memory > xbogusForceDataize
>   memory > xhack
>   seq > @
>     xhack.write
>       []
>         memory > xwhile_try_except_else
>         seq > @
>           xwhile_try_except_else.write
>             []
>               memory > xx
>               memory > xarr
>               memory > xres
>               seq > @
>                 seq
>                   xarr.write (((xmyArray)).apply ((((unsupported)).apply)))
>                   while.
>                     (pybool TRUE)
>                     [unused]
>                       seq > @
>                         (((unsupported)).apply ((xValueError)))
>                           seq
>                             xx.write (((xint)).apply ((pyint 1)))
>                             bogusForceDataize.write (((xprint)).apply ((xx)))
>                           bogusForceDataize.write (((xprint)).apply ((pystring "Oops!  That was not a valid number.  Try again...")))
>                           seq
>                             xres.write (pybool TRUE)
>                             bogusForceDataize.write ((((xarr).xappend)).apply ((pyint 1)))
>                             (((unsupported)).apply)
>                   (((unsupported)).apply (((xres).and ((xarr).eq (((xmyArray)).apply ((((unsupported)).apply ((pyint 1)))))))))
\ No newline at end of file