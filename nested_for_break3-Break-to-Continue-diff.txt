Diff between original (left) and mutated (right) python files
1c1
< def nested_for_break3(): # 1:0-17:45
---
> def nested_for_continue3(): # 1:0-17:45
8c8
<                 break # 8:16-8:20
---
>                 continue # 8:16-8:20
13c13
<             break # 13:12-13:16
---
>             continue # 13:12-13:16

Diff between original (left) and mutated (right) eo files
2,8d1
< +alias goto org.eolang.gray.goto
< +alias stdout org.eolang.io.stdout
< +alias sprintf org.eolang.txt.sprintf
< +alias cage org.eolang.gray.cage
< +alias pyint preface.pyint
< +alias pystring preface.pystring
< +alias pybool preface.pybool
10,314c3,29
< 
< [unused] > nested_for_break3
<   [] > apply
<     [stackUp] > @
<       [x] > mkCopy
<         x' > copy
<         copy.< > @
<       [] > newUID
<         memory > cur
<         [unused] > apply
<           seq > @
<             cur.write (cur.is-empty.if (5) (cur.add (1)))
<             (pyint cur)
<       [] > raiseEmpty
<         [] > xclass
<           (pyint 4) > xid
<       [res] > return
<         res > result
<         [] > xclass
<           (pyint 3) > xid
<       [] > break
<         [] > xclass
<           (pyint 2) > xid
<       [] > continue
<         [] > xclass
<           (pyint 1) > xid
<       [] > raiseNothing
<         [] > xclass
<           (pyint 0) > xid
<       [id] > is-exception
<         id.greater (pyint 3) > @
<       [id] > is-break-continue-return
<         (id.greater (pyint 0)).and (id.less (pyint 4)) > @
<       cage > xcurrent-exception
<       cage > xcaught
<       pyint 0 > dummy-int-usage
<       pybool TRUE > dummy-bool-usage
<       pystring (sprintf "") > dummy-bool-string
<       [] > xmyArray
<         [initValue] > apply
<           [stackUp] > @
<             cage > pResult
<             [] > result
<               cage > value
<               [] > xlength
<                 [self] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (pyint (self.value.length)))
<                       123
<               [] > xget
<                 [self i] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (self.value.get i))
<                       123
<               [] > xappend
<                 [self x] > apply
<                   [stackUp] > @
<                     seq > @
<                       mkCopy (self.value) > tmp
<                       self.value.write (tmp.copy.append x)
<                       stackUp.forward (return 0)
<             seq > @
<               result.value.write initValue
<               pResult.write result
<               stackUp.forward (return pResult)
<       cage > tmp
<       cage > toReturn
<       cage > assertMe
<       cage > xnested_for_break3
<       seq > @
<         stdout "nested_for_break3\n"
<         write.
<           xnested_for_break3
<           []
<             [] > apply
<               [stackUp] > @
<                 cage > tmp
<                 cage > toReturn
<                 cage > lhs18
<                 cage > e23
<                 cage > e1
<                 cage > lhs14
<                 cage > e7
<                 cage > e17
<                 cage > xres
<                 cage > e10
<                 cage > e25
<                 cage > xcaught
<                 cage > e9
<                 cage > e22
<                 cage > e19
<                 cage > e6
<                 cage > e18
<                 cage > lhs0
<                 cage > e12
<                 cage > xj
<                 cage > lhs4
<                 cage > e5
<                 cage > e0
<                 cage > e20
<                 cage > xarr2
<                 cage > e4
<                 cage > e24
<                 cage > e13
<                 cage > lhs13
<                 cage > xit1
<                 cage > e8
<                 cage > e16
<                 cage > lhs2
<                 cage > lhs8
<                 cage > e3
<                 cage > lhs6
<                 cage > e21
<                 cage > lhs9
<                 cage > e14
<                 cage > xit0
<                 cage > e15
<                 cage > xi
<                 cage > e2
<                 cage > xarr1
<                 cage > e26
<                 cage > e11
<                 seq > @
<                   stdout "xnested_for_break3\n"
<                   tmp.write (goto ((((xmyArray)).apply ((* (pyint 1) (pyint 2) (pyint 3)))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e0).write (tmp.result)
<                   ((e0).<)
<                   mkCopy (e0) > tmp1
<                   (xarr1).write (tmp1.copy)
<                   tmp.write (goto ((((xmyArray)).apply ((* (pyint 4) (pyint 5) (pyint 6)))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e1).write (tmp.result)
<                   ((e1).<)
<                   mkCopy (e1) > tmp2
<                   (xarr2).write (tmp2.copy)
<                   tmp.write (goto ((((xmyArray)).apply ((*))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e2).write (tmp.result)
<                   ((e2).<)
<                   mkCopy (e2) > tmp3
<                   (xres).write (tmp3.copy)
<                   mkCopy (xarr1.x__iter__) > tmp4
<                   (e3).write (tmp4.copy)
<                   ((e3).<)
<                   mkCopy (xarr1) > tmp5
<                   (lhs0).write (tmp5.copy)
<                   tmp.write (goto ((((e3)).apply ((lhs0))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e4).write (tmp.result)
<                   ((e4).<)
<                   mkCopy (e4) > tmp6
<                   (xit0).write (tmp6.copy)
<                   (xcaught).write ((pybool FALSE))
<                   (xcaught).force
<                   xcaught.write (pybool TRUE)
<                   write.
<                     xcurrent-exception
<                     goto
<                       [stackUp]
<                         seq > @
<                           write.
<                             xcurrent-exception
<                             goto
<                               [stackUp]
<                                 seq > @
<                                   (pybool TRUE).while
<                                     [unused]
<                                       seq > @
<                                         mkCopy (xit0.x__next__) > tmp7
<                                         (e5).write (tmp7.copy)
<                                         ((e5).<)
<                                         mkCopy (xit0) > tmp8
<                                         (lhs2).write (tmp8.copy)
<                                         tmp.write (goto ((((e5)).apply ((lhs2))).@))
<                                         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                         (e6).write (tmp.result)
<                                         ((e6).<)
<                                         mkCopy (e6) > tmp9
<                                         (xi).write (tmp9.copy)
<                                         mkCopy (xarr2.x__iter__) > tmp10
<                                         (e7).write (tmp10.copy)
<                                         ((e7).<)
<                                         mkCopy (xarr2) > tmp11
<                                         (lhs4).write (tmp11.copy)
<                                         tmp.write (goto ((((e7)).apply ((lhs4))).@))
<                                         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                         (e8).write (tmp.result)
<                                         ((e8).<)
<                                         mkCopy (e8) > tmp12
<                                         (xit1).write (tmp12.copy)
<                                         (xcaught).write ((pybool FALSE))
<                                         (xcaught).force
<                                         xcaught.write (pybool TRUE)
<                                         write.
<                                           xcurrent-exception
<                                           goto
<                                             [stackUp]
<                                               seq > @
<                                                 write.
<                                                   xcurrent-exception
<                                                   goto
<                                                     [stackUp]
<                                                       seq > @
<                                                         (pybool TRUE).while
<                                                           [unused]
<                                                             seq > @
<                                                               mkCopy (xit1.x__next__) > tmp13
<                                                               (e9).write (tmp13.copy)
<                                                               ((e9).<)
<                                                               mkCopy (xit1) > tmp14
<                                                               (lhs6).write (tmp14.copy)
<                                                               tmp.write (goto ((((e9)).apply ((lhs6))).@))
<                                                               (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                                               (e10).write (tmp.result)
<                                                               ((e10).<)
<                                                               mkCopy (e10) > tmp15
<                                                               (xj).write (tmp15.copy)
<                                                               (e11).write (((xj).eq (pyint 5)))
<                                                               (e11).force
<                                                               ((e11).<)
<                                                               (e11).if
<                                                                 seq
<                                                                   stackUp.forward break
<                                                                   (pybool TRUE)
<                                                                 seq
<                                                                   (pybool TRUE)
<                                                               mkCopy (xres.xappend) > tmp16
<                                                               (e12).write (tmp16.copy)
<                                                               ((e12).<)
<                                                               mkCopy (xres) > tmp17
<                                                               (lhs8).write (tmp17.copy)
<                                                               mkCopy (xj) > tmp18
<                                                               (lhs9).write (tmp18.copy)
<                                                               tmp.write (goto ((((e12)).apply ((lhs8)) ((lhs9))).@))
<                                                               (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                                               (e13).write (tmp.result)
<                                                               ((e13).<)
<                                                               (pybool TRUE)
<                                                         stackUp.forward raiseNothing
<                                                 if.
<                                                   xcurrent-exception.xclass.xid.neq (break.xclass.xid)
<                                                   stackUp.forward xcurrent-exception
<                                                   0
<                                                 stackUp.forward raiseNothing
<                                         seq
<                                           if.
<                                             is-exception (xcurrent-exception.xclass.xid)
<                                             seq
<                                               mkCopy (xcurrent-exception.xclass) > tmp19
<                                               (e14).write (tmp19.copy)
<                                               ((e14).<)
<                                               mkCopy (e14.xid) > tmp20
<                                               (e15).write (tmp20.copy)
<                                               ((e15).<)
<                                               mkCopy (xStopIteration.xid) > tmp21
<                                               (e16).write (tmp21.copy)
<                                               ((e16).<)
<                                               (e17).write (((e15).eq (e16)))
<                                               (e17).force
<                                               ((e17).<)
<                                               (e17).if
<                                                 seq
<                                                   (xcaught).write ((pybool TRUE))
<                                                   (xcaught).force
<                                                   (pybool TRUE)
<                                                 seq
<                                                   (pybool TRUE)
<                                               0
<                                             0
<                                           if.
<                                             xcurrent-exception.xclass.xid.eq (raiseNothing.xclass.xid)
<                                             seq
<                                               0
<                                             0
<                                           ((is-break-continue-return (xcurrent-exception.xclass.xid)).or ((is-exception (xcurrent-exception.xclass.xid)).and (xcaught.not))).if (stackUp.forward xcurrent-exception) 0
<                                         (e18).write (((xi).eq (pyint 2)))
<                                         (e18).force
<                                         ((e18).<)
<                                         (e18).if
<                                           seq
<                                             stackUp.forward break
<                                             (pybool TRUE)
<                                           seq
<                                             (pybool TRUE)
<                                         mkCopy (xres.xappend) > tmp22
<                                         (e19).write (tmp22.copy)
<                                         ((e19).<)
<                                         mkCopy (xres) > tmp23
<                                         (lhs13).write (tmp23.copy)
<                                         mkCopy (xi) > tmp24
<                                         (lhs14).write (tmp24.copy)
<                                         tmp.write (goto ((((e19)).apply ((lhs13)) ((lhs14))).@))
<                                         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                         (e20).write (tmp.result)
<                                         ((e20).<)
<                                         (pybool TRUE)
<                                   stackUp.forward raiseNothing
<                           if.
<                             xcurrent-exception.xclass.xid.neq (break.xclass.xid)
<                             stackUp.forward xcurrent-exception
<                             0
<                           stackUp.forward raiseNothing
---
> memory > xStopIteration
> memory > xmyArray
> [] > nested_for_break3
>   [args...] > unsupported
>   [args...] > xunsupported
>   memory > bogusForceDataize
>   memory > xbogusForceDataize
>   memory > xhack
>   seq > @
>     xhack.write
>       []
>         memory > xnested_for_continue3
>         seq > @
>           xnested_for_continue3.write
>             []
>               memory > xarr1
>               memory > xit0
>               memory > xit1
>               memory > xi
>               memory > xarr2
>               memory > xres
>               memory > xj
>               seq > @
>                 seq
>                   xarr1.write (((xmyArray)).apply ((((unsupported)).apply ((pyint 1)) ((pyint 2)) ((pyint 3)))))
>                   xarr2.write (((xmyArray)).apply ((((unsupported)).apply ((pyint 4)) ((pyint 5)) ((pyint 6)))))
>                   xres.write (((xmyArray)).apply ((((unsupported)).apply)))
316,363c31,56
<                     if.
<                       is-exception (xcurrent-exception.xclass.xid)
<                       seq
<                         mkCopy (xcurrent-exception.xclass) > tmp25
<                         (e21).write (tmp25.copy)
<                         ((e21).<)
<                         mkCopy (e21.xid) > tmp26
<                         (e22).write (tmp26.copy)
<                         ((e22).<)
<                         mkCopy (xStopIteration.xid) > tmp27
<                         (e23).write (tmp27.copy)
<                         ((e23).<)
<                         (e24).write (((e22).eq (e23)))
<                         (e24).force
<                         ((e24).<)
<                         (e24).if
<                           seq
<                             (xcaught).write ((pybool TRUE))
<                             (xcaught).force
<                             (pybool TRUE)
<                           seq
<                             (pybool TRUE)
<                         0
<                       0
<                     if.
<                       xcurrent-exception.xclass.xid.eq (raiseNothing.xclass.xid)
<                       seq
<                         0
<                       0
<                     ((is-break-continue-return (xcurrent-exception.xclass.xid)).or ((is-exception (xcurrent-exception.xclass.xid)).and (xcaught.not))).if (stackUp.forward xcurrent-exception) 0
<                   mkCopy (xres) > tmp28
<                   (lhs18).write (tmp28.copy)
<                   tmp.write (goto ((((xmyArray)).apply ((* (pyint 4) (pyint 1) (pyint 4)))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e25).write (tmp.result)
<                   ((e25).<)
<                   (e26).write (((lhs18).eq (e25)))
<                   (e26).force
<                   ((e26).<)
<                   toReturn.write ((e26))
<                   stackUp.forward (return toReturn)
<                   123
<         tmp.write (goto ((((xnested_for_break3)).apply).@))
<         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<         (assertMe).write (tmp.result)
<         toReturn.write ((assertMe))
<         stackUp.forward (return toReturn)
<   (goto (apply.@)).result > @
\ No newline at end of file
---
>                     xit0.write ((((xarr1).x__iter__)).apply)
>                     (((unsupported)).apply ((xStopIteration)))
>                       while.
>                         (pybool TRUE)
>                         [unused]
>                           seq > @
>                             seq
>                               xi.write ((((xit0).x__next__)).apply)
>                               seq
>                                 seq
>                                   xit1.write ((((xarr2).x__iter__)).apply)
>                                   (((unsupported)).apply ((xStopIteration)))
>                                     while.
>                                       (pybool TRUE)
>                                       [unused]
>                                         seq > @
>                                           seq
>                                             xj.write ((((xit1).x__next__)).apply)
>                                             seq
>                                               ((xj).eq (pyint 5)).if
>                                                 (((unsupported)).apply)
>                                               bogusForceDataize.write ((((xres).xappend)).apply ((xj)))
>                                 ((xi).eq (pyint 2)).if
>                                   (((unsupported)).apply)
>                                 bogusForceDataize.write ((((xres).xappend)).apply ((xi)))
>                   (((unsupported)).apply (((xres).eq (((xmyArray)).apply ((((unsupported)).apply ((pyint 4)) ((pyint 1)) ((pyint 4))))))))
\ No newline at end of file