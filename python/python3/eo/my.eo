+package org.eolang
+alias stdout org.eolang.io.stdout
+alias sprintf org.eolang.txt.sprintf 
+junit

[] > myTestBool
  memory > z
  and. > @
    z.write 15
    stdout "aoeuoeu"
    eq.
      42
      42

[] > myTestInt
  eq. > @
    100
    add.
      11
      89

[] > affine
  [a b x result] > f
    write. > @
      result
      ((x.mul a).add b)
  memory > result
  and. > @
    f 1 2 0 result
    result.eq 2
    f 1 2 1 result
    result.eq 3
    f 1 2 2 result
    result.eq 4

[] > squarePoly
  [a x result] > f
    write. > @
      result
      ((((x.mul (a.get 0)).add (a.get 1)).mul x).add (a.get 2))
  memory > result
  and. > @
    f (* 1 2 3) 0 result
    result.eq 3
    f (* 1 2 3) 1 result
    result.eq 6
    f (* 1 2 3) 2 result
    result.eq 11

[] > poly
  [a x] > f
    memory > i
    memory > result
    seq > @
      result.write 0
      i.write 0
      while.
        (i.less) (a.length)
        [unused]
          seq > @
            (result.write) (((a.get) (i)).add ((result.mul) (x)))
            (i.write (i.add 1))
      result
  and. > @
    (f (* 1 2 3) 0).eq 3
    (f (* 1 2 3) 1).eq 6
    (f (* 1 2 3) 2).eq 11

[] > bubbleSorter
  [a] > sort
    memory > i
    seq > @
      i.write 0
      while. > @
        (i.less) (a.length)
        [unused]
          memory > minpos
          memory > j
          memory > t
          seq > @
            minpos.write (i)
            j.write ((i.add) 1)
            while.
              (j.less) (a.length)
              [unused]
                seq > @
                  if. > @
                    ((a.get) (j)).less ((a.get) (minpos))
                    (minpos.write) (j)
                    j
                  stdout (sprintf "j = %d\n" (j))
                  (j.write) ((j.add) 1)
            t.write (a.get (i))
            ((a.get) (i)).write ((a.get) minpos)
            ((a.get) minpos).write t
            (i.write) ((i.add) 1)
            stdout (sprintf "i = %d\n" (i))
  [elements...] > mkArr
  (mkArr memory memory memory).elements > arr
  seq > @
    (arr.get 0).write 2
    (arr.get 1).write 1
    (arr.get 2).write 0
    (sort arr)
    arr.each
      [x] (stdout (sprintf "%d " x) > @)

[] > mutablePairTest

  [a b] > mutablePair
    memory > first
    memory > second
    [y] > eq
      (first.eq y.first).and (second.eq y.second) > @
    seq > @
      first.write a
      second.write b

  mutablePair 0 1 > p01
  memory > devNull
  and. > @
    devNull.write p01
    p01.first.eq 0
    p01.second.eq 1

[] > ifelseifA
  memory > notWritten
  FALSE.if notWritten TRUE > @

[] > ifelseifB
  * > anArray
  FALSE.if (anArray.get 0) TRUE > @

[] > ifelseifC
  [first] > pair

  [] > none
    pair TRUE > @

  seq > @
    if.
      FALSE
      11.cantget
      none.first

[] > bogus
  memory > a
  seq > @
    write.
      a
      *
        "a"
        "b"
        "c"
    stdout (a.get 0)
    stdout (a.get 1)
    reduce.
      a
      0
      []
        [accum elt] > reduce
          accum > @

[] > arr2d
  (* 1 2 3) > a0
  (* 4 5 6) > a1
  (* a0 a1) > a01
  (* memory) > heap
  seq > @
    (heap.get 0).write a01
    (((heap.get 0).get 1).get 1).eq 5

[] > memory-array-memory
  memory > m
  (* memory memory) > a0
  (* memory memory) > a1
  seq > @
    m.write a1
    (m.get 1).write 123
    m.write a0
    m.write a1
    (m.get 1).eq 123

[] > trivialMapTester

  [first second] > pair
    [y] > eq
      (first.eq y.first).and (second.eq y.second) > @

  [key] > tElt
    memory > valid
    memory > value
    [x] > set
      seq > @
        value.write x
        valid.write TRUE
    [] > clear
      valid.write FALSE > @

  [] > none
    [z] > eq
      z.first.not > @
    pair FALSE 0 > @

  [] > trivialMap
    memory > a

    [name] > findElt
      memory > i
      memory > found
      seq > @
        i.write 0
        found.write FALSE
        while.
          (i.less (a.length)).and (found.not)
          [unused]
            if.
              (a.get i).key.eq (name)
              found.write TRUE
              i.write (i.add 1)

    [name1] > get
      findElt name1 > found
      memory > bogus
      seq > @
        bogus.write found
        stdout (sprintf "found = %b, i = %d\n" (found.found) (found.i))
        if.
          found.found
          ((a.get (found.i)).valid.if (pair TRUE (a.get (found.i)).value) (none))
          (none)

    [name value] > set
      findElt name > found
      tElt name > newElt
      if. > @
        found.found
        (a.get found.i).set value
        seq
          stdout (sprintf "ONE! %s %s\n" name value)
          newElt.set value
          stdout "TWO!\n"
          a.write (a.append newElt)
          stdout "THREE!\n"

  and. > @
    write.
      trivialMap.a
      *
    none.eq (trivialMap.get "a")

[] > dataizable-list
  (* memory memory) > empty-list
  [index l] > getNode
    if. > @
      index.eq 0
      l
      getNode (index.sub 1) (l.get 1)
  [h l] > push-back
    l.get 0 > len!
    seq > @
      if.
        len.is-empty
        seq
          len.write 1
          (l.get 1).write (* h memory)
        seq
          ((getNode len l).get 1).write (* h memory)
          len.write (len.add 1)
  [index l] > get
    (getNode index (l.get 1)).get 0 > @

  empty-list > l
  seq > @
    push-back 11 l
    stdout (sprintf "%d\n" (get 0 l))
    push-back 22 l
    stdout (sprintf "%d\n" (get 0 l))
    stdout (sprintf "%d\n" (get 1 l))
    push-back 33 l
    stdout "\n =================================================================================================== \n"
    stdout (sprintf "%d\n" (get 0 l))
    stdout (sprintf "%d\n" (get 1 l))
    stdout (sprintf "%d\n" (get 2 l))
    and.
      (get 2 l).eq 33
      (get 1 l).eq 22
      (get 0 l).eq 11
