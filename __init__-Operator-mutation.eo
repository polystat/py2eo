memory > xBooleanField
memory > xLOOKUP_SEP
memory > xfloat
memory > xAutoFieldMixin
memory > xk
memory > xcopy
memory > xinvalid_error_message
memory > xdb
memory > xforms
memory > xAttributeError
memory > xtimezone
memory > xc
memory > xdatetime
memory > xmin_value
memory > xall
memory > xgroup_name
memory > xlist
memory > xdecimal
memory > xBigIntegerField
memory > xparent
memory > xenumerate
memory > xuuid
memory > xparse_duration
memory > xDictWrapper
memory > xDateTimeCheckMixin
memory > xValueError
memory > xSmallIntegerField
memory > xstr
memory > xchecks
memory > xSmallAutoField
memory > xclean_ipv6_address
memory > xwarnings
memory > xapps
memory > xb64encode
memory > xoption
memory > xmath
memory > xtotal_ordering
memory > xrouter
memory > xvalue
memory > xdefault
memory > xCharField
memory > xcollections
memory > xNOT_PROVIDED
memory > xchoice
memory > xalias
memory > xKeyError
memory > xField
memory > xconnection
memory > xmax
memory > xexceptions
memory > xRuntimeWarning
memory > xIntegerField
memory > xoption_key
memory > xparse_time
memory > xb64decode
memory > xRegisterLookupMixin
memory > xreversed
memory > xBigAutoField
memory > xany
memory > xtype
memory > xcallable
memory > xpath
memory > xhuman_name
memory > xint
memory > xrepr
memory > xsettings
memory > xconnections
memory > xhasattr
memory > xproperty
memory > xoptgroup_key
memory > xx
memory > xduration_string
memory > xoperator
memory > xi
memory > xsuper
memory > xAutoFieldMeta
memory > xbool
memory > xissubclass
memory > xtuple
memory > xcapfirst
memory > xNotImplemented
memory > xargs
memory > xDeferredAttribute
memory > xmax_value
memory > xgetattr
memory > xv
memory > xparse_date
memory > xid
memory > xCol
memory > xoption_value
memory > xoptgroup_value
memory > xDateField
memory > xe
memory > xgroup_choices
memory > xsetattr
memory > xname
memory > xchoices_group
memory > xEmpty
memory > xhash
memory > xnext
memory > xis_iterable
memory > xmemoryview
memory > xPositiveIntegerRelDbTypeMixin
memory > xkwargs
memory > xduration_microseconds
memory > xisinstance
memory > xvalidator
memory > xPromise
memory > xlen
memory > xparse_datetime
memory > xTypeError
memory > xpartialmethod
[] > __init__
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xclean
        memory > xget_placeholder
        memory > xget_prep_value
        memory > xauto_creation_counter
        memory > x__str__
        memory > x__deepcopy__
        memory > xcontribute_to_class
        memory > x_check_if_value_fixed
        memory > x__eq__
        memory > x__repr__
        memory > xformfield
        memory > x_check_db_collation
        memory > xget_pk_value_on_save
        memory > x_check_db_index
        memory > xnon_db_attrs
        memory > xset_attributes_from_name
        memory > xvalue_to_string
        memory > xdb_parameters
        memory > xsystem_check_removed_details
        memory > xget_internal_type
        memory > xreturn_None
        memory > x_to_naive
        memory > xsystem_check_deprecated_details
        memory > x__reduce__
        memory > x_check_choices
        memory > x_check_fix_default_value
        memory > xget_db_prep_value
        memory > xmany_to_one
        memory > xget_col
        memory > xcontext
        memory > xcheck
        memory > xclone
        memory > xone_to_one
        memory > xvalidators
        memory > xcreation_counter
        memory > xdb_type_suffix
        memory > x_check_blank_and_null_values
        memory > xflatchoices
        memory > xdescription
        memory > xdefault_validators
        memory > xdb_tablespace
        memory > xcached_col
        memory > xcast_db_type
        memory > x_
        memory > x_check_max_digits
        memory > xget_db_converters
        memory > x_check_max_length_attribute
        memory > xget_default
        memory > x_check_deprecation_details
        memory > xsave_form_data
        memory > x__lt__
        memory > xdb_type_parameters
        memory > xmany_to_many
        memory > x__init_subclass__
        memory > xhidden
        memory > xone_to_many
        memory > xget_db_prep_save
        memory > x__instancecheck__
        memory > xempty_strings_allowed
        memory > xto_python
        memory > x_check_validators
        memory > xget_attname_column
        memory > x_check_mutually_exclusive_options
        memory > x_get_naive_now
        memory > x_check_field_name
        memory > xvalidate
        memory > xerror_messages
        memory > xempty_values
        memory > xunique
        memory > x__subclasscheck__
        memory > x_get_default
        memory > xselect_format
        memory > xdb_returning
        memory > xMAX_BIGINT
        memory > x_description
        memory > xrun_validators
        memory > xget_filter_kwargs_for_object
        memory > xrel_db_type
        memory > x_check_max_length_warning
        memory > xBLANK_CHOICE_DASH
        memory > x__all__
        memory > xvalue_from_object
        memory > x_check_null_allowed_for_primary_keys
        memory > x_subclasses
        memory > xget_choices
        memory > xdb_type
        memory > x_check_primary_key
        memory > xdeconstruct
        memory > xget_attname
        memory > xpre_save
        memory > xdescriptor_class
        memory > x_load_field
        memory > x__init__
        memory > x__hash__
        memory > x_choices_is_value
        memory > xhas_default
        memory > x_check_backend_specific_checks
        memory > xrelated_model
        memory > x_check_allowing_files_or_folders
        memory > x_check_decimal_places_and_max_digits
        memory > x_check_decimal_places
        memory > xdefault_error_messages
        memory > xdb_check
        memory > x_check_str_default_value
        memory > x__copy__
        memory > x_get_flatchoices
        memory > x_empty
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            x__all__.write (((unsupported)).apply ("AutoField") ("BLANK_CHOICE_DASH") ("BigAutoField") ("BigIntegerField") ("BinaryField") ("BooleanField") ("CharField") ("CommaSeparatedIntegerField") ("DateField") ("DateTimeField") ("DecimalField") ("DurationField") ("EmailField") ("Empty") ("Field") ("FilePathField") ("FloatField") ("GenericIPAddressField") ("IPAddressField") ("IntegerField") ("NOT_PROVIDED") ("NullBooleanField") ("PositiveBigIntegerField") ("PositiveIntegerField") ("PositiveSmallIntegerField") ("SlugField") ("SmallAutoField") ("SmallIntegerField") ("TextField") ("TimeField") ("URLField") ("UUIDField"))
            (((unsupported)).apply)
            (((unsupported)).apply)
            xBLANK_CHOICE_DASH.write (((unsupported)).apply ((((unsupported)).apply ("") ("---------"))))
            x_load_field.write
              [xapp_label xmodel_name xfield_name]
                seq > @
                  (((unsupported)).apply (((((((((xapps).xget_model)).apply ((xapp_label)) ((xmodel_name))).x_meta).xget_field)).apply ((xfield_name)))))
            x_empty.write
              [xof_cls]
                memory > xnew
                seq > @
                  seq
                    xnew.write (((xEmpty)).apply)
                    (((unsupported)).apply (((xnew).x__class__)) ((xof_cls)))
                    (((unsupported)).apply ((xnew)))
            xreturn_None.write
              []
                seq > @
                  (((unsupported)).apply ("None: is there a None literal in the EO language?"))
            (((unsupported)).apply ((xRegisterLookupMixin)) ((xtotal_ordering)))
              seq
                unsupported
                xempty_strings_allowed.write TRUE
                xempty_values.write (((xlist)).apply (((xvalidators).xEMPTY_VALUES)))
                xcreation_counter.write 0
                xauto_creation_counter.write (1.neg)
                xdefault_validators.write (((unsupported)).apply)
                xdefault_error_messages.write (((unsupported)).apply ("invalid_choice") ((((x_)).apply ("Value %(value)r is not a valid choice."))) ("null") ((((x_)).apply ("This field cannot be null."))) ("blank") ((((x_)).apply ("This field cannot be blank."))) ("unique") ((((x_)).apply ("%(model_name)s with this %(field_label)s already exists."))) ("unique_for_date") ((((x_)).apply ("%(field_label)s must be unique for %(date_field_label)s %(lookup_type)s."))))
                xsystem_check_deprecated_details.write "None: is there a None literal in the EO language?"
                xsystem_check_removed_details.write "None: is there a None literal in the EO language?"
                xnon_db_attrs.write (((unsupported)).apply ("blank") ("choices") ("db_column") ("editable") ("error_messages") ("help_text") ("limit_choices_to") ("on_delete") ("related_name") ("related_query_name") ("validators") ("verbose_name"))
                xhidden.write FALSE
                xmany_to_many.write "None: is there a None literal in the EO language?"
                xmany_to_one.write "None: is there a None literal in the EO language?"
                xone_to_many.write "None: is there a None literal in the EO language?"
                xone_to_one.write "None: is there a None literal in the EO language?"
                xrelated_model.write "None: is there a None literal in the EO language?"
                xdescriptor_class.write (xDeferredAttribute)
                x_description.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((((x_)).apply ("Field of type: %(field_type)s")).mod (((unsupported)).apply ("field_type") ((((xself).x__class__).x__name__))))))
                xdescription.write (((xproperty)).apply ((x_description)))
                x__init__.write
                  [xself xverbose_name xname xprimary_key xmax_length xunique xblank xnull xdb_index xrel xdefault xeditable xserialize xunique_for_date xunique_for_month xunique_for_year xchoices xhelp_text xdb_column xdb_tablespace xauto_created xvalidators xerror_messages]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xname)) ((xname)))
                        (((unsupported)).apply (((xself).xverbose_name)) ((xverbose_name)))
                        (((unsupported)).apply (((xself).x_verbose_name)) ((xverbose_name)))
                        (((unsupported)).apply (((xself).xprimary_key)) ((xprimary_key)))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xmax_length)) (((xself).x_unique)))) ((((unsupported)).apply ((xmax_length)) ((xunique)))))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xblank)) (((xself).xnull)))) ((((unsupported)).apply ((xblank)) ((xnull)))))
                        (((unsupported)).apply (((xself).xremote_field)) ((xrel)))
                        (((unsupported)).apply (((xself).xis_relation)) ((((unsupported)).apply (((xself).xremote_field)) ("None: is there a None literal in the EO language?"))))
                        (((unsupported)).apply (((xself).xdefault)) ((xdefault)))
                        (((unsupported)).apply (((xself).xeditable)) ((xeditable)))
                        (((unsupported)).apply (((xself).xserialize)) ((xserialize)))
                        (((unsupported)).apply (((xself).xunique_for_date)) ((xunique_for_date)))
                        (((unsupported)).apply (((xself).xunique_for_month)) ((xunique_for_month)))
                        (((unsupported)).apply (((xself).xunique_for_year)) ((xunique_for_year)))
                        (((xisinstance)).apply ((xchoices)) ((((xcollections).xabc).xIterator))).if
                          xchoices.write (((xlist)).apply ((xchoices)))
                        (((unsupported)).apply (((xself).xchoices)) ((xchoices)))
                        (((unsupported)).apply (((xself).xhelp_text)) ((xhelp_text)))
                        (((unsupported)).apply (((xself).xdb_index)) ((xdb_index)))
                        (((unsupported)).apply (((xself).xdb_column)) ((xdb_column)))
                        (((unsupported)).apply (((xself).x_db_tablespace)) ((xdb_tablespace)))
                        (((unsupported)).apply (((xself).xauto_created)) ((xauto_created)))
                        (xauto_created).if
                          seq
                            (((unsupported)).apply (((xself).xcreation_counter)) (((xField).xauto_creation_counter)))
                            (((unsupported)).apply (((xField).xauto_creation_counter)) (1))
                          seq
                            (((unsupported)).apply (((xself).xcreation_counter)) (((xField).xcreation_counter)))
                            (((unsupported)).apply (((xField).xcreation_counter)) (1))
                        (((unsupported)).apply (((xself).x_validators)) ((((xlist)).apply ((xvalidators)))))
                        (((unsupported)).apply (((xself).x_error_messages)) ((xerror_messages)))
                x__str__.write
                  [xself]
                    memory > xmodel
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((((xhasattr)).apply ((xself)) ("model")).not).if
                          (((unsupported)).apply (((((((xsuper)).apply).x__str__)).apply)))
                        xmodel.write ((xself).xmodel)
                        (((unsupported)).apply (("%s.%s".mod (((unsupported)).apply ((((xmodel).x_meta).xlabel)) (((xself).xname))))))
                x__repr__.write
                  [xself]
                    memory > xname
                    memory > xpath
                    seq > @
                      seq
                        unsupported
                        xpath.write ("%s.%s".mod (((unsupported)).apply ((((xself).x__class__).x__module__)) ((((xself).x__class__).x__qualname__))))
                        xname.write (((xgetattr)).apply ((xself)) ("name") ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((xname)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (("<%s: %s>".mod (((unsupported)).apply ((xpath)) ((xname))))))
                        (((unsupported)).apply (("<%s>".mod (xpath))))
                xcheck.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((xself).x_check_field_name)).apply)))) ((((unsupported)).apply (((((xself).x_check_choices)).apply)))) ((((unsupported)).apply (((((xself).x_check_db_index)).apply)))) ((((unsupported)).apply (((((xself).x_check_null_allowed_for_primary_keys)).apply)))) ((((unsupported)).apply (((((xself).x_check_backend_specific_checks)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_validators)).apply)))) ((((unsupported)).apply (((((xself).x_check_deprecation_details)).apply)))))))
                x_check_field_name.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((((xself).xname).xendswith)).apply ("_")).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("Field names must not end with an underscore.") ((xself)) ("fields.E001"))))))
                          (((unsupported)).apply ((xLOOKUP_SEP)) (((xself).xname))).if
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("Field names must not contain \"%s\".".mod (xLOOKUP_SEP))) ((xself)) ("fields.E002"))))))
                            (((xself).xname).eq "pk").if
                              (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'pk' is a reserved word that cannot be used as a field name.") ((xself)) ("fields.E003"))))))
                              (((unsupported)).apply ((((unsupported)).apply)))
                x_choices_is_value.write
                  [xcls xvalue]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xisinstance)).apply ((xvalue)) ((((unsupported)).apply ((xstr)) ((xPromise))))).or ((((xis_iterable)).apply ((xvalue))).not))))
                x_check_choices.write
                  [xself]
                    memory > xchoice_max_length
                    seq > @
                      seq
                        (((xself).xchoices).not).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        (((((xis_iterable)).apply (((xself).xchoices))).not).or (((xisinstance)).apply (((xself).xchoices)) ((xstr)))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'choices' must be an iterable (e.g., a list or tuple).") ((xself)) ("fields.E004"))))))
                        xchoice_max_length.write 0
                        (((unsupported)).apply ((xchoices_group)) (((xself).xchoices)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xTypeError)) ((xValueError)))))
                              (((unsupported)).apply ((((unsupported)).apply ((xgroup_name)) ((xgroup_choices)))) ((xchoices_group)))
                              (((unsupported)).apply)
                            (((unsupported)).apply ((((unsupported)).apply ((xTypeError)) ((xValueError)))))
                              seq
                                ((((xall)).apply ((((unsupported)).apply ((((((xself).x_choices_is_value)).apply ((xvalue))).and ((((xself).x_choices_is_value)).apply ((xhuman_name))))) ((((unsupported)).apply ((xvalue)) ((xhuman_name)))) ((xgroup_choices))))).not).if
                                  (((unsupported)).apply)
                                ((((unsupported)).apply (((xself).xmax_length)) ("None: is there a None literal in the EO language?")).and (xgroup_choices)).if
                                  xchoice_max_length.write (((xmax)).apply ((((unsupported)).apply ((xchoice_max_length)) ((((unsupported)).apply ((((unsupported)).apply ((((xlen)).apply ((xvalue)))) ((((unsupported)).apply ((xvalue)) ((x_)))) ((xgroup_choices)) ((((xisinstance)).apply ((xvalue)) ((xstr)))))))))))
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xvalue)) ((xhuman_name)))) ((((unsupported)).apply ((xgroup_name)) ((xgroup_choices)))))
                                ((((((xself).x_choices_is_value)).apply ((xvalue))).not).or (((((xself).x_choices_is_value)).apply ((xhuman_name))).not)).if
                                  (((unsupported)).apply)
                                ((((unsupported)).apply (((xself).xmax_length)) ("None: is there a None literal in the EO language?")).and (((xisinstance)).apply ((xvalue)) ((xstr)))).if
                                  xchoice_max_length.write (((xmax)).apply ((xchoice_max_length)) ((((xlen)).apply ((xvalue)))))
                            (((xisinstance)).apply ((xchoices_group)) ((xstr))).if
                              (((unsupported)).apply)
                          seq
                            ((((unsupported)).apply (((xself).xmax_length)) ("None: is there a None literal in the EO language?")).and ((xchoice_max_length).greater ((xself).xmax_length))).if
                              (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("'max_length' is too small to fit the longest value in 'choices' (%d characters).".mod (xchoice_max_length))) ((xself)) ("fields.E009"))))))
                            (((unsupported)).apply ((((unsupported)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'choices' must be an iterable containing (actual value, human readable name) tuples.") ((xself)) ("fields.E005"))))))
                x_check_db_index.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((xself).xdb_index)) ((((unsupported)).apply ("None: is there a None literal in the EO language?") (TRUE) (FALSE)))).if
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'db_index' must be None, True or False.") ((xself)) ("fields.E006"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_null_allowed_for_primary_keys.write
                  [xself]
                    seq > @
                      ((((xself).xprimary_key).and ((xself).xnull)).and ((((xconnection).xfeatures).xinterprets_empty_strings_as_nulls).not)).if
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("Primary keys must not have null=True.") ("Set null=False on the field, or remove primary_key=True argument.") ((xself)) ("fields.E007"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_backend_specific_checks.write
                  [xself xdatabases]
                    memory > xerrors
                    memory > xapp_label
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xdatabases)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xapp_label.write ((((xself).xmodel).x_meta).xapp_label)
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xalias)) ((xdatabases)))
                          (((unsupported)).apply (((xrouter).xallow_migrate)) ((xalias)) ((xapp_label)) (((((xself).xmodel).x_meta).xmodel_name))).if
                            bogusForceDataize.write ((((xerrors).xextend)).apply ((((((((unsupported)).apply ((xconnections)) ((xalias))).xvalidation).xcheck_field)).apply ((xself)) ((((unsupported)).apply ((xkwargs)))))))
                        (((unsupported)).apply ((xerrors)))
                x_check_validators.write
                  [xself]
                    memory > xerrors
                    seq > @
                      seq
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xi)) ((xvalidator)))) ((((xenumerate)).apply (((xself).xvalidators)))))
                          ((((xcallable)).apply ((xvalidator))).not).if
                            bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) ("All 'validators' must be callable.") ((((unsupported)).apply (("validators[{i}] ({repr}) isn't a function or instance of a validator class.".xformat)) ((xi)) ((((xrepr)).apply ((xvalidator)))))) ((xself)) ("fields.E008"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_deprecation_details.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xsystem_check_removed_details)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ((((((xself).xsystem_check_removed_details).xget)).apply ("msg") (("%s has been removed except for support in historical migrations.".mod (((xself).x__class__).x__name__))))) ((((((xself).xsystem_check_removed_details).xget)).apply ("hint"))) ((xself)) ((((((xself).xsystem_check_removed_details).xget)).apply ("id") ("fields.EXXX"))))))))
                          (((unsupported)).apply (((xself).xsystem_check_deprecated_details)) ("None: is there a None literal in the EO language?")).if
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xWarning)) ((((((xself).xsystem_check_deprecated_details).xget)).apply ("msg") (("%s has been deprecated.".mod (((xself).x__class__).x__name__))))) ((((((xself).xsystem_check_deprecated_details).xget)).apply ("hint"))) ((xself)) ((((((xself).xsystem_check_deprecated_details).xget)).apply ("id") ("fields.WXXX"))))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                xget_col.write
                  [xself xalias xoutput_field]
                    seq > @
                      (((unsupported)).apply)
                        (((xalias).eq ((((xself).xmodel).x_meta).xdb_table)).and ((((unsupported)).apply ((xoutput_field)) ("None: is there a None literal in the EO language?")).or ((xoutput_field).eq (xself)))).if
                          (((unsupported)).apply (((xself).xcached_col)))
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xCol)).apply ((xalias)) ((xself)) ((xoutput_field)))))
                xcached_col.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xCol)).apply (((((xself).xmodel).x_meta).xdb_table)) ((xself)))))
                xselect_format.write
                  [xself xcompiler xsql xparams]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
                xdeconstruct.write
                  [xself]
                    memory > xpossibles
                    memory > xvalue
                    memory > xpath
                    memory > xkeywords
                    memory > xequals_comparison
                    memory > xattr_overrides
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xkeywords.write (((unsupported)).apply)
                        xpossibles.write (((unsupported)).apply ("verbose_name") ("None: is there a None literal in the EO language?") ("primary_key") (FALSE) ("max_length") ("None: is there a None literal in the EO language?") ("unique") (FALSE) ("blank") (FALSE) ("null") (FALSE) ("db_index") (FALSE) ("default") ((xNOT_PROVIDED)) ("editable") (TRUE) ("serialize") (TRUE) ("unique_for_date") ("None: is there a None literal in the EO language?") ("unique_for_month") ("None: is there a None literal in the EO language?") ("unique_for_year") ("None: is there a None literal in the EO language?") ("choices") ("None: is there a None literal in the EO language?") ("help_text") ("") ("db_column") ("None: is there a None literal in the EO language?") ("db_tablespace") ("None: is there a None literal in the EO language?") ("auto_created") (FALSE) ("validators") ((((unsupported)).apply)) ("error_messages") ("None: is there a None literal in the EO language?"))
                        xattr_overrides.write (((unsupported)).apply ("unique") ("_unique") ("error_messages") ("_error_messages") ("validators") ("_validators") ("verbose_name") ("_verbose_name") ("db_tablespace") ("_db_tablespace"))
                        xequals_comparison.write (((unsupported)).apply ("choices") ("validators"))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xdefault)))) (((((xpossibles).xitems)).apply)))
                          seq
                            xvalue.write (((xgetattr)).apply ((xself)) (((((xattr_overrides).xget)).apply ((xname)) ((xname)))))
                            (((xname).eq "choices").and (((xisinstance)).apply ((xvalue)) ((((xcollections).xabc).xIterable)))).if
                              xvalue.write (((xlist)).apply ((xvalue)))
                            (((unsupported)).apply ((xname)) ((xequals_comparison))).if
                              ((xvalue).neq (xdefault)).if
                                (((unsupported)).apply ((((unsupported)).apply ((xkeywords)) ((xname)))) ((xvalue)))
                              (((unsupported)).apply ((xvalue)) ((xdefault))).if
                                (((unsupported)).apply ((((unsupported)).apply ((xkeywords)) ((xname)))) ((xvalue)))
                        xpath.write ("%s.%s".mod (((unsupported)).apply ((((xself).x__class__).x__module__)) ((((xself).x__class__).x__qualname__))))
                        ((((xpath).xstartswith)).apply ("django.db.models.fields.related")).if
                          xpath.write ((((xpath).xreplace)).apply ("django.db.models.fields.related") ("django.db.models"))
                          ((((xpath).xstartswith)).apply ("django.db.models.fields.files")).if
                            xpath.write ((((xpath).xreplace)).apply ("django.db.models.fields.files") ("django.db.models"))
                            ((((xpath).xstartswith)).apply ("django.db.models.fields.json")).if
                              xpath.write ((((xpath).xreplace)).apply ("django.db.models.fields.json") ("django.db.models"))
                              ((((xpath).xstartswith)).apply ("django.db.models.fields.proxy")).if
                                xpath.write ((((xpath).xreplace)).apply ("django.db.models.fields.proxy") ("django.db.models"))
                                ((((xpath).xstartswith)).apply ("django.db.models.fields")).if
                                  xpath.write ((((xpath).xreplace)).apply ("django.db.models.fields") ("django.db.models"))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xname)) ((xpath)) ((((unsupported)).apply)) ((xkeywords)))))
                xclone.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((xself).xdeconstruct)).apply)))
                        (((unsupported)).apply (((((xself).x__class__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                x__eq__.write
                  [xself xother]
                    seq > @
                      seq
                        (((xisinstance)).apply ((xother)) ((xField))).if
                          (((unsupported)).apply (((((xself).xcreation_counter).eq ((xother).xcreation_counter)).and ((((xgetattr)).apply ((xself)) ("model") ("None: is there a None literal in the EO language?")).eq (((xgetattr)).apply ((xother)) ("model") ("None: is there a None literal in the EO language?"))))))
                        (((unsupported)).apply ((xNotImplemented)))
                x__lt__.write
                  [xself xother]
                    seq > @
                      seq
                        (((xisinstance)).apply ((xother)) ((xField))).if
                          ((((xself).xcreation_counter).neq ((xother).xcreation_counter)).or (((((xhasattr)).apply ((xself)) ("model")).not).and ((((xhasattr)).apply ((xother)) ("model")).not))).if
                            (((unsupported)).apply ((((xself).xcreation_counter).less ((xother).xcreation_counter))))
                            ((((xhasattr)).apply ((xself)) ("model")).neq (((xhasattr)).apply ((xother)) ("model"))).if
                              (((unsupported)).apply (((((xhasattr)).apply ((xself)) ("model")).not)))
                              (((unsupported)).apply (((((unsupported)).apply (((((xself).xmodel).x_meta).xapp_label)) (((((xself).xmodel).x_meta).xmodel_name))).less (((unsupported)).apply (((((xother).xmodel).x_meta).xapp_label)) (((((xother).xmodel).x_meta).xmodel_name))))))
                        (((unsupported)).apply ((xNotImplemented)))
                x__hash__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xhash)).apply (((xself).xcreation_counter)))))
                x__deepcopy__.write
                  [xself xmemodict]
                    memory > xobj
                    seq > @
                      seq
                        xobj.write ((((xcopy).xcopy)).apply ((xself)))
                        ((xself).xremote_field).if
                          seq
                            (((unsupported)).apply (((xobj).xremote_field)) (((((xcopy).xcopy)).apply (((xself).xremote_field)))))
                            ((((xhasattr)).apply (((xself).xremote_field)) ("field")).and (((unsupported)).apply ((((xself).xremote_field).xfield)) ((xself)))).if
                              (((unsupported)).apply ((((xobj).xremote_field).xfield)) ((xobj)))
                        (((unsupported)).apply ((((unsupported)).apply ((xmemodict)) ((((xid)).apply ((xself)))))) ((xobj)))
                        (((unsupported)).apply ((xobj)))
                x__copy__.write
                  [xself]
                    memory > xobj
                    seq > @
                      seq
                        xobj.write (((xEmpty)).apply)
                        (((unsupported)).apply (((xobj).x__class__)) (((xself).x__class__)))
                        (((unsupported)).apply (((xobj).x__dict__)) ((((((xself).x__dict__).xcopy)).apply)))
                        (((unsupported)).apply ((xobj)))
                x__reduce__.write
                  [xself]
                    memory > xstate
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((((xhasattr)).apply ((xself)) ("model")).not).if
                          seq
                            xstate.write (((((xself).x__dict__).xcopy)).apply)
                            bogusForceDataize.write ((((xstate).xpop)).apply ("_get_default") ("None: is there a None literal in the EO language?"))
                            (((unsupported)).apply ((((unsupported)).apply ((x_empty)) ((((unsupported)).apply (((xself).x__class__)))) ((xstate)))))
                        (((unsupported)).apply ((((unsupported)).apply ((x_load_field)) ((((unsupported)).apply (((((xself).xmodel).x_meta).xapp_label)) (((((xself).xmodel).x_meta).xobject_name)) (((xself).xname)))))))
                xget_pk_value_on_save.write
                  [xself xinstance]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((xself).xdefault).if
                          (((unsupported)).apply (((((xself).xget_default)).apply)))
                        (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xto_python.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xvalue)))
                xerror_messages.write
                  [xself]
                    memory > xmessages
                    seq > @
                      (((unsupported)).apply)
                        xmessages.write (((unsupported)).apply)
                        (((unsupported)).apply ((xc)) ((((xreversed)).apply ((((xself).x__class__).x__mro__)))))
                          bogusForceDataize.write ((((xmessages).xupdate)).apply ((((xgetattr)).apply ((xc)) ("default_error_messages") ((((unsupported)).apply)))))
                        bogusForceDataize.write ((((xmessages).xupdate)).apply ((((xself).x_error_messages).or (((unsupported)).apply))))
                        (((unsupported)).apply ((xmessages)))
                xvalidators.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xself).xdefault_validators)))) ((((unsupported)).apply (((xself).x_validators)))))))
                xrun_validators.write
                  [xself xvalue]
                    memory > xerrors
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) (((xself).xempty_values))).if
                          (((unsupported)).apply)
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xv)) (((xself).xvalidators)))
                          (((unsupported)).apply (((xexceptions).xValidationError)))
                            bogusForceDataize.write (((xv)).apply ((xvalue)))
                            seq
                              ((((xhasattr)).apply ((xe)) ("code")).and (((unsupported)).apply (((xe).xcode)) (((xself).xerror_messages)))).if
                                (((unsupported)).apply (((xe).xmessage)) ((((unsupported)).apply (((xself).xerror_messages)) (((xe).xcode)))))
                              bogusForceDataize.write ((((xerrors).xextend)).apply (((xe).xerror_list)))
                        (xerrors).if
                          (((unsupported)).apply (((((xexceptions).xValidationError)).apply ((xerrors)))))
                xvalidate.write
                  [xself xvalue xmodel_instance]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xself).xeditable).not).if
                          (((unsupported)).apply)
                        ((((unsupported)).apply (((xself).xchoices)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xvalue)) (((xself).xempty_values)))).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xoption_key)) ((xoption_value)))) (((xself).xchoices)))
                              (((xisinstance)).apply ((xoption_value)) ((((unsupported)).apply ((xlist)) ((xtuple))))).if
                                (((unsupported)).apply ((((unsupported)).apply ((xoptgroup_key)) ((xoptgroup_value)))) ((xoption_value)))
                                  ((xvalue).eq (xoptgroup_key)).if
                                    (((unsupported)).apply)
                                ((xvalue).eq (xoption_key)).if
                                  (((unsupported)).apply)
                            (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid_choice"))) ("invalid_choice") ((((unsupported)).apply ("value") ((xvalue)))))))
                        ((((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).and (((xself).xnull).not)).if
                          (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("null"))) ("null"))))
                        ((((xself).xblank).not).and (((unsupported)).apply ((xvalue)) (((xself).xempty_values)))).if
                          (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("blank"))) ("blank"))))
                xclean.write
                  [xself xvalue xmodel_instance]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xvalue.write ((((xself).xto_python)).apply ((xvalue)))
                        bogusForceDataize.write ((((xself).xvalidate)).apply ((xvalue)) ((xmodel_instance)))
                        bogusForceDataize.write ((((xself).xrun_validators)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)))
                xdb_type_parameters.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ((((xDictWrapper)).apply (((xself).x__dict__)) ((((xconnection).xops).xquote_name)) ("qn_"))))
                xdb_check.write
                  [xself xconnection]
                    memory > xdata
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xdata.write ((((xself).xdb_type_parameters)).apply ((xconnection)))
                        (((unsupported)).apply ((xKeyError)))
                          (((unsupported)).apply (((((unsupported)).apply (((xconnection).xdata_type_check_constraints)) (((((xself).xget_internal_type)).apply))).mod (xdata))))
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xdb_type.write
                  [xself xconnection]
                    memory > xdata
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xdata.write ((((xself).xdb_type_parameters)).apply ((xconnection)))
                        (((unsupported)).apply ((xKeyError)))
                          (((unsupported)).apply (((((unsupported)).apply (((xconnection).xdata_types)) (((((xself).xget_internal_type)).apply))).mod (xdata))))
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xrel_db_type.write
                  [xself xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).xdb_type)).apply ((xconnection)))))
                xcast_db_type.write
                  [xself xconnection]
                    memory > xdb_type
                    seq > @
                      seq
                        unsupported
                        xdb_type.write ((((((xconnection).xops).xcast_data_types).xget)).apply (((((xself).xget_internal_type)).apply)))
                        (xdb_type).if
                          (((unsupported)).apply (((xdb_type).mod ((((xself).xdb_type_parameters)).apply ((xconnection))))))
                        (((unsupported)).apply (((((xself).xdb_type)).apply ((xconnection)))))
                xdb_parameters.write
                  [xself xconnection]
                    memory > xcheck_string
                    memory > xtype_string
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xtype_string.write ((((xself).xdb_type)).apply ((xconnection)))
                        xcheck_string.write ((((xself).xdb_check)).apply ((xconnection)))
                        (((unsupported)).apply ((((unsupported)).apply ("type") ((xtype_string)) ("check") ((xcheck_string)))))
                xdb_type_suffix.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ((((((xconnection).xdata_types_suffix).xget)).apply (((((xself).xget_internal_type)).apply)))))
                xget_db_converters.write
                  [xself xconnection]
                    seq > @
                      seq
                        (((xhasattr)).apply ((xself)) ("from_db_value")).if
                          (((unsupported)).apply ((((unsupported)).apply (((xself).xfrom_db_value)))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                xunique.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xself).x_unique).or ((xself).xprimary_key))))
                xdb_tablespace.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xself).x_db_tablespace).or ((xsettings).xDEFAULT_INDEX_TABLESPACE))))
                xdb_returning.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (FALSE))
                xset_attributes_from_name.write
                  [xself xname]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xname)) ((((xself).xname).or (xname))))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xattname)) (((xself).xcolumn)))) (((((xself).xget_attname_column)).apply)))
                        (((unsupported)).apply (((xself).xconcrete)) ((((unsupported)).apply (((xself).xcolumn)) ("None: is there a None literal in the EO language?"))))
                        ((((unsupported)).apply (((xself).xverbose_name)) ("None: is there a None literal in the EO language?")).and ((xself).xname)).if
                          (((unsupported)).apply (((xself).xverbose_name)) ((((((xself).xname).xreplace)).apply ("_") (" "))))
                xcontribute_to_class.write
                  [xself xcls xname xprivate_only]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xset_attributes_from_name)).apply ((xname)))
                        (((unsupported)).apply (((xself).xmodel)) ((xcls)))
                        (((unsupported)).apply ((((xcls).x_meta).xadd_field)) ((xself)) ((xprivate_only)))
                        ((xself).xcolumn).if
                          bogusForceDataize.write (((xsetattr)).apply ((xcls)) (((xself).xattname)) (((((xself).xdescriptor_class)).apply ((xself)))))
                        (((unsupported)).apply (((xself).xchoices)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (("get_%s_display".mod ((xself).xname))) (((xcls).x__dict__))).if
                            bogusForceDataize.write (((xsetattr)).apply ((xcls)) (("get_%s_display".mod ((xself).xname))) ((((unsupported)).apply ((xpartialmethod)) (((xcls).x_get_FIELD_display)) ((xself)))))
                xget_filter_kwargs_for_object.write
                  [xself xobj]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xname)) ((((xgetattr)).apply ((xobj)) (((xself).xattname)))))))
                xget_attname.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((xself).xname)))
                xget_attname_column.write
                  [xself]
                    memory > xcolumn
                    memory > xattname
                    seq > @
                      seq
                        xattname.write ((((xself).xget_attname)).apply)
                        xcolumn.write (((xself).xdb_column).or (xattname))
                        (((unsupported)).apply ((((unsupported)).apply ((xattname)) ((xcolumn)))))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xself).x__class__).x__name__)))
                xpre_save.write
                  [xself xmodel_instance xadd]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((((xgetattr)).apply ((xmodel_instance)) (((xself).xattname)))))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        unsupported
                        (((xisinstance)).apply ((xvalue)) ((xPromise))).if
                          xvalue.write ((((xvalue).x_proxy____cast)).apply)
                        (((unsupported)).apply ((xvalue)))
                xget_db_prep_value.write
                  [xself xvalue xconnection xprepared]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        ((xprepared).not).if
                          xvalue.write ((((xself).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)))
                xget_db_prep_save.write
                  [xself xvalue xconnection]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xget_db_prep_value)) ((xvalue)) ((xconnection)) (FALSE))))
                xhas_default.write
                  [xself]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xdefault)) ((xNOT_PROVIDED)))))
                xget_default.write
                  [xself]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((((xself).x_get_default)).apply)))
                x_get_default.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        ((((xself).xhas_default)).apply).if
                          seq
                            (((xcallable)).apply (((xself).xdefault))).if
                              (((unsupported)).apply (((xself).xdefault)))
                            (((unsupported)).apply ((((unsupported)).apply (((xself).xdefault)))))
                        ((((xself).xempty_strings_allowed).not).or (((xself).xnull).and ((((xconnection).xfeatures).xinterprets_empty_strings_as_nulls).not))).if
                          (((unsupported)).apply ((xreturn_None)))
                        (((unsupported)).apply ((xstr)))
                xget_choices.write
                  [xself xinclude_blank xblank_choice xlimit_choices_to xordering]
                    memory > xqs
                    memory > xchoice_func
                    memory > xblank_defined
                    memory > xchoices
                    memory > xrel_model
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xchoices)) ("None: is there a None literal in the EO language?")).if
                          seq
                            xchoices.write (((xlist)).apply (((xself).xchoices)))
                            (xinclude_blank).if
                              seq
                                xblank_defined.write (((xany)).apply ((((unsupported)).apply ((((unsupported)).apply ((xchoice)) ((((unsupported)).apply ("") ("None: is there a None literal in the EO language?"))))) ((((unsupported)).apply ((xchoice)) ((x_)))) (((xself).xflatchoices)))))
                                ((xblank_defined).not).if
                                  xchoices.write ((xblank_choice).sub (xchoices))
                            (((unsupported)).apply ((xchoices)))
                        xrel_model.write (((xself).xremote_field).xmodel)
                        xlimit_choices_to.write ((xlimit_choices_to).or ((((xself).xget_limit_choices_to)).apply))
                        xchoice_func.write ((((xoperator).xattrgetter)).apply (((((xhasattr)).apply (((xself).xremote_field)) ("get_related_field")).if ((((((xself).xremote_field).xget_related_field)).apply).xattname) "pk")))
                        xqs.write (((((xrel_model).x_default_manager).xcomplex_filter)).apply ((xlimit_choices_to)))
                        (xordering).if
                          xqs.write ((((xqs).xorder_by)).apply ((((unsupported)).apply ((xordering)))))
                        (((unsupported)).apply ((((xinclude_blank).if (xblank_choice) (((unsupported)).apply)).sub (((unsupported)).apply ((((unsupported)).apply ((((xchoice_func)).apply ((xx)))) ((((xstr)).apply ((xx)))))) ((xx)) ((xqs))))))
                xvalue_to_string.write
                  [xself xobj]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xstr)).apply (((((xself).xvalue_from_object)).apply ((xobj)))))))
                x_get_flatchoices.write
                  [xself]
                    memory > xflat
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xself).xchoices)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xflat.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xchoice)) ((xvalue)))) (((xself).xchoices)))
                          (((xisinstance)).apply ((xvalue)) ((((unsupported)).apply ((xlist)) ((xtuple))))).if
                            bogusForceDataize.write ((((xflat).xextend)).apply ((xvalue)))
                            bogusForceDataize.write ((((xflat).xappend)).apply ((((unsupported)).apply ((xchoice)) ((xvalue)))))
                        (((unsupported)).apply ((xflat)))
                xflatchoices.write (((xproperty)).apply ((x_get_flatchoices)))
                xsave_form_data.write
                  [xself xinstance xdata]
                    seq > @
                      bogusForceDataize.write (((xsetattr)).apply ((xinstance)) (((xself).xname)) ((xdata)))
                xformfield.write
                  [xself xform_class xchoices_form_class]
                    memory > xdefaults
                    memory > xinclude_blank
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xdefaults.write (((unsupported)).apply ("required") ((((xself).xblank).not)) ("label") ((((xcapfirst)).apply (((xself).xverbose_name)))) ("help_text") (((xself).xhelp_text)))
                        ((((xself).xhas_default)).apply).if
                          (((xcallable)).apply (((xself).xdefault))).if
                            seq
                              (((unsupported)).apply ((((unsupported)).apply ((xdefaults)) ("initial"))) (((xself).xdefault)))
                              (((unsupported)).apply ((((unsupported)).apply ((xdefaults)) ("show_hidden_initial"))) (TRUE))
                            (((unsupported)).apply ((((unsupported)).apply ((xdefaults)) ("initial"))) (((((xself).xget_default)).apply)))
                        (((unsupported)).apply (((xself).xchoices)) ("None: is there a None literal in the EO language?")).if
                          seq
                            xinclude_blank.write (((xself).xblank).or ((((((xself).xhas_default)).apply).or (((unsupported)).apply ("initial") ((xkwargs)))).not))
                            (((unsupported)).apply ((((unsupported)).apply ((xdefaults)) ("choices"))) ((((unsupported)).apply (((xself).xget_choices)) ((xinclude_blank)))))
                            (((unsupported)).apply ((((unsupported)).apply ((xdefaults)) ("coerce"))) (((xself).xto_python)))
                            ((xself).xnull).if
                              (((unsupported)).apply ((((unsupported)).apply ((xdefaults)) ("empty_value"))) ("None: is there a None literal in the EO language?"))
                            (((unsupported)).apply ((xchoices_form_class)) ("None: is there a None literal in the EO language?")).if
                              xform_class.write (xchoices_form_class)
                              xform_class.write ((xforms).xTypedChoiceField)
                            (((unsupported)).apply ((xk)) ((((xlist)).apply ((xkwargs)))))
                              (((unsupported)).apply ((xk)) ((((unsupported)).apply ("coerce") ("empty_value") ("choices") ("required") ("widget") ("label") ("initial") ("help_text") ("error_messages") ("show_hidden_initial") ("disabled")))).if
                                (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ((xk)))))))
                        bogusForceDataize.write ((((xdefaults).xupdate)).apply ((xkwargs)))
                        (((unsupported)).apply ((xform_class)) ("None: is there a None literal in the EO language?")).if
                          xform_class.write ((xforms).xCharField)
                        (((unsupported)).apply ((((xform_class)).apply ((((unsupported)).apply ((xdefaults)))))))
                xvalue_from_object.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((((xgetattr)).apply ((xobj)) (((xself).xattname)))))
            (((unsupported)).apply ((xField)))
              seq
                xempty_strings_allowed.write FALSE
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("%(value)s value must be either True or False."))) ("invalid_nullable") ((((x_)).apply ("%(value)s value must be either True, False, or None."))))
                xdescription.write (((x_)).apply ("Boolean (Either True or False)"))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("BooleanField"))
                xto_python.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((xself).xnull).and (((unsupported)).apply ((xvalue)) (((xself).xempty_values)))).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((xvalue)) ((((unsupported)).apply (TRUE) (FALSE)))).if
                          (((unsupported)).apply ((((xbool)).apply ((xvalue)))))
                        (((unsupported)).apply ((xvalue)) ((((unsupported)).apply ("t") ("True") ("1")))).if
                          (((unsupported)).apply (TRUE))
                        (((unsupported)).apply ((xvalue)) ((((unsupported)).apply ("f") ("False") ("0")))).if
                          (((unsupported)).apply (FALSE))
                        (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ((((xself).xnull).if "invalid_nullable" "invalid")))) ("invalid") ((((unsupported)).apply ("value") ((xvalue)))))))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((((xself).xto_python)).apply ((xvalue)))))
                xformfield.write
                  [xself]
                    memory > xdefaults
                    memory > xform_class
                    memory > xinclude_blank
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xchoices)) ("None: is there a None literal in the EO language?")).if
                          seq
                            xinclude_blank.write ((((((xself).xhas_default)).apply).or (((unsupported)).apply ("initial") ((xkwargs)))).not)
                            xdefaults.write (((unsupported)).apply ("choices") ((((unsupported)).apply (((xself).xget_choices)) ((xinclude_blank)))))
                          seq
                            xform_class.write (((xself).xnull).if ((xforms).xNullBooleanField) ((xforms).xBooleanField))
                            xdefaults.write (((unsupported)).apply ("form_class") ((xform_class)) ("required") (FALSE))
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ((xdefaults)) ((xkwargs)))))))))
                xselect_format.write
                  [xself xcompiler xsql xparams]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((((xsuper)).apply).xselect_format)).apply ((xcompiler)) ((xsql)) ((xparams)))))
                        ((xsql).eq "").if
                          xsql.write "1"
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
            (((unsupported)).apply ((xField)))
              seq
                xdescription.write (((x_)).apply ("String (up to %(max_length)s)"))
                x__init__.write
                  [xself xdb_collation]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((xself).xdb_collation)) ((xdb_collation)))
                        (((unsupported)).apply (((xself).xmax_length)) ("None: is there a None literal in the EO language?")).if
                          bogusForceDataize.write (((((xself).xvalidators).xappend)).apply (((((xvalidators).xMaxLengthValidator)).apply (((xself).xmax_length)))))
                xcheck.write
                  [xself]
                    memory > xdatabases
                    seq > @
                      (((unsupported)).apply)
                        xdatabases.write (((((xkwargs).xget)).apply ("databases")).or (((unsupported)).apply))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_db_collation)).apply ((xdatabases)))))) ((((unsupported)).apply (((((xself).x_check_max_length_attribute)).apply ((((unsupported)).apply ((xkwargs)))))))))))
                x_check_max_length_attribute.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xmax_length)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("CharFields must define a 'max_length' attribute.") ((xself)) ("fields.E120"))))))
                          ((((((xisinstance)).apply (((xself).xmax_length)) ((xint))).not).or (((xisinstance)).apply (((xself).xmax_length)) ((xbool)))).or (((xself).xmax_length).leq 0)).if
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'max_length' must be a positive integer.") ((xself)) ("fields.E121"))))))
                            (((unsupported)).apply ((((unsupported)).apply)))
                x_check_db_collation.write
                  [xself xdatabases]
                    memory > xerrors
                    memory > xconnection
                    seq > @
                      seq
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xdb)) ((xdatabases)))
                          seq
                            (((((xrouter).xallow_migrate_model)).apply ((xdb)) (((xself).xmodel))).not).if
                              (((unsupported)).apply)
                            xconnection.write (((unsupported)).apply ((xconnections)) ((xdb)))
                            ((((((unsupported)).apply (((xself).xdb_collation)) ("None: is there a None literal in the EO language?")).or (((unsupported)).apply ("supports_collation_on_charfield") (((((xself).xmodel).x_meta).xrequired_db_features)))).or (((xconnection).xfeatures).xsupports_collation_on_charfield)).not).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("%s does not support a database collation on CharFields.".mod ((xconnection).xdisplay_name))) ((xself)) ("fields.E190"))))
                        (((unsupported)).apply ((xerrors)))
                xcast_db_type.write
                  [xself xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xmax_length)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((xconnection).xops).xcast_char_field_without_max_length)))
                        (((unsupported)).apply (((((((xsuper)).apply).xcast_db_type)).apply ((xconnection)))))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("CharField"))
                xto_python.write
                  [xself xvalue]
                    seq > @
                      seq
                        ((((xisinstance)).apply ((xvalue)) ((xstr))).or (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?"))).if
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply ((((xstr)).apply ((xvalue)))))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply (((((xself).xto_python)).apply ((xvalue)))))
                xformfield.write
                  [xself]
                    memory > xdefaults
                    seq > @
                      (((unsupported)).apply)
                        xdefaults.write (((unsupported)).apply ("max_length") (((xself).xmax_length)))
                        (((xself).xnull).and ((((xconnection).xfeatures).xinterprets_empty_strings_as_nulls).not)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xdefaults)) ("empty_value"))) ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xdefaults).xupdate)).apply ((xkwargs)))
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((xdefaults)))))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        ((xself).xdb_collation).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("db_collation"))) (((xself).xdb_collation)))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
            (((unsupported)).apply ((xCharField)))
              seq
                xdefault_validators.write (((unsupported)).apply (((xvalidators).xvalidate_comma_separated_integer_list)))
                xdescription.write (((x_)).apply ("Comma-separated integers"))
                xsystem_check_removed_details.write (((unsupported)).apply ("msg") ("CommaSeparatedIntegerField is removed except for support in historical migrations.") ("hint") ("Use CharField(validators=[validate_comma_separated_integer_list]) instead.") ("id") ("fields.E901"))
            x_to_naive.write
              [xvalue]
                seq > @
                  seq
                    ((((xtimezone).xis_aware)).apply ((xvalue))).if
                      xvalue.write ((((xtimezone).xmake_naive)).apply ((xvalue)) ((((xdatetime).xtimezone).xutc)))
                    (((unsupported)).apply ((xvalue)))
            x_get_naive_now.write
              []
                seq > @
                  (((unsupported)).apply ((((x_to_naive)).apply (((((xtimezone).xnow)).apply)))))
            (((unsupported)).apply)
              seq
                xcheck.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_mutually_exclusive_options)).apply)))) ((((unsupported)).apply (((((xself).x_check_fix_default_value)).apply)))))))
                x_check_mutually_exclusive_options.write
                  [xself]
                    memory > xenabled_options
                    memory > xmutually_exclusive_options
                    seq > @
                      seq
                        xmutually_exclusive_options.write (((unsupported)).apply (((xself).xauto_now_add)) (((xself).xauto_now)) (((((xself).xhas_default)).apply)))
                        xenabled_options.write ((((((unsupported)).apply ((((unsupported)).apply ((xoption)) ((((unsupported)).apply ("None: is there a None literal in the EO language?") (FALSE))))) ((xoption)) ((xmutually_exclusive_options))).xcount)).apply (TRUE))
                        ((xenabled_options).greater 1).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("The options auto_now, auto_now_add, and default are mutually exclusive. Only one of these options may be present.") ((xself)) ("fields.E160"))))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_fix_default_value.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply)))
                x_check_if_value_fixed.write
                  [xself xvalue xnow]
                    memory > xlower
                    memory > xupper
                    memory > xoffset
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xnow)) ("None: is there a None literal in the EO language?")).if
                          xnow.write (((x_get_naive_now)).apply)
                        xoffset.write (((unsupported)).apply (((xdatetime).xtimedelta)) (10))
                        xlower.write ((xnow).sub (xoffset))
                        xupper.write ((xnow).sub (xoffset))
                        (((xisinstance)).apply ((xvalue)) (((xdatetime).xdatetime))).if
                          xvalue.write (((x_to_naive)).apply ((xvalue)))
                          seq
                            (((unsupported)).apply ((((xisinstance)).apply ((xvalue)) (((xdatetime).xdate)))))
                            xlower.write ((((xlower).xdate)).apply)
                            xupper.write ((((xupper).xdate)).apply)
                        (((unsupported)).apply ((xlower)) ((xvalue)) ((xupper))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xWarning)) ("Fixed default value provided.") ("It seems you set a fixed date / time / datetime value as default for this field. This may not be what you want. If you want to have the current date as default, use `django.utils.timezone.now`") ((xself)) ("fields.W161"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
            (((unsupported)).apply ((xDateTimeCheckMixin)) ((xField)))
              seq
                xempty_strings_allowed.write FALSE
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("%(value)s value has an invalid date format. It must be in YYYY-MM-DD format."))) ("invalid_date") ((((x_)).apply ("%(value)s value has the correct format (YYYY-MM-DD) but it is an invalid date."))))
                xdescription.write (((x_)).apply ("Date (without time)"))
                x__init__.write
                  [xself xverbose_name xname xauto_now xauto_now_add]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xauto_now)) (((xself).xauto_now_add)))) ((((unsupported)).apply ((xauto_now)) ((xauto_now_add)))))
                        ((xauto_now).or (xauto_now_add)).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("editable"))) (FALSE))
                            (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("blank"))) (TRUE))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xverbose_name)) ((xname)) ((((unsupported)).apply ((xkwargs)))))
                x_check_fix_default_value.write
                  [xself]
                    memory > xvalue
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((((xself).xhas_default)).apply).not).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xvalue.write ((xself).xdefault)
                        (((xisinstance)).apply ((xvalue)) (((xdatetime).xdatetime))).if
                          xvalue.write ((((((x_to_naive)).apply ((xvalue))).xdate)).apply)
                          (((xisinstance)).apply ((xvalue)) (((xdatetime).xdate))).if
                            (((unsupported)).apply ((((unsupported)).apply)))
                        (((unsupported)).apply (((((xself).x_check_if_value_fixed)).apply ((xvalue)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        ((xself).xauto_now).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("auto_now"))) (TRUE))
                        ((xself).xauto_now_add).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("auto_now_add"))) (TRUE))
                        (((xself).xauto_now).or ((xself).xauto_now_add)).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("editable"))))))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("blank"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("DateField"))
                xto_python.write
                  [xself xvalue]
                    memory > xdefault_timezone
                    memory > xparsed
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xvalue)))
                        (((xisinstance)).apply ((xvalue)) (((xdatetime).xdatetime))).if
                          seq
                            (((xsettings).xUSE_TZ).and ((((xtimezone).xis_aware)).apply ((xvalue)))).if
                              seq
                                xdefault_timezone.write ((((xtimezone).xget_default_timezone)).apply)
                                xvalue.write ((((xtimezone).xmake_naive)).apply ((xvalue)) ((xdefault_timezone)))
                            (((unsupported)).apply (((((xvalue).xdate)).apply)))
                        (((xisinstance)).apply ((xvalue)) (((xdatetime).xdate))).if
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply ((xValueError)))
                          seq
                            xparsed.write (((xparse_date)).apply ((xvalue)))
                            (((unsupported)).apply ((xparsed)) ("None: is there a None literal in the EO language?")).if
                              (((unsupported)).apply ((xparsed)))
                          (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid_date"))) ("invalid_date") ((((unsupported)).apply ("value") ((xvalue)))))))
                        (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))) ("invalid") ((((unsupported)).apply ("value") ((xvalue)))))))
                xpre_save.write
                  [xself xmodel_instance xadd]
                    memory > xvalue
                    seq > @
                      (((xself).xauto_now).or (((xself).xauto_now_add).and (xadd))).if
                        seq
                          xvalue.write (((((xdatetime).xdate).xtoday)).apply)
                          bogusForceDataize.write (((xsetattr)).apply ((xmodel_instance)) (((xself).xattname)) ((xvalue)))
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply (((((((xsuper)).apply).xpre_save)).apply ((xmodel_instance)) ((xadd)))))
                xcontribute_to_class.write
                  [xself xcls xname]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).xcontribute_to_class)).apply ((xcls)) ((xname)) ((((unsupported)).apply ((xkwargs)))))
                        (((xself).xnull).not).if
                          seq
                            bogusForceDataize.write (((xsetattr)).apply ((xcls)) (("get_next_by_%s".mod ((xself).xname))) ((((unsupported)).apply ((xpartialmethod)) (((xcls).x_get_next_or_previous_by_FIELD)) ((xself)) (TRUE))))
                            bogusForceDataize.write (((xsetattr)).apply ((xcls)) (("get_previous_by_%s".mod ((xself).xname))) ((((unsupported)).apply ((xpartialmethod)) (((xcls).x_get_next_or_previous_by_FIELD)) ((xself)) (FALSE))))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply (((((xself).xto_python)).apply ((xvalue)))))
                xget_db_prep_value.write
                  [xself xvalue xconnection xprepared]
                    seq > @
                      (((unsupported)).apply)
                        ((xprepared).not).if
                          xvalue.write ((((xself).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply ((((((xconnection).xops).xadapt_datefield_value)).apply ((xvalue)))))
                xvalue_to_string.write
                  [xself xobj]
                    memory > xval
                    seq > @
                      seq
                        xval.write ((((xself).xvalue_from_object)).apply ((xobj)))
                        (((unsupported)).apply (((((unsupported)).apply ((xval)) ("None: is there a None literal in the EO language?")).if "" ((((xval).xisoformat)).apply))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xDateField)) ((xkwargs)))))))))
            (((unsupported)).apply ((xDateField)))
              seq
                xempty_strings_allowed.write FALSE
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("%(value)s value has an invalid format. It must be in YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] format."))) ("invalid_date") ((((x_)).apply ("%(value)s value has the correct format (YYYY-MM-DD) but it is an invalid date."))) ("invalid_datetime") ((((x_)).apply ("%(value)s value has the correct format (YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]) but it is an invalid date/time."))))
                xdescription.write (((x_)).apply ("Date (with time)"))
                x_check_fix_default_value.write
                  [xself]
                    memory > xvalue
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((((xself).xhas_default)).apply).not).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xvalue.write ((xself).xdefault)
                        (((xisinstance)).apply ((xvalue)) ((((unsupported)).apply (((xdatetime).xdatetime)) (((xdatetime).xdate))))).if
                          (((unsupported)).apply (((((xself).x_check_if_value_fixed)).apply ((xvalue)))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("DateTimeField"))
                xto_python.write
                  [xself xvalue]
                    memory > xdefault_timezone
                    memory > xparsed
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xvalue)))
                        (((xisinstance)).apply ((xvalue)) (((xdatetime).xdatetime))).if
                          (((unsupported)).apply ((xvalue)))
                        (((xisinstance)).apply ((xvalue)) (((xdatetime).xdate))).if
                          seq
                            xvalue.write ((((xdatetime).xdatetime)).apply (((xvalue).xyear)) (((xvalue).xmonth)) (((xvalue).xday)))
                            ((xsettings).xUSE_TZ).if
                              seq
                                bogusForceDataize.write ((((xwarnings).xwarn)).apply (("DateTimeField %s.%s received a naive datetime (%s) while time zone support is active.".mod (((unsupported)).apply ((((xself).xmodel).x__name__)) (((xself).xname)) ((xvalue))))) ((xRuntimeWarning)))
                                xdefault_timezone.write ((((xtimezone).xget_default_timezone)).apply)
                                xvalue.write ((((xtimezone).xmake_aware)).apply ((xvalue)) ((xdefault_timezone)))
                            (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply ((xValueError)))
                          seq
                            xparsed.write (((xparse_datetime)).apply ((xvalue)))
                            (((unsupported)).apply ((xparsed)) ("None: is there a None literal in the EO language?")).if
                              (((unsupported)).apply ((xparsed)))
                          (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid_datetime"))) ("invalid_datetime") ((((unsupported)).apply ("value") ((xvalue)))))))
                        (((unsupported)).apply ((xValueError)))
                          seq
                            xparsed.write (((xparse_date)).apply ((xvalue)))
                            (((unsupported)).apply ((xparsed)) ("None: is there a None literal in the EO language?")).if
                              (((unsupported)).apply (((((xdatetime).xdatetime)).apply (((xparsed).xyear)) (((xparsed).xmonth)) (((xparsed).xday)))))
                          (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid_date"))) ("invalid_date") ((((unsupported)).apply ("value") ((xvalue)))))))
                        (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))) ("invalid") ((((unsupported)).apply ("value") ((xvalue)))))))
                xpre_save.write
                  [xself xmodel_instance xadd]
                    memory > xvalue
                    seq > @
                      (((xself).xauto_now).or (((xself).xauto_now_add).and (xadd))).if
                        seq
                          xvalue.write ((((xtimezone).xnow)).apply)
                          bogusForceDataize.write (((xsetattr)).apply ((xmodel_instance)) (((xself).xattname)) ((xvalue)))
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply (((((((xsuper)).apply).xpre_save)).apply ((xmodel_instance)) ((xadd)))))
                xget_prep_value.write
                  [xself xvalue]
                    memory > xname
                    memory > xdefault_timezone
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        xvalue.write ((((xself).xto_python)).apply ((xvalue)))
                        (((((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).and ((xsettings).xUSE_TZ)).and ((((xtimezone).xis_naive)).apply ((xvalue)))).if
                          seq
                            (((unsupported)).apply ((xAttributeError)))
                              xname.write ("%s.%s".mod (((unsupported)).apply ((((xself).xmodel).x__name__)) (((xself).xname))))
                              xname.write "(unbound)"
                            bogusForceDataize.write ((((xwarnings).xwarn)).apply (("DateTimeField %s received a naive datetime (%s) while time zone support is active.".mod (((unsupported)).apply ((xname)) ((xvalue))))) ((xRuntimeWarning)))
                            xdefault_timezone.write ((((xtimezone).xget_default_timezone)).apply)
                            xvalue.write ((((xtimezone).xmake_aware)).apply ((xvalue)) ((xdefault_timezone)))
                        (((unsupported)).apply ((xvalue)))
                xget_db_prep_value.write
                  [xself xvalue xconnection xprepared]
                    seq > @
                      (((unsupported)).apply)
                        ((xprepared).not).if
                          xvalue.write ((((xself).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply ((((((xconnection).xops).xadapt_datetimefield_value)).apply ((xvalue)))))
                xvalue_to_string.write
                  [xself xobj]
                    memory > xval
                    seq > @
                      seq
                        xval.write ((((xself).xvalue_from_object)).apply ((xobj)))
                        (((unsupported)).apply (((((unsupported)).apply ((xval)) ("None: is there a None literal in the EO language?")).if "" ((((xval).xisoformat)).apply))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xDateTimeField)) ((xkwargs)))))))))
            (((unsupported)).apply ((xField)))
              seq
                xempty_strings_allowed.write FALSE
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("%(value)s value must be a decimal number."))))
                xdescription.write (((x_)).apply ("Decimal number"))
                x__init__.write
                  [xself xverbose_name xname xmax_digits xdecimal_places]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xmax_digits)) (((xself).xdecimal_places)))) ((((unsupported)).apply ((xmax_digits)) ((xdecimal_places)))))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xverbose_name)) ((xname)) ((((unsupported)).apply ((xkwargs)))))
                xcheck.write
                  [xself]
                    memory > xerrors
                    memory > xdigits_errors
                    seq > @
                      (((unsupported)).apply)
                        xerrors.write ((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))
                        xdigits_errors.write (((unsupported)).apply ((((unsupported)).apply (((((xself).x_check_decimal_places)).apply)))) ((((unsupported)).apply (((((xself).x_check_max_digits)).apply)))))
                        ((xdigits_errors).not).if
                          bogusForceDataize.write ((((xerrors).xextend)).apply (((((xself).x_check_decimal_places_and_max_digits)).apply ((((unsupported)).apply ((xkwargs)))))))
                          bogusForceDataize.write ((((xerrors).xextend)).apply ((xdigits_errors)))
                        (((unsupported)).apply ((xerrors)))
                x_check_decimal_places.write
                  [xself]
                    memory > xdecimal_places
                    seq > @
                      (((unsupported)).apply ((xTypeError)) ((xValueError)))
                        seq
                          xdecimal_places.write (((xint)).apply (((xself).xdecimal_places)))
                          ((xdecimal_places).less 0).if
                            (((unsupported)).apply ((((xValueError)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("DecimalFields must define a 'decimal_places' attribute.") ((xself)) ("fields.E130"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'decimal_places' must be a non-negative integer.") ((xself)) ("fields.E131"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_max_digits.write
                  [xself]
                    memory > xmax_digits
                    seq > @
                      (((unsupported)).apply ((xTypeError)) ((xValueError)))
                        seq
                          xmax_digits.write (((xint)).apply (((xself).xmax_digits)))
                          ((xmax_digits).leq 0).if
                            (((unsupported)).apply ((((xValueError)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("DecimalFields must define a 'max_digits' attribute.") ((xself)) ("fields.E132"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'max_digits' must be a positive integer.") ((xself)) ("fields.E133"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_decimal_places_and_max_digits.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        ((((xint)).apply (((xself).xdecimal_places))).greater (((xint)).apply (((xself).xmax_digits)))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'max_digits' must be greater or equal to 'decimal_places'.") ((xself)) ("fields.E134"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                xvalidators.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((((xsuper)).apply).xvalidators).sub (((unsupported)).apply (((((xvalidators).xDecimalValidator)).apply (((xself).xmax_digits)) (((xself).xdecimal_places))))))))
                xcontext.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xdecimal).xContext)) (((xself).xmax_digits)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply (((xself).xmax_digits)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("max_digits"))) (((xself).xmax_digits)))
                        (((unsupported)).apply (((xself).xdecimal_places)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("decimal_places"))) (((xself).xdecimal_places)))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("DecimalField"))
                xto_python.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xvalue)))
                        (((xisinstance)).apply ((xvalue)) ((xfloat))).if
                          seq
                            ((((xmath).xisnan)).apply ((xvalue))).if
                              (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))) ("invalid") ((((unsupported)).apply ("value") ((xvalue)))))))
                            (((unsupported)).apply ((((((xself).xcontext).xcreate_decimal_from_float)).apply ((xvalue)))))
                        (((unsupported)).apply ((((unsupported)).apply (((xdecimal).xInvalidOperation)) ((xTypeError)) ((xValueError)))))
                          (((unsupported)).apply (((((xdecimal).xDecimal)).apply ((xvalue)))))
                          (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))) ("invalid") ((((unsupported)).apply ("value") ((xvalue)))))))
                xget_db_prep_save.write
                  [xself xvalue xconnection]
                    seq > @
                      (((unsupported)).apply ((((((xconnection).xops).xadapt_decimalfield_value)).apply (((((xself).xto_python)).apply ((xvalue)))) (((xself).xmax_digits)) (((xself).xdecimal_places)))))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply (((((xself).xto_python)).apply ((xvalue)))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("max_digits") (((xself).xmax_digits)) ("decimal_places") (((xself).xdecimal_places)) ("form_class") (((xforms).xDecimalField)) ((xkwargs)))))))))
            (((unsupported)).apply ((xField)))
              seq
                (((unsupported)).apply)
                xempty_strings_allowed.write FALSE
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("%(value)s value has an invalid format. It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format."))))
                xdescription.write (((x_)).apply ("Duration"))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("DurationField"))
                xto_python.write
                  [xself xvalue]
                    memory > xparsed
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xvalue)))
                        (((xisinstance)).apply ((xvalue)) (((xdatetime).xtimedelta))).if
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply ((xValueError)))
                          xparsed.write (((xparse_duration)).apply ((xvalue)))
                          (((unsupported)).apply ((xparsed)) ("None: is there a None literal in the EO language?")).if
                            (((unsupported)).apply ((xparsed)))
                        (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))) ("invalid") ((((unsupported)).apply ("value") ((xvalue)))))))
                xget_db_prep_value.write
                  [xself xvalue xconnection xprepared]
                    seq > @
                      (((unsupported)).apply)
                        (((xconnection).xfeatures).xhas_native_duration_field).if
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((((xduration_microseconds)).apply ((xvalue)))))
                xget_db_converters.write
                  [xself xconnection]
                    memory > xconverters
                    seq > @
                      seq
                        xconverters.write (((unsupported)).apply)
                        ((((xconnection).xfeatures).xhas_native_duration_field).not).if
                          bogusForceDataize.write ((((xconverters).xappend)).apply ((((xconnection).xops).xconvert_durationfield_value)))
                        (((unsupported)).apply (((xconverters).sub ((((((xsuper)).apply).xget_db_converters)).apply ((xconnection))))))
                xvalue_to_string.write
                  [xself xobj]
                    memory > xval
                    seq > @
                      seq
                        xval.write ((((xself).xvalue_from_object)).apply ((xobj)))
                        (((unsupported)).apply (((((unsupported)).apply ((xval)) ("None: is there a None literal in the EO language?")).if "" (((xduration_string)).apply ((xval))))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xDurationField)) ((xkwargs)))))))))
            (((unsupported)).apply ((xCharField)))
              seq
                xdefault_validators.write (((unsupported)).apply (((xvalidators).xvalidate_email)))
                xdescription.write (((x_)).apply ("Email address"))
                x__init__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xkwargs).xsetdefault)).apply ("max_length") (254))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xEmailField)) ((xkwargs)))))))))
            (((unsupported)).apply ((xField)))
              seq
                xdescription.write (((x_)).apply ("File path"))
                x__init__.write
                  [xself xverbose_name xname xpath xmatch xrecursive xallow_files xallow_folders]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xpath)) (((xself).xmatch)) (((xself).xrecursive)))) ((((unsupported)).apply ((xpath)) ((xmatch)) ((xrecursive)))))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xallow_files)) (((xself).xallow_folders)))) ((((unsupported)).apply ((xallow_files)) ((xallow_folders)))))
                        bogusForceDataize.write ((((xkwargs).xsetdefault)).apply ("max_length") (100))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xverbose_name)) ((xname)) ((((unsupported)).apply ((xkwargs)))))
                xcheck.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_allowing_files_or_folders)).apply ((((unsupported)).apply ((xkwargs)))))))))))
                x_check_allowing_files_or_folders.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        ((((xself).xallow_files).not).and (((xself).xallow_folders).not)).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("FilePathFields must have either 'allow_files' or 'allow_folders' set to True.") ((xself)) ("fields.E140"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((xself).xpath).neq "").if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("path"))) (((xself).xpath)))
                        (((unsupported)).apply (((xself).xmatch)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("match"))) (((xself).xmatch)))
                        (((unsupported)).apply (((xself).xrecursive)) (FALSE)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("recursive"))) (((xself).xrecursive)))
                        (((unsupported)).apply (((xself).xallow_files)) (TRUE)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("allow_files"))) (((xself).xallow_files)))
                        (((unsupported)).apply (((xself).xallow_folders)) (FALSE)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("allow_folders"))) (((xself).xallow_folders)))
                        (((((xkwargs).xget)).apply ("max_length")).eq 100).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("max_length"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((((xstr)).apply ((xvalue)))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("path") (((((xcallable)).apply (((xself).xpath))).if ((((xself).xpath)).apply) ((xself).xpath))) ("match") (((xself).xmatch)) ("recursive") (((xself).xrecursive)) ("form_class") (((xforms).xFilePathField)) ("allow_files") (((xself).xallow_files)) ("allow_folders") (((xself).xallow_folders)) ((xkwargs)))))))))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("FilePathField"))
            (((unsupported)).apply ((xField)))
              seq
                xempty_strings_allowed.write FALSE
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("%(value)s value must be a float."))))
                xdescription.write (((x_)).apply ("Floating point number"))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((((unsupported)).apply ((xTypeError)) ((xValueError)))))
                          (((unsupported)).apply ((((xfloat)).apply ((xvalue)))))
                          (((unsupported)).apply (((((xe).x__class__)).apply (("Field '%s' expected a number but got %r.".mod (((unsupported)).apply (((xself).xname)) ((xvalue))))))) ((xe)))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("FloatField"))
                xto_python.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply ((((unsupported)).apply ((xTypeError)) ((xValueError)))))
                          (((unsupported)).apply ((((xfloat)).apply ((xvalue)))))
                          (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))) ("invalid") ((((unsupported)).apply ("value") ((xvalue)))))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xFloatField)) ((xkwargs)))))))))
            (((unsupported)).apply ((xField)))
              seq
                xempty_strings_allowed.write FALSE
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("%(value)s value must be an integer."))))
                xdescription.write (((x_)).apply ("Integer"))
                xcheck.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_max_length_warning)).apply)))))))
                x_check_max_length_warning.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xmax_length)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xWarning)) (("'max_length' is ignored when used with %s.".mod (((xself).x__class__).x__name__))) ("Remove 'max_length' from field") ((xself)) ("fields.W122"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                xvalidators.write
                  [xself]
                    memory > xinternal_type
                    memory > xvalidators_
                    seq > @
                      (((unsupported)).apply)
                        xvalidators_.write ((((xsuper)).apply).xvalidators)
                        xinternal_type.write ((((xself).xget_internal_type)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xmin_value)) ((xmax_value)))) ((((((xconnection).xops).xinteger_field_range)).apply ((xinternal_type)))))
                        ((((unsupported)).apply ((xmin_value)) ("None: is there a None literal in the EO language?")).and ((((xany)).apply ((((unsupported)).apply (((((xisinstance)).apply ((xvalidator)) (((xvalidators).xMinValueValidator))).and (((((xcallable)).apply (((xvalidator).xlimit_value))).if ((((xvalidator).xlimit_value)).apply) ((xvalidator).xlimit_value)).geq (xmin_value)))) ((xvalidator)) ((xvalidators_))))).not)).if
                          bogusForceDataize.write ((((xvalidators_).xappend)).apply (((((xvalidators).xMinValueValidator)).apply ((xmin_value)))))
                        ((((unsupported)).apply ((xmax_value)) ("None: is there a None literal in the EO language?")).and ((((xany)).apply ((((unsupported)).apply (((((xisinstance)).apply ((xvalidator)) (((xvalidators).xMaxValueValidator))).and (((((xcallable)).apply (((xvalidator).xlimit_value))).if ((((xvalidator).xlimit_value)).apply) ((xvalidator).xlimit_value)).leq (xmax_value)))) ((xvalidator)) ((xvalidators_))))).not)).if
                          bogusForceDataize.write ((((xvalidators_).xappend)).apply (((((xvalidators).xMaxValueValidator)).apply ((xmax_value)))))
                        (((unsupported)).apply ((xvalidators_)))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((((unsupported)).apply ((xTypeError)) ((xValueError)))))
                          (((unsupported)).apply ((((xint)).apply ((xvalue)))))
                          (((unsupported)).apply (((((xe).x__class__)).apply (("Field '%s' expected a number but got %r.".mod (((unsupported)).apply (((xself).xname)) ((xvalue))))))) ((xe)))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("IntegerField"))
                xto_python.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply ((((unsupported)).apply ((xTypeError)) ((xValueError)))))
                          (((unsupported)).apply ((((xint)).apply ((xvalue)))))
                          (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))) ("invalid") ((((unsupported)).apply ("value") ((xvalue)))))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xIntegerField)) ((xkwargs)))))))))
            (((unsupported)).apply ((xIntegerField)))
              seq
                xdescription.write (((x_)).apply ("Big (8 byte) integer"))
                xMAX_BIGINT.write (((unsupported)).apply)
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("BigIntegerField"))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("min_value") (((((xBigIntegerField).xMAX_BIGINT).neg).sub 1)) ("max_value") (((xBigIntegerField).xMAX_BIGINT)) ((xkwargs)))))))))
            (((unsupported)).apply ((xIntegerField)))
              seq
                xdescription.write (((x_)).apply ("Small integer"))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("SmallIntegerField"))
            (((unsupported)).apply ((xField)))
              seq
                xempty_strings_allowed.write FALSE
                xdescription.write (((x_)).apply ("IPv4 address"))
                xsystem_check_removed_details.write (((unsupported)).apply ("msg") ("IPAddressField has been removed except for support in historical migrations.") ("hint") ("Use GenericIPAddressField instead.") ("id") ("fields.E900"))
                x__init__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("max_length"))) (15))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("max_length"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((((xstr)).apply ((xvalue)))))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("IPAddressField"))
            (((unsupported)).apply ((xField)))
              seq
                xempty_strings_allowed.write FALSE
                xdescription.write (((x_)).apply ("IP address"))
                xdefault_error_messages.write (((unsupported)).apply)
                x__init__.write
                  [xself xverbose_name xname xprotocol xunpack_ipv4]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xunpack_ipv4)) ((xunpack_ipv4)))
                        (((unsupported)).apply (((xself).xprotocol)) ((xprotocol)))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xdefault_validators)) ((xinvalid_error_message)))) (((((xvalidators).xip_address_validators)).apply ((xprotocol)) ((xunpack_ipv4)))))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xdefault_error_messages)) ("invalid"))) ((xinvalid_error_message)))
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("max_length"))) (39))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xverbose_name)) ((xname)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                xcheck.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_blank_and_null_values)).apply ((((unsupported)).apply ((xkwargs)))))))))))
                x_check_blank_and_null_values.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((((xgetattr)).apply ((xself)) ("null") (FALSE)).not).and (((xgetattr)).apply ((xself)) ("blank") (FALSE))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("GenericIPAddressFields cannot have blank=True if null=False, as blank values are stored as nulls.") ((xself)) ("fields.E150"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply (((xself).xunpack_ipv4)) (FALSE)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("unpack_ipv4"))) (((xself).xunpack_ipv4)))
                        (((xself).xprotocol).neq "both").if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("protocol"))) (((xself).xprotocol)))
                        (((((xkwargs).xget)).apply ("max_length")).eq 39).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("max_length"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("GenericIPAddressField"))
                xto_python.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        ((((xisinstance)).apply ((xvalue)) ((xstr))).not).if
                          xvalue.write (((xstr)).apply ((xvalue)))
                        xvalue.write ((((xvalue).xstrip)).apply)
                        (((unsupported)).apply (":") ((xvalue))).if
                          (((unsupported)).apply ((((xclean_ipv6_address)).apply ((xvalue)) (((xself).xunpack_ipv4)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))))))
                        (((unsupported)).apply ((xvalue)))
                xget_db_prep_value.write
                  [xself xvalue xconnection xprepared]
                    seq > @
                      (((unsupported)).apply)
                        ((xprepared).not).if
                          xvalue.write ((((xself).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply ((((((xconnection).xops).xadapt_ipaddressfield_value)).apply ((xvalue)))))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        ((xvalue).and (((unsupported)).apply (":") ((xvalue)))).if
                          (((unsupported)).apply (((xexceptions).xValidationError)))
                            (((unsupported)).apply ((((xclean_ipv6_address)).apply ((xvalue)) (((xself).xunpack_ipv4)))))
                        (((unsupported)).apply ((((xstr)).apply ((xvalue)))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("protocol") (((xself).xprotocol)) ("form_class") (((xforms).xGenericIPAddressField)) ((xkwargs)))))))))
            (((unsupported)).apply ((xBooleanField)))
              seq
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("%(value)s value must be either None, True or False."))) ("invalid_nullable") ((((x_)).apply ("%(value)s value must be either None, True or False."))))
                xdescription.write (((x_)).apply ("Boolean (Either True, False or None)"))
                xsystem_check_removed_details.write (((unsupported)).apply ("msg") ("NullBooleanField is removed except for support in historical migrations.") ("hint") ("Use BooleanField(null=True) instead.") ("id") ("fields.E903"))
                x__init__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("null"))) (TRUE))
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("blank"))) (TRUE))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("null"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("blank"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
            (((unsupported)).apply)
              seq
                x__init_subclass__.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x__init_subclass__)).apply ((((unsupported)).apply ((xkwargs)))))
                        ((((xhasattr)).apply ((xcls)) ("integer_field_class")).not).if
                          (((unsupported)).apply (((xcls).xinteger_field_class)) ((((xnext)).apply ((((unsupported)).apply ((xparent)) ((xparent)) ((((unsupported)).apply (((xcls).x__mro__)) ((((unsupported)).apply (1))))) ((((xissubclass)).apply ((xparent)) ((xIntegerField)))))) ("None: is there a None literal in the EO language?"))))
                xrel_db_type.write
                  [xself xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xconnection).xfeatures).xrelated_fields_match_type).if
                          (((unsupported)).apply (((((xself).xdb_type)).apply ((xconnection)))))
                          (((unsupported)).apply ((((unsupported)).apply ((((((xself).xinteger_field_class)).apply).xdb_type)) ((xconnection)))))
            (((unsupported)).apply ((xPositiveIntegerRelDbTypeMixin)) ((xBigIntegerField)))
              seq
                xdescription.write (((x_)).apply ("Positive big integer"))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("PositiveBigIntegerField"))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("min_value") (0) ((xkwargs)))))))))
            (((unsupported)).apply ((xPositiveIntegerRelDbTypeMixin)) ((xIntegerField)))
              seq
                xdescription.write (((x_)).apply ("Positive integer"))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("PositiveIntegerField"))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("min_value") (0) ((xkwargs)))))))))
            (((unsupported)).apply ((xPositiveIntegerRelDbTypeMixin)) ((xSmallIntegerField)))
              seq
                xdescription.write (((x_)).apply ("Positive small integer"))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("PositiveSmallIntegerField"))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("min_value") (0) ((xkwargs)))))))))
            (((unsupported)).apply ((xCharField)))
              seq
                xdefault_validators.write (((unsupported)).apply (((xvalidators).xvalidate_slug)))
                xdescription.write (((x_)).apply ("Slug (up to %(max_length)s)"))
                x__init__.write
                  [xself xmax_length xdb_index xallow_unicode]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xallow_unicode)) ((xallow_unicode)))
                        ((xself).xallow_unicode).if
                          (((unsupported)).apply (((xself).xdefault_validators)) ((((unsupported)).apply (((xvalidators).xvalidate_unicode_slug)))))
                        (((unsupported)).apply (((((xsuper)).apply).x__init__)) ((((unsupported)).apply ((xargs)))) ((xmax_length)) ((xdb_index)) ((((unsupported)).apply ((xkwargs)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((((xkwargs).xget)).apply ("max_length")).eq 50).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("max_length"))))))
                        (((unsupported)).apply (((xself).xdb_index)) (FALSE)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("db_index"))) (FALSE))
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("db_index"))))))
                        (((unsupported)).apply (((xself).xallow_unicode)) (FALSE)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("allow_unicode"))) (((xself).xallow_unicode)))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("SlugField"))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xSlugField)) ("allow_unicode") (((xself).xallow_unicode)) ((xkwargs)))))))))
            (((unsupported)).apply ((xField)))
              seq
                xdescription.write (((x_)).apply ("Text"))
                x__init__.write
                  [xself xdb_collation]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((xself).xdb_collation)) ((xdb_collation)))
                xcheck.write
                  [xself]
                    memory > xdatabases
                    seq > @
                      (((unsupported)).apply)
                        xdatabases.write (((((xkwargs).xget)).apply ("databases")).or (((unsupported)).apply))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_db_collation)).apply ((xdatabases)))))))))
                x_check_db_collation.write
                  [xself xdatabases]
                    memory > xerrors
                    memory > xconnection
                    seq > @
                      seq
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xdb)) ((xdatabases)))
                          seq
                            (((((xrouter).xallow_migrate_model)).apply ((xdb)) (((xself).xmodel))).not).if
                              (((unsupported)).apply)
                            xconnection.write (((unsupported)).apply ((xconnections)) ((xdb)))
                            ((((((unsupported)).apply (((xself).xdb_collation)) ("None: is there a None literal in the EO language?")).or (((unsupported)).apply ("supports_collation_on_textfield") (((((xself).xmodel).x_meta).xrequired_db_features)))).or (((xconnection).xfeatures).xsupports_collation_on_textfield)).not).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("%s does not support a database collation on TextFields.".mod ((xconnection).xdisplay_name))) ((xself)) ("fields.E190"))))
                        (((unsupported)).apply ((xerrors)))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("TextField"))
                xto_python.write
                  [xself xvalue]
                    seq > @
                      seq
                        ((((xisinstance)).apply ((xvalue)) ((xstr))).or (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?"))).if
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply ((((xstr)).apply ((xvalue)))))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply (((((xself).xto_python)).apply ((xvalue)))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("max_length") (((xself).xmax_length)) (((((unsupported)).apply (((xself).xchoices)) ("None: is there a None literal in the EO language?")).if (((unsupported)).apply) (((unsupported)).apply ("widget") (((xforms).xTextarea))))) ((xkwargs)))))))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        ((xself).xdb_collation).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("db_collation"))) (((xself).xdb_collation)))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
            (((unsupported)).apply ((xDateTimeCheckMixin)) ((xField)))
              seq
                xempty_strings_allowed.write FALSE
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("%(value)s value has an invalid format. It must be in HH:MM[:ss[.uuuuuu]] format."))) ("invalid_time") ((((x_)).apply ("%(value)s value has the correct format (HH:MM[:ss[.uuuuuu]]) but it is an invalid time."))))
                xdescription.write (((x_)).apply ("Time"))
                x__init__.write
                  [xself xverbose_name xname xauto_now xauto_now_add]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xauto_now)) (((xself).xauto_now_add)))) ((((unsupported)).apply ((xauto_now)) ((xauto_now_add)))))
                        ((xauto_now).or (xauto_now_add)).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("editable"))) (FALSE))
                            (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("blank"))) (TRUE))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xverbose_name)) ((xname)) ((((unsupported)).apply ((xkwargs)))))
                x_check_fix_default_value.write
                  [xself]
                    memory > xvalue
                    memory > xnow
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((((xself).xhas_default)).apply).not).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xvalue.write ((xself).xdefault)
                        (((xisinstance)).apply ((xvalue)) (((xdatetime).xdatetime))).if
                          xnow.write "None: is there a None literal in the EO language?"
                          (((xisinstance)).apply ((xvalue)) (((xdatetime).xtime))).if
                            seq
                              xnow.write (((x_get_naive_now)).apply)
                              xvalue.write (((((xdatetime).xdatetime).xcombine)).apply (((((xnow).xdate)).apply)) ((xvalue)))
                            (((unsupported)).apply ((((unsupported)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).x_check_if_value_fixed)) ((xvalue)) ((xnow)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply (((xself).xauto_now)) (FALSE)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("auto_now"))) (((xself).xauto_now)))
                        (((unsupported)).apply (((xself).xauto_now_add)) (FALSE)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("auto_now_add"))) (((xself).xauto_now_add)))
                        (((xself).xauto_now).or ((xself).xauto_now_add)).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("blank"))))))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("editable"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("TimeField"))
                xto_python.write
                  [xself xvalue]
                    memory > xparsed
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((xisinstance)).apply ((xvalue)) (((xdatetime).xtime))).if
                          (((unsupported)).apply ((xvalue)))
                        (((xisinstance)).apply ((xvalue)) (((xdatetime).xdatetime))).if
                          (((unsupported)).apply (((((xvalue).xtime)).apply)))
                        (((unsupported)).apply ((xValueError)))
                          seq
                            xparsed.write (((xparse_time)).apply ((xvalue)))
                            (((unsupported)).apply ((xparsed)) ("None: is there a None literal in the EO language?")).if
                              (((unsupported)).apply ((xparsed)))
                          (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid_time"))) ("invalid_time") ((((unsupported)).apply ("value") ((xvalue)))))))
                        (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))) ("invalid") ((((unsupported)).apply ("value") ((xvalue)))))))
                xpre_save.write
                  [xself xmodel_instance xadd]
                    memory > xvalue
                    seq > @
                      (((xself).xauto_now).or (((xself).xauto_now_add).and (xadd))).if
                        seq
                          xvalue.write ((((((((xdatetime).xdatetime).xnow)).apply).xtime)).apply)
                          bogusForceDataize.write (((xsetattr)).apply ((xmodel_instance)) (((xself).xattname)) ((xvalue)))
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply (((((((xsuper)).apply).xpre_save)).apply ((xmodel_instance)) ((xadd)))))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply (((((xself).xto_python)).apply ((xvalue)))))
                xget_db_prep_value.write
                  [xself xvalue xconnection xprepared]
                    seq > @
                      (((unsupported)).apply)
                        ((xprepared).not).if
                          xvalue.write ((((xself).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply ((((((xconnection).xops).xadapt_timefield_value)).apply ((xvalue)))))
                xvalue_to_string.write
                  [xself xobj]
                    memory > xval
                    seq > @
                      seq
                        xval.write ((((xself).xvalue_from_object)).apply ((xobj)))
                        (((unsupported)).apply (((((unsupported)).apply ((xval)) ("None: is there a None literal in the EO language?")).if "" ((((xval).xisoformat)).apply))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xTimeField)) ((xkwargs)))))))))
            (((unsupported)).apply ((xCharField)))
              seq
                xdefault_validators.write (((unsupported)).apply (((((xvalidators).xURLValidator)).apply)))
                xdescription.write (((x_)).apply ("URL"))
                x__init__.write
                  [xself xverbose_name xname]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xkwargs).xsetdefault)).apply ("max_length") (200))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xverbose_name)) ((xname)) ((((unsupported)).apply ((xkwargs)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((((xkwargs).xget)).apply ("max_length")).eq 200).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("max_length"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xURLField)) ((xkwargs)))))))))
            (((unsupported)).apply ((xField)))
              seq
                xdescription.write (((x_)).apply ("Raw binary data"))
                xempty_values.write (((unsupported)).apply ("None: is there a None literal in the EO language?") (""))
                x__init__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xkwargs).xsetdefault)).apply ("editable") (FALSE))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((xself).xmax_length)) ("None: is there a None literal in the EO language?")).if
                          bogusForceDataize.write (((((xself).xvalidators).xappend)).apply (((((xvalidators).xMaxLengthValidator)).apply (((xself).xmax_length)))))
                xcheck.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_str_default_value)).apply)))))))
                x_check_str_default_value.write
                  [xself]
                    seq > @
                      seq
                        (((((xself).xhas_default)).apply).and (((xisinstance)).apply (((xself).xdefault)) ((xstr)))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("BinaryField's default cannot be a string. Use bytes content instead.") ((xself)) ("fields.E170"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        ((xself).xeditable).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("editable"))) (TRUE))
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("editable"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("BinaryField"))
                xget_placeholder.write
                  [xself xvalue xcompiler xconnection]
                    seq > @
                      (((unsupported)).apply ((((((xconnection).xops).xbinary_placeholder_sql)).apply ((xvalue)))))
                xget_default.write
                  [xself]
                    memory > xdefault
                    seq > @
                      seq
                        (((((xself).xhas_default)).apply).and ((((xcallable)).apply (((xself).xdefault))).not)).if
                          (((unsupported)).apply (((xself).xdefault)))
                        xdefault.write ((((((xsuper)).apply).xget_default)).apply)
                        ((xdefault).eq "").if
                          (((unsupported)).apply (""))
                        (((unsupported)).apply ((xdefault)))
                xget_db_prep_value.write
                  [xself xvalue xconnection xprepared]
                    seq > @
                      (((unsupported)).apply)
                        xvalue.write ((((((xsuper)).apply).xget_db_prep_value)).apply ((xvalue)) ((xconnection)) ((xprepared)))
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((((xconnection).xDatabase).xBinary)).apply ((xvalue)))))
                        (((unsupported)).apply ((xvalue)))
                xvalue_to_string.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((((((xb64encode)).apply (((((xself).xvalue_from_object)).apply ((xobj))))).xdecode)).apply ("ascii"))))
                xto_python.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((xisinstance)).apply ((xvalue)) ((xstr))).if
                          (((unsupported)).apply ((((xmemoryview)).apply ((((xb64decode)).apply (((((xvalue).xencode)).apply ("ascii"))))))))
                        (((unsupported)).apply ((xvalue)))
            (((unsupported)).apply ((xField)))
              seq
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("%(value)s is not a valid UUID."))))
                xdescription.write (((x_)).apply ("Universally unique identifier"))
                xempty_strings_allowed.write FALSE
                x__init__.write
                  [xself xverbose_name]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("max_length"))) (32))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xverbose_name)) ((((unsupported)).apply ((xkwargs)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("max_length"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("UUIDField"))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        xvalue.write ((((((xsuper)).apply).xget_prep_value)).apply ((xvalue)))
                        (((unsupported)).apply (((((xself).xto_python)).apply ((xvalue)))))
                xget_db_prep_value.write
                  [xself xvalue xconnection xprepared]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        ((((xisinstance)).apply ((xvalue)) (((xuuid).xUUID))).not).if
                          xvalue.write ((((xself).xto_python)).apply ((xvalue)))
                        (((xconnection).xfeatures).xhas_native_uuid_field).if
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply (((xvalue).xhex)))
                xto_python.write
                  [xself xvalue]
                    memory > xinput_form
                    seq > @
                      seq
                        ((((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).and ((((xisinstance)).apply ((xvalue)) (((xuuid).xUUID))).not)).if
                          seq
                            xinput_form.write ((((xisinstance)).apply ((xvalue)) ((xint))).if "int" "hex")
                            (((unsupported)).apply ((((unsupported)).apply ((xAttributeError)) ((xValueError)))))
                              (((unsupported)).apply (((((xuuid).xUUID)).apply ((((unsupported)).apply ((((unsupported)).apply ((xinput_form)) ((xvalue)))))))))
                              (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))) ("invalid") ((((unsupported)).apply ("value") ((xvalue)))))))
                        (((unsupported)).apply ((xvalue)))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xUUIDField)) ((xkwargs)))))))))
            (((unsupported)).apply)
              seq
                xdb_returning.write TRUE
                x__init__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("blank"))) (TRUE))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                xcheck.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_primary_key)).apply)))))))
                x_check_primary_key.write
                  [xself]
                    seq > @
                      (((xself).xprimary_key).not).if
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("AutoFields must set primary_key=True.") ((xself)) ("fields.E100"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("blank"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("primary_key"))) (TRUE))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xvalidate.write
                  [xself xvalue xmodel_instance]
                    seq > @
                xget_db_prep_value.write
                  [xself xvalue xconnection xprepared]
                    seq > @
                      (((unsupported)).apply)
                        ((xprepared).not).if
                          seq
                            xvalue.write ((((xself).xget_prep_value)).apply ((xvalue)))
                            xvalue.write (((((xconnection).xops).xvalidate_autopk_value)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)))
                xcontribute_to_class.write
                  [xself xcls xname]
                    seq > @
                      (((unsupported)).apply)
                        (((xcls).x_meta).xauto_field).if
                          (((unsupported)).apply ((((xValueError)).apply (("Model %s can't have more than one auto-generated field.".mod (((xcls).x_meta).xlabel))))))
                        bogusForceDataize.write ((((((xsuper)).apply).xcontribute_to_class)).apply ((xcls)) ((xname)) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply ((((xcls).x_meta).xauto_field)) ((xself)))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ("None: is there a None literal in the EO language?"))
            (((unsupported)).apply ((xtype)))
              seq
                (((unsupported)).apply)
                x_subclasses.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xBigAutoField)) ((xSmallAutoField)))))
                x__instancecheck__.write
                  [xself xinstance]
                    seq > @
                      (((unsupported)).apply (((((xisinstance)).apply ((xinstance)) (((xself).x_subclasses))).or ((((((xsuper)).apply).x__instancecheck__)).apply ((xinstance))))))
                x__subclasscheck__.write
                  [xself xsubclass]
                    seq > @
                      (((unsupported)).apply (((((xissubclass)).apply ((xsubclass)) (((xself).x_subclasses))).or ((((((xsuper)).apply).x__subclasscheck__)).apply ((xsubclass))))))
            (((unsupported)).apply ((xAutoFieldMixin)) ((xIntegerField)) ((xAutoFieldMeta)))
              seq
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("AutoField"))
                xrel_db_type.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply (((((xIntegerField)).apply).xdb_type)) ((xconnection)))))
            (((unsupported)).apply ((xAutoFieldMixin)) ((xBigIntegerField)))
              seq
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("BigAutoField"))
                xrel_db_type.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply (((((xBigIntegerField)).apply).xdb_type)) ((xconnection)))))
            (((unsupported)).apply ((xAutoFieldMixin)) ((xSmallIntegerField)))
              seq
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("SmallAutoField"))
                xrel_db_type.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply (((((xSmallIntegerField)).apply).xdb_type)) ((xconnection)))))