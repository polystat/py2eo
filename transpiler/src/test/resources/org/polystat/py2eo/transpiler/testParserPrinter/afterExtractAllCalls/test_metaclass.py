xdoctests = "\n\nBasic class construction.\n\n    >>> class C:\n    ...     def meth(self): print(\"Hello\")\n    ...\n    >>> C.__class__ is type\n    True\n    >>> a = C()\n    >>> a.__class__ is C\n    True\n    >>> a.meth()\n    Hello\n    >>>\n\nUse *args notation for the bases.\n\n    >>> class A: pass\n    >>> class B: pass\n    >>> bases = (A, B)\n    >>> class C(*bases): pass\n    >>> C.__bases__ == bases\n    True\n    >>>\n\nUse a trivial metaclass.\n\n    >>> class M(type):\n    ...     pass\n    ...\n    >>> class C(metaclass=M):\n    ...    def meth(self): print(\"Hello\")\n    ...\n    >>> C.__class__ is M\n    True\n    >>> a = C()\n    >>> a.__class__ is C\n    True\n    >>> a.meth()\n    Hello\n    >>>\n\nUse **kwds notation for the metaclass keyword.\n\n    >>> kwds = {'metaclass': M}\n    >>> class C(**kwds): pass\n    ...\n    >>> C.__class__ is M\n    True\n    >>> a = C()\n    >>> a.__class__ is C\n    True\n    >>>\n\nUse a metaclass with a __prepare__ static method.\n\n    >>> class M(type):\n    ...    @staticmethod\n    ...    def __prepare__(*args, **kwds):\n    ...        print(\"Prepare called:\", args, kwds)\n    ...        return dict()\n    ...    def __new__(cls, name, bases, namespace, **kwds):\n    ...        print(\"New called:\", kwds)\n    ...        return type.__new__(cls, name, bases, namespace)\n    ...    def __init__(cls, *args, **kwds):\n    ...        pass\n    ...\n    >>> class C(metaclass=M):\n    ...     def meth(self): print(\"Hello\")\n    ...\n    Prepare called: ('C', ()) {}\n    New called: {}\n    >>>\n\nAlso pass another keyword.\n\n    >>> class C(object, metaclass=M, other=\"haha\"):\n    ...     pass\n    ...\n    Prepare called: ('C', (<class 'object'>,)) {'other': 'haha'}\n    New called: {'other': 'haha'}\n    >>> C.__class__ is M\n    True\n    >>> C.__bases__ == (object,)\n    True\n    >>> a = C()\n    >>> a.__class__ is C\n    True\n    >>>\n\nCheck that build_class doesn't mutate the kwds dict.\n\n    >>> kwds = {'metaclass': type}\n    >>> class C(**kwds): pass\n    ...\n    >>> kwds == {'metaclass': type}\n    True\n    >>>\n\nUse various combinations of explicit keywords and **kwds.\n\n    >>> bases = (object,)\n    >>> kwds = {'metaclass': M, 'other': 'haha'}\n    >>> class C(*bases, **kwds): pass\n    ...\n    Prepare called: ('C', (<class 'object'>,)) {'other': 'haha'}\n    New called: {'other': 'haha'}\n    >>> C.__class__ is M\n    True\n    >>> C.__bases__ == (object,)\n    True\n    >>> class B: pass\n    >>> kwds = {'other': 'haha'}\n    >>> class C(B, metaclass=M, *bases, **kwds): pass\n    ...\n    Prepare called: ('C', (<class 'test.test_metaclass.B'>, <class 'object'>)) {'other': 'haha'}\n    New called: {'other': 'haha'}\n    >>> C.__class__ is M\n    True\n    >>> C.__bases__ == (B, object)\n    True\n    >>>\n\nCheck for duplicate keywords.\n\n    >>> class C(metaclass=type, metaclass=type): pass\n    ...\n    Traceback (most recent call last):\n    [...]\n    SyntaxError: keyword argument repeated\n    >>>\n\nAnother way.\n\n    >>> kwds = {'metaclass': type}\n    >>> class C(metaclass=type, **kwds): pass\n    ...\n    Traceback (most recent call last):\n    [...]\n    TypeError: __build_class__() got multiple values for keyword argument 'metaclass'\n    >>>\n\nUse a __prepare__ method that returns an instrumented dict.\n\n    >>> class LoggingDict(dict):\n    ...     def __setitem__(self, key, value):\n    ...         print(\"d[%r] = %r\" % (key, value))\n    ...         dict.__setitem__(self, key, value)\n    ...\n    >>> class Meta(type):\n    ...    @staticmethod\n    ...    def __prepare__(name, bases):\n    ...        return LoggingDict()\n    ...\n    >>> class C(metaclass=Meta):\n    ...     foo = 2+2\n    ...     foo = 42\n    ...     bar = 123\n    ...\n    d['__module__'] = 'test.test_metaclass'\n    d['__qualname__'] = 'C'\n    d['foo'] = 4\n    d['foo'] = 42\n    d['bar'] = 123\n    >>>\n\nUse a metaclass that doesn't derive from type.\n\n    >>> def meta(name, bases, namespace, **kwds):\n    ...     print(\"meta:\", name, bases)\n    ...     print(\"ns:\", sorted(namespace.items()))\n    ...     print(\"kw:\", sorted(kwds.items()))\n    ...     return namespace\n    ...\n    >>> class C(metaclass=meta):\n    ...     a = 42\n    ...     b = 24\n    ...\n    meta: C ()\n    ns: [('__module__', 'test.test_metaclass'), ('__qualname__', 'C'), ('a', 42), ('b', 24)]\n    kw: []\n    >>> type(C) is dict\n    True\n    >>> print(sorted(C.items()))\n    [('__module__', 'test.test_metaclass'), ('__qualname__', 'C'), ('a', 42), ('b', 24)]\n    >>>\n\nAnd again, with a __prepare__ attribute.\n\n    >>> def prepare(name, bases, **kwds):\n    ...     print(\"prepare:\", name, bases, sorted(kwds.items()))\n    ...     return LoggingDict()\n    ...\n    >>> meta.__prepare__ = prepare\n    >>> class C(metaclass=meta, other=\"booh\"):\n    ...    a = 1\n    ...    a = 2\n    ...    b = 3\n    ...\n    prepare: C () [('other', 'booh')]\n    d['__module__'] = 'test.test_metaclass'\n    d['__qualname__'] = 'C'\n    d['a'] = 1\n    d['a'] = 2\n    d['b'] = 3\n    meta: C ()\n    ns: [('__module__', 'test.test_metaclass'), ('__qualname__', 'C'), ('a', 2), ('b', 3)]\n    kw: [('other', 'booh')]\n    >>>\n\nThe default metaclass must define a __prepare__() method.\n\n    >>> type.__prepare__()\n    {}\n    >>>\n\nMake sure it works with subclassing.\n\n    >>> class M(type):\n    ...     @classmethod\n    ...     def __prepare__(cls, *args, **kwds):\n    ...         d = super().__prepare__(*args, **kwds)\n    ...         d[\"hello\"] = 42\n    ...         return d\n    ...\n    >>> class C(metaclass=M):\n    ...     print(hello)\n    ...\n    42\n    >>> print(C.hello)\n    42\n    >>>\n\nTest failures in looking up the __prepare__ method work.\n    >>> class ObscureException(Exception):\n    ...     pass\n    >>> class FailDescr:\n    ...     def __get__(self, instance, owner):\n    ...        raise ObscureException\n    >>> class Meta(type):\n    ...     __prepare__ = FailDescr()\n    >>> class X(metaclass=Meta):\n    ...     pass\n    Traceback (most recent call last):\n    [...]\n    test.test_metaclass.ObscureException\n\n" # 1:0-1:5948
import xsys # 251:7-251:9
e0 = xhasattr(xsys, "gettrace") # 254:3-254:26
if (e0): # 254:32-254:45 
    e1 = xsys.xgettrace # 254:32-254:43
    e2 = e1() # 254:32-254:45
else: # 254:32-254:45
    lhs1 = False # 254:32-254:45
    e2 = lhs1 # 254:32-254:45
if (e2): # 254:47-256:-1 
    x__test__ = {} # 255:4-255:16
else: # 256:5-259:-1
    x__test__ = {"doctests" : xdoctests} # 257:4-257:37
def xtest_main(xverbose = False): # 259:0-264:-1
    from xtest import xsupport # 260:21-260:27
    from xtest import xtest_metaclass # 261:21-261:34
    e3 = xsupport.xrun_doctest # 262:4-262:22
    lhs2 = xtest_metaclass # 262:24-262:37
    lhs3 = xverbose # 262:40-262:46
    e4 = e3(lhs2, lhs3) # 262:4-262:47
e6 = (x__name__ == "__main__") # 264:3-264:24
if (e6): # 264:26-266:-1 
    e5 = xtest_main(xverbose=True) # 265:4-265:26
else: # 264:0-266:-1
    pass # 264:0-266:-1