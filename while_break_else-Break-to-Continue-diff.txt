Diff between original (left) and mutated (right) python files
1c1
< def while_break_else(): # 1:0-12:107
---
> def while_continue_else(): # 1:0-12:107
7c7
<             break # 7:12-7:16
---
>             continue # 7:12-7:16

Diff between original (left) and mutated (right) eo files
2,8d1
< +alias goto org.eolang.gray.goto
< +alias stdout org.eolang.io.stdout
< +alias sprintf org.eolang.txt.sprintf
< +alias cage org.eolang.gray.cage
< +alias pyint preface.pyint
< +alias pystring preface.pystring
< +alias pybool preface.pybool
10,261c3,30
< 
< [unused] > while_break_else
<   [] > apply
<     [stackUp] > @
<       [x] > mkCopy
<         x' > copy
<         copy.< > @
<       [] > newUID
<         memory > cur
<         [unused] > apply
<           seq > @
<             cur.write (cur.is-empty.if (5) (cur.add (1)))
<             (pyint cur)
<       [] > raiseEmpty
<         [] > xclass
<           (pyint 4) > xid
<       [res] > return
<         res > result
<         [] > xclass
<           (pyint 3) > xid
<       [] > break
<         [] > xclass
<           (pyint 2) > xid
<       [] > continue
<         [] > xclass
<           (pyint 1) > xid
<       [] > raiseNothing
<         [] > xclass
<           (pyint 0) > xid
<       [id] > is-exception
<         id.greater (pyint 3) > @
<       [id] > is-break-continue-return
<         (id.greater (pyint 0)).and (id.less (pyint 4)) > @
<       cage > xcurrent-exception
<       cage > xcaught
<       pyint 0 > dummy-int-usage
<       pybool TRUE > dummy-bool-usage
<       pystring (sprintf "") > dummy-bool-string
<       [] > xmyArray
<         [initValue] > apply
<           [stackUp] > @
<             cage > pResult
<             [] > result
<               cage > value
<               [] > xlength
<                 [self] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (pyint (self.value.length)))
<                       123
<               [] > xget
<                 [self i] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (self.value.get i))
<                       123
<               [] > xappend
<                 [self x] > apply
<                   [stackUp] > @
<                     seq > @
<                       mkCopy (self.value) > tmp
<                       self.value.write (tmp.copy.append x)
<                       stackUp.forward (return 0)
<             seq > @
<               result.value.write initValue
<               pResult.write result
<               stackUp.forward (return pResult)
<       cage > tmp
<       cage > toReturn
<       cage > assertMe
<       cage > xwhile_break_else
<       seq > @
<         stdout "while_break_else\n"
<         write.
<           xwhile_break_else
<           []
<             [] > apply
<               [stackUp] > @
<                 cage > tmp
<                 cage > toReturn
<                 cage > xn
<                 cage > e12
<                 cage > e1
<                 cage > lhs14
<                 cage > lhs17
<                 cage > e0
<                 cage > lhs10
<                 cage > lhs13
<                 cage > e8
<                 cage > xres
<                 cage > e14
<                 cage > lhs12
<                 cage > e15
<                 cage > e6
<                 cage > lhs0
<                 cage > lhs4
<                 cage > e5
<                 cage > lhs1
<                 cage > e7
<                 cage > e4
<                 cage > e13
<                 cage > e3
<                 cage > lhs6
<                 cage > e10
<                 cage > doElse0
<                 cage > lhs3
<                 cage > e9
<                 cage > e2
<                 cage > lhs7
<                 cage > e11
<                 seq > @
<                   stdout "xwhile_break_else\n"
<                   (xn).write ((pyint 5))
<                   (xn).force
<                   tmp.write (goto ((((xmyArray)).apply ((*))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e0).write (tmp.result)
<                   ((e0).<)
<                   mkCopy (e0) > tmp1
<                   (xres).write (tmp1.copy)
<                   (doElse0).write ((pybool FALSE))
<                   (doElse0).force
<                   write.
<                     xcurrent-exception
<                     goto
<                       [stackUp]
<                         seq > @
<                           (pybool TRUE).while
<                             [unused]
<                               seq > @
<                                 (e7).write (((xn).greater (pyint 0)))
<                                 (e7).force
<                                 ((e7).<)
<                                 ((e7).not).if
<                                   seq
<                                     (doElse0).write ((pybool TRUE))
<                                     (doElse0).force
<                                     stackUp.forward break
<                                     (pybool TRUE)
<                                   seq
<                                     (pybool TRUE)
<                                 (e1).write (((xn).sub (pyint 1)))
<                                 (e1).force
<                                 ((e1).<)
<                                 mkCopy (e1) > tmp2
<                                 (xn).write (tmp2.copy)
<                                 (e2).write (((xn).eq (pyint 2)))
<                                 (e2).force
<                                 ((e2).<)
<                                 (e2).if
<                                   seq
<                                     stackUp.forward break
<                                     (pybool TRUE)
<                                   seq
<                                     (pybool TRUE)
<                                 mkCopy (xres.xappend) > tmp3
<                                 (e3).write (tmp3.copy)
<                                 ((e3).<)
<                                 mkCopy (xres) > tmp4
<                                 (lhs0).write (tmp4.copy)
<                                 mkCopy (xn) > tmp5
<                                 (lhs1).write (tmp5.copy)
<                                 tmp.write (goto ((((e3)).apply ((lhs0)) ((lhs1))).@))
<                                 (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                 (e4).write (tmp.result)
<                                 ((e4).<)
<                                 (pybool TRUE)
<                           stackUp.forward raiseNothing
<                   if.
<                     xcurrent-exception.xclass.xid.neq (break.xclass.xid)
<                     stackUp.forward xcurrent-exception
<                     0
<                   (doElse0).if
<                     seq
<                       mkCopy (xres.xappend) > tmp6
<                       (e5).write (tmp6.copy)
<                       ((e5).<)
<                       mkCopy (xres) > tmp7
<                       (lhs3).write (tmp7.copy)
<                       (lhs4).write ((pyint 6))
<                       (lhs4).force
<                       tmp.write (goto ((((e5)).apply ((lhs3)) ((lhs4))).@))
<                       (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                       (e6).write (tmp.result)
<                       ((e6).<)
<                       (pybool TRUE)
<                     seq
<                       (pybool TRUE)
<                   mkCopy (xres.x__contains__) > tmp8
<                   (e8).write (tmp8.copy)
<                   ((e8).<)
<                   mkCopy (xres) > tmp9
<                   (lhs6).write (tmp9.copy)
<                   (lhs7).write ((pyint 6))
<                   (lhs7).force
<                   tmp.write (goto ((((e8)).apply ((lhs6)) ((lhs7))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e9).write (tmp.result)
<                   ((e9).<)
<                   (e10).write (((e9).not))
<                   (e10).force
<                   ((e10).<)
<                   (e10).if
<                     seq
<                       mkCopy (xres) > tmp10
<                       (lhs10).write (tmp10.copy)
<                       tmp.write (goto ((((xmyArray)).apply ((* (pyint 4) (pyint 3)))).@))
<                       (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                       (e11).write (tmp.result)
<                       ((e11).<)
<                       (e12).write (((lhs10).eq (e11)))
<                       (e12).force
<                       ((e12).<)
<                       (pybool TRUE)
<                     seq
<                       (lhs12).write ((pybool FALSE))
<                       (lhs12).force
<                       mkCopy (lhs12) > tmp11
<                       (e12).write (tmp11.copy)
<                       (pybool TRUE)
<                   (e12).if
<                     seq
<                       mkCopy (xres.x__contains__) > tmp12
<                       (e13).write (tmp12.copy)
<                       ((e13).<)
<                       mkCopy (xres) > tmp13
<                       (lhs13).write (tmp13.copy)
<                       (lhs14).write ((pyint 2))
<                       (lhs14).force
<                       tmp.write (goto ((((e13)).apply ((lhs13)) ((lhs14))).@))
<                       (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                       (e14).write (tmp.result)
<                       ((e14).<)
<                       (e15).write (((e14).not))
<                       (e15).force
<                       ((e15).<)
<                       (pybool TRUE)
<                     seq
<                       (lhs17).write ((pybool FALSE))
<                       (lhs17).force
<                       mkCopy (lhs17) > tmp14
<                       (e15).write (tmp14.copy)
<                       (pybool TRUE)
<                   toReturn.write ((e15))
<                   stackUp.forward (return toReturn)
<                   123
<         tmp.write (goto ((((xwhile_break_else)).apply).@))
<         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<         (assertMe).write (tmp.result)
<         toReturn.write ((assertMe))
<         stackUp.forward (return toReturn)
<   (goto (apply.@)).result > @
\ No newline at end of file
---
> memory > xmyArray
> [] > while_break_else
>   [args...] > unsupported
>   [args...] > xunsupported
>   memory > bogusForceDataize
>   memory > xbogusForceDataize
>   memory > xhack
>   seq > @
>     xhack.write
>       []
>         memory > xwhile_continue_else
>         seq > @
>           xwhile_continue_else.write
>             []
>               memory > xn
>               memory > xres
>               seq > @
>                 seq
>                   xn.write (pyint 5)
>                   xres.write (((xmyArray)).apply ((((unsupported)).apply)))
>                   (((unsupported)).apply (((xn).greater (pyint 0))))
>                     seq
>                       xn.write ((xn).sub (pyint 1))
>                       ((xn).eq (pyint 2)).if
>                         (((unsupported)).apply)
>                       bogusForceDataize.write ((((xres).xappend)).apply ((xn)))
>                     bogusForceDataize.write ((((xres).xappend)).apply ((pyint 6)))
>                   (((unsupported)).apply ((((((((xres).x__contains__)).apply ((pyint 6))).not).and ((xres).eq (((xmyArray)).apply ((((unsupported)).apply ((pyint 4)) ((pyint 3))))))).and (((((xres).x__contains__)).apply ((pyint 2))).not))))
\ No newline at end of file