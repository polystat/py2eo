Diff between original (left) and mutated (right) python files
1c1
< def for_try_break(): # 1:0-13:46
---
> def for_try_continue(): # 1:0-13:46
10c10
<             break # 10:12-10:16
---
>             continue # 10:12-10:16

Diff between original (left) and mutated (right) eo files
2,8d1
< +alias goto org.eolang.gray.goto
< +alias stdout org.eolang.io.stdout
< +alias sprintf org.eolang.txt.sprintf
< +alias cage org.eolang.gray.cage
< +alias pyint preface.pyint
< +alias pystring preface.pystring
< +alias pybool preface.pybool
10,238c3,28
< 
< [unused] > for_try_break
<   [] > apply
<     [stackUp] > @
<       [x] > mkCopy
<         x' > copy
<         copy.< > @
<       [] > newUID
<         memory > cur
<         [unused] > apply
<           seq > @
<             cur.write (cur.is-empty.if (5) (cur.add (1)))
<             (pyint cur)
<       [] > raiseEmpty
<         [] > xclass
<           (pyint 4) > xid
<       [res] > return
<         res > result
<         [] > xclass
<           (pyint 3) > xid
<       [] > break
<         [] > xclass
<           (pyint 2) > xid
<       [] > continue
<         [] > xclass
<           (pyint 1) > xid
<       [] > raiseNothing
<         [] > xclass
<           (pyint 0) > xid
<       [id] > is-exception
<         id.greater (pyint 3) > @
<       [id] > is-break-continue-return
<         (id.greater (pyint 0)).and (id.less (pyint 4)) > @
<       cage > xcurrent-exception
<       cage > xcaught
<       pyint 0 > dummy-int-usage
<       pybool TRUE > dummy-bool-usage
<       pystring (sprintf "") > dummy-bool-string
<       [] > xmyArray
<         [initValue] > apply
<           [stackUp] > @
<             cage > pResult
<             [] > result
<               cage > value
<               [] > xlength
<                 [self] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (pyint (self.value.length)))
<                       123
<               [] > xget
<                 [self i] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (self.value.get i))
<                       123
<               [] > xappend
<                 [self x] > apply
<                   [stackUp] > @
<                     seq > @
<                       mkCopy (self.value) > tmp
<                       self.value.write (tmp.copy.append x)
<                       stackUp.forward (return 0)
<             seq > @
<               result.value.write initValue
<               pResult.write result
<               stackUp.forward (return pResult)
<       cage > tmp
<       cage > toReturn
<       cage > assertMe
<       cage > xfor_try_break
<       seq > @
<         stdout "for_try_break\n"
<         write.
<           xfor_try_break
<           []
<             [] > apply
<               [stackUp] > @
<                 cage > tmp
<                 cage > toReturn
<                 cage > e12
<                 cage > e1
<                 cage > e17
<                 cage > e0
<                 cage > xres
<                 cage > e3
<                 cage > e10
<                 cage > lhs11
<                 cage > xcaught
<                 cage > e9
<                 cage > e15
<                 cage > e19
<                 cage > e6
<                 cage > e18
<                 cage > lhs0
<                 cage > lhs4
<                 cage > e5
<                 cage > e7
<                 cage > xnum
<                 cage > lhs5
<                 cage > e4
<                 cage > xresult
<                 cage > xarr
<                 cage > e13
<                 cage > e8
<                 cage > e16
<                 cage > lhs2
<                 cage > e14
<                 cage > xit0
<                 cage > e2
<                 cage > e11
<                 seq > @
<                   stdout "xfor_try_break\n"
<                   tmp.write (goto ((((xmyArray)).apply ((*))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e0).write (tmp.result)
<                   ((e0).<)
<                   mkCopy (e0) > tmp1
<                   (xres).write (tmp1.copy)
<                   tmp.write (goto ((((xmyArray)).apply ((* (pyint 1) (pyint 2) (pyint 4) (pyint 0) (pyint 8)))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e1).write (tmp.result)
<                   ((e1).<)
<                   mkCopy (e1) > tmp2
<                   (xarr).write (tmp2.copy)
<                   mkCopy (xarr.x__iter__) > tmp3
<                   (e2).write (tmp3.copy)
<                   ((e2).<)
<                   mkCopy (xarr) > tmp4
<                   (lhs0).write (tmp4.copy)
<                   tmp.write (goto ((((e2)).apply ((lhs0))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e3).write (tmp.result)
<                   ((e3).<)
<                   mkCopy (e3) > tmp5
<                   (xit0).write (tmp5.copy)
<                   (xcaught).write ((pybool FALSE))
<                   (xcaught).force
<                   xcaught.write (pybool TRUE)
<                   write.
<                     xcurrent-exception
<                     goto
<                       [stackUp]
<                         seq > @
<                           write.
<                             xcurrent-exception
<                             goto
<                               [stackUp]
<                                 seq > @
<                                   (pybool TRUE).while
<                                     [unused]
<                                       seq > @
<                                         mkCopy (xit0.x__next__) > tmp6
<                                         (e4).write (tmp6.copy)
<                                         ((e4).<)
<                                         mkCopy (xit0) > tmp7
<                                         (lhs2).write (tmp7.copy)
<                                         tmp.write (goto ((((e4)).apply ((lhs2))).@))
<                                         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                         (e5).write (tmp.result)
<                                         ((e5).<)
<                                         mkCopy (e5) > tmp8
<                                         (xnum).write (tmp8.copy)
<                                         (xcaught).write ((pybool FALSE))
<                                         (xcaught).force
<                                         xcaught.write (pybool TRUE)
<                                         write.
<                                           xcurrent-exception
<                                           goto
<                                             [stackUp]
<                                               seq > @
<                                                 (e6).write (((pyint 16).div (xnum)))
<                                                 (e6).force
<                                                 ((e6).<)
<                                                 mkCopy (e6) > tmp9
<                                                 (xresult).write (tmp9.copy)
<                                                 mkCopy (xres.xappend) > tmp10
<                                                 (e7).write (tmp10.copy)
<                                                 ((e7).<)
<                                                 mkCopy (xres) > tmp11
<                                                 (lhs4).write (tmp11.copy)
<                                                 mkCopy (xresult) > tmp12
<                                                 (lhs5).write (tmp12.copy)
<                                                 tmp.write (goto ((((e7)).apply ((lhs4)) ((lhs5))).@))
<                                                 (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                                 (e8).write (tmp.result)
<                                                 ((e8).<)
<                                                 stackUp.forward raiseNothing
<                                         seq
<                                           if.
<                                             is-exception (xcurrent-exception.xclass.xid)
<                                             seq
<                                               mkCopy (xcurrent-exception.xclass) > tmp13
<                                               (e10).write (tmp13.copy)
<                                               ((e10).<)
<                                               mkCopy (e10.xid) > tmp14
<                                               (e11).write (tmp14.copy)
<                                               ((e11).<)
<                                               mkCopy (xZeroDivisionError.xid) > tmp15
<                                               (e12).write (tmp15.copy)
<                                               ((e12).<)
<                                               (e13).write (((e11).eq (e12)))
<                                               (e13).force
<                                               ((e13).<)
<                                               (e13).if
<                                                 seq
<                                                   stdout (sprintf "%s\n" ((pystring "Sorry ! You are dividing by zero ").as-string))
<                                                   ((e9).<)
<                                                   stackUp.forward break
<                                                   (xcaught).write ((pybool TRUE))
<                                                   (xcaught).force
<                                                   (pybool TRUE)
<                                                 seq
<                                                   (pybool TRUE)
<                                               0
<                                             0
<                                           if.
<                                             xcurrent-exception.xclass.xid.eq (raiseNothing.xclass.xid)
<                                             seq
<                                               0
<                                             0
<                                           ((is-break-continue-return (xcurrent-exception.xclass.xid)).or ((is-exception (xcurrent-exception.xclass.xid)).and (xcaught.not))).if (stackUp.forward xcurrent-exception) 0
<                                         (pybool TRUE)
<                                   stackUp.forward raiseNothing
<                           if.
<                             xcurrent-exception.xclass.xid.neq (break.xclass.xid)
<                             stackUp.forward xcurrent-exception
<                             0
<                           stackUp.forward raiseNothing
---
> memory > xZeroDivisionError
> memory > xStopIteration
> memory > xprint
> memory > xmyArray
> [] > for_try_break
>   [args...] > unsupported
>   [args...] > xunsupported
>   memory > bogusForceDataize
>   memory > xbogusForceDataize
>   memory > xhack
>   seq > @
>     xhack.write
>       []
>         memory > xfor_try_continue
>         seq > @
>           xfor_try_continue.write
>             []
>               memory > xnum
>               memory > xit0
>               memory > xres
>               memory > xresult
>               memory > xarr
>               seq > @
>                 seq
>                   xres.write (((xmyArray)).apply ((((unsupported)).apply)))
>                   xarr.write (((xmyArray)).apply ((((unsupported)).apply ((pyint 1)) ((pyint 2)) ((pyint 4)) ((pyint 0)) ((pyint 8)))))
240,287c30,45
<                     if.
<                       is-exception (xcurrent-exception.xclass.xid)
<                       seq
<                         mkCopy (xcurrent-exception.xclass) > tmp16
<                         (e14).write (tmp16.copy)
<                         ((e14).<)
<                         mkCopy (e14.xid) > tmp17
<                         (e15).write (tmp17.copy)
<                         ((e15).<)
<                         mkCopy (xStopIteration.xid) > tmp18
<                         (e16).write (tmp18.copy)
<                         ((e16).<)
<                         (e17).write (((e15).eq (e16)))
<                         (e17).force
<                         ((e17).<)
<                         (e17).if
<                           seq
<                             (xcaught).write ((pybool TRUE))
<                             (xcaught).force
<                             (pybool TRUE)
<                           seq
<                             (pybool TRUE)
<                         0
<                       0
<                     if.
<                       xcurrent-exception.xclass.xid.eq (raiseNothing.xclass.xid)
<                       seq
<                         0
<                       0
<                     ((is-break-continue-return (xcurrent-exception.xclass.xid)).or ((is-exception (xcurrent-exception.xclass.xid)).and (xcaught.not))).if (stackUp.forward xcurrent-exception) 0
<                   mkCopy (xres) > tmp19
<                   (lhs11).write (tmp19.copy)
<                   tmp.write (goto ((((xmyArray)).apply ((* (pyint 16) (pyint 8) (pyint 4)))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e18).write (tmp.result)
<                   ((e18).<)
<                   (e19).write (((lhs11).eq (e18)))
<                   (e19).force
<                   ((e19).<)
<                   toReturn.write ((e19))
<                   stackUp.forward (return toReturn)
<                   123
<         tmp.write (goto ((((xfor_try_break)).apply).@))
<         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<         (assertMe).write (tmp.result)
<         toReturn.write ((assertMe))
<         stackUp.forward (return toReturn)
<   (goto (apply.@)).result > @
\ No newline at end of file
---
>                     xit0.write ((((xarr).x__iter__)).apply)
>                     (((unsupported)).apply ((xStopIteration)))
>                       while.
>                         (pybool TRUE)
>                         [unused]
>                           seq > @
>                             seq
>                               xnum.write ((((xit0).x__next__)).apply)
>                               (((unsupported)).apply ((xZeroDivisionError)))
>                                 seq
>                                   xresult.write ((pyint 16).div (xnum))
>                                   bogusForceDataize.write ((((xres).xappend)).apply ((xresult)))
>                                 seq
>                                   bogusForceDataize.write (((xprint)).apply ((pystring "Sorry ! You are dividing by zero ")))
>                                   (((unsupported)).apply)
>                   (((unsupported)).apply (((xres).eq (((xmyArray)).apply ((((unsupported)).apply ((pyint 16)) ((pyint 8)) ((pyint 4))))))))
\ No newline at end of file