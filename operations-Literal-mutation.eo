memory > xtimezone
memory > xdecimal
memory > xstr
memory > xforce_str
memory > xNotImplementedError
memory > xlhs_sql
memory > xend_
memory > xsql
memory > xoffset
memory > xk
memory > xstatement
memory > xlimit
memory > xlhs_params
memory > xrhs_params
memory > xdatetime
memory > xlist
memory > xrhs_sql
memory > xValueError
memory > ximport_module
memory > xsettings
memory > xint
memory > xhasattr
memory > xstart_
memory > xcursor
memory > xNotSupportedError
memory > xsqlparse
memory > xtuple
memory > xsorted
memory > xutils
memory > xval
memory > xgetattr
memory > xv
memory > xoptions
memory > xabs
memory > xisinstance
memory > xtransaction
memory > xlen
[] > operations
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xexplain_prefix
        memory > xadapt_decimalfield_value
        memory > xdistinct_sql
        memory > xprep_for_iexact_query
        memory > xwindow_frame_rows_start_end
        memory > xadapt_datefield_value
        memory > xcompiler
        memory > xdatetime_trunc_sql
        memory > xcombine_duration_expression
        memory > xbulk_batch_size
        memory > xdatetime_cast_time_sql
        memory > xend_transaction_sql
        memory > xexplain_query_prefix
        memory > xadapt_datetimefield_value
        memory > xUNBOUNDED_PRECEDING
        memory > xmax_in_list_size
        memory > xsavepoint_commit_sql
        memory > xvalidate_autopk_value
        memory > xreturn_insert_columns
        memory > xpk_default_value
        memory > xconditional_expression_supported_in_where_clause
        memory > xfetch_returned_insert_columns
        memory > xtime_extract_sql
        memory > xprocess_clob
        memory > xno_limit_value
        memory > xinsert_statement
        memory > xsubtract_temporals
        memory > xinteger_field_range
        memory > xfor_update_sql
        memory > xwindow_frame_end
        memory > xsequence_reset_by_name_sql
        memory > xdatetime_extract_sql
        memory > xget_db_converters
        memory > xfield_cast_sql
        memory > x_get_limit_offset_params
        memory > xcast_data_types
        memory > xcombine_expression
        memory > xlookup_cast
        memory > xunification_cast_sql
        memory > xcheck_expression_support
        memory > xprep_for_like_query
        memory > xset_time_zone_sql
        memory > xstart_transaction_sql
        memory > xCURRENT_ROW
        memory > xUNBOUNDED_FOLLOWING
        memory > xautoinc_sql
        memory > xcache_key_culling_sql
        memory > xadapt_unknown_value
        memory > xbinary_placeholder_sql
        memory > xyear_lookup_bounds_for_datetime_field
        memory > xexecute_sql_flush
        memory > xdeferrable_sql
        memory > xforce_no_ordering
        memory > xsql_flush
        memory > xlimit_offset_sql
        memory > xcompiler_module
        memory > xwindow_frame_start
        memory > xwindow_frame_range_start_end
        memory > xset_operators
        memory > xsavepoint_rollback_sql
        memory > xmodify_insert_params
        memory > xon_conflict_suffix_sql
        memory > xtime_trunc_sql
        memory > x__init__
        memory > xPRECEDING
        memory > xcast_char_field_without_max_length
        memory > xyear_lookup_bounds_for_date_field
        memory > xdate_trunc_sql
        memory > xquote_name
        memory > xFOLLOWING
        memory > xdatetime_cast_date_sql
        memory > xsavepoint_create_sql
        memory > xinteger_field_ranges
        memory > xformat_for_duration_arithmetic
        memory > xconvert_durationfield_value
        memory > xadapt_ipaddressfield_value
        memory > xprepare_sql_script
        memory > xdate_extract_sql
        memory > xmax_name_length
        memory > xtablespace_sql
        memory > xregex_lookup
        memory > xlast_insert_id
        memory > xlast_executed_query
        memory > xsequence_reset_sql
        memory > xadapt_timefield_value
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                xcompiler_module.write "django.db.models.sql.compiler"
                xinteger_field_ranges.write (((unsupported)).apply ("SmallIntegerField") ((((unsupported)).apply ((32768.neg)) (32767))) ("IntegerField") ((((unsupported)).apply (((((unsupported)).apply).neg)) (2147483647))) ("BigIntegerField") ((((unsupported)).apply (((((unsupported)).apply).neg)) ((((unsupported)).apply)))) ("PositiveBigIntegerField") ((((unsupported)).apply (0) ((((unsupported)).apply)))) ("PositiveSmallIntegerField") ((((unsupported)).apply (0) (32767))) ("PositiveIntegerField") ((((unsupported)).apply (0) (2147483647))) ("SmallAutoField") ((((unsupported)).apply ((32768.neg)) (32767))) ("AutoField") ((((unsupported)).apply (((((unsupported)).apply).neg)) (2147483647))) ("BigAutoField") ((((unsupported)).apply (((((unsupported)).apply).neg)) ((((unsupported)).apply)))))
                xset_operators.write (((unsupported)).apply ("union") ("UNION") ("intersection") ("INTERSECT") ("difference") ("EXCEPT"))
                xcast_data_types.write (((unsupported)).apply)
                xcast_char_field_without_max_length.write "None: is there a None literal in the EO language?"
                xPRECEDING.write "PRECEDING"
                xFOLLOWING.write "FOLLOWING"
                xUNBOUNDED_PRECEDING.write ("UNBOUNDED ".add (xPRECEDING))
                xUNBOUNDED_FOLLOWING.write ("UNBOUNDED ".add (xFOLLOWING))
                xCURRENT_ROW.write "CURRENT ROW"
                xexplain_prefix.write "None: is there a None literal in the EO language?"
                x__init__.write
                  [xself xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xconnection)) ((xconnection)))
                        (((unsupported)).apply (((xself).x_cache)) ("None: is there a None literal in the EO language?"))
                xautoinc_sql.write
                  [xself xtable xcolumn]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xbulk_batch_size.write
                  [xself xfields xobjs]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xlen)).apply ((xobjs)))))
                xformat_for_duration_arithmetic.write
                  [xself xsql]
                    seq > @
                      (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations may require a format_for_duration_arithmetic() method."))))
                xcache_key_culling_sql.write
                  [xself]
                    memory > xcache_key
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xcache_key.write ((((xself).xquote_name)).apply ("cache_key"))
                        (((unsupported)).apply ("SELECT {cache_key} FROM %s ORDER BY {cache_key} LIMIT 1 OFFSET %%s"))
                xunification_cast_sql.write
                  [xself xoutput_field]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ("%s"))
                xdate_extract_sql.write
                  [xself xlookup_type xfield_name]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations may require a date_extract_sql() method"))))
                xdate_trunc_sql.write
                  [xself xlookup_type xfield_name xtzname]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations may require a date_trunc_sql() method."))))
                xdatetime_cast_date_sql.write
                  [xself xfield_name xtzname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations may require a datetime_cast_date_sql() method."))))
                xdatetime_cast_time_sql.write
                  [xself xfield_name xtzname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations may require a datetime_cast_time_sql() method"))))
                xdatetime_extract_sql.write
                  [xself xlookup_type xfield_name xtzname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations may require a datetime_extract_sql() method"))))
                xdatetime_trunc_sql.write
                  [xself xlookup_type xfield_name xtzname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations may require a datetime_trunc_sql() method"))))
                xtime_trunc_sql.write
                  [xself xlookup_type xfield_name xtzname]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations may require a time_trunc_sql() method"))))
                xtime_extract_sql.write
                  [xself xlookup_type xfield_name]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).xdate_extract_sql)).apply ((xlookup_type)) ((xfield_name)))))
                xdeferrable_sql.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (""))
                xdistinct_sql.write
                  [xself xfields xparams]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (xfields).if
                          (((unsupported)).apply ((((xNotSupportedError)).apply ("DISTINCT ON fields is not supported by this database backend"))))
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ("DISTINCT"))) ((((unsupported)).apply)))))
                xfetch_returned_insert_columns.write
                  [xself xcursor xreturning_params]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (((((xcursor).xfetchone)).apply)))
                xfield_cast_sql.write
                  [xself xdb_type xinternal_type]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ("%s"))
                xforce_no_ordering.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply)))
                xfor_update_sql.write
                  [xself xnowait xskip_locked xof xno_key]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (("FOR%s UPDATE%s%s%s".mod (((unsupported)).apply (((xno_key).if " NO KEY" "")) (((xof).if (" OF %s".mod (((", ".xjoin)).apply ((xof)))) "")) (((xnowait).if " NOWAIT" "")) (((xskip_locked).if " SKIP LOCKED" ""))))))
                x_get_limit_offset_params.write
                  [xself xlow_mark xhigh_mark]
                    memory > xoffset
                    seq > @
                      seq
                        xoffset.write ((xlow_mark).or 0)
                        (((unsupported)).apply ((xhigh_mark)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply (((xhigh_mark).sub (xoffset))) ((xoffset)))))
                          (xoffset).if
                            (((unsupported)).apply ((((unsupported)).apply (((((((xself).xconnection).xops).xno_limit_value)).apply)) ((xoffset)))))
                        (((unsupported)).apply ((((unsupported)).apply ("None: is there a None literal in the EO language?") ((xoffset)))))
                xlimit_offset_sql.write
                  [xself xlow_mark xhigh_mark]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((((unsupported)).apply ((xlimit)) ((xoffset)))) (((((xself).x_get_limit_offset_params)).apply ((xlow_mark)) ((xhigh_mark)))))
                        (((unsupported)).apply ((((" ".xjoin)).apply ((((unsupported)).apply ((xsql)) ((xsql)) ((((unsupported)).apply (((xlimit).if ("LIMIT %d".mod (xlimit)) "None: is there a None literal in the EO language?")) (((xoffset).if ("OFFSET %d".mod (xoffset)) "None: is there a None literal in the EO language?")))) ((xsql)))))))
                xlast_executed_query.write
                  [xself xcursor xsql xparams]
                    memory > xto_string
                    memory > xu_params
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xto_string.write
                          [xs]
                            seq > @
                              (((unsupported)).apply ((((unsupported)).apply ((xforce_str)) ((xs)) (TRUE) ("replace"))))
                        (((xisinstance)).apply ((xparams)) ((((unsupported)).apply ((xlist)) ((xtuple))))).if
                          xu_params.write (((xtuple)).apply ((((unsupported)).apply ((((xto_string)).apply ((xval)))) ((xval)) ((xparams)))))
                          (((unsupported)).apply ((xparams)) ("None: is there a None literal in the EO language?")).if
                            xu_params.write (((unsupported)).apply)
                            xu_params.write (((unsupported)).apply ((((xto_string)).apply ((xk)))) ((((xto_string)).apply ((xv)))) ((((unsupported)).apply ((xk)) ((xv)))) (((((xparams).xitems)).apply)))
                        (((unsupported)).apply (("QUERY = %r - PARAMS = %r".mod (((unsupported)).apply ((xsql)) ((xu_params))))))
                xlast_insert_id.write
                  [xself xcursor xtable_name xpk_name]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xcursor).xlastrowid)))
                xlookup_cast.write
                  [xself xlookup_type xinternal_type]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ("%s"))
                xmax_in_list_size.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xmax_name_length.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xno_limit_value.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations may require a no_limit_value() method"))))
                xpk_default_value.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ("DEFAULT"))
                xprepare_sql_script.write
                  [xself xsql]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xsqlparse).xformat)) ((xstatement)) (TRUE))) ((xstatement)) (((((xsqlparse).xsplit)).apply ((xsql)))) ((xstatement)))))
                xprocess_clob.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xvalue)))
                xreturn_insert_columns.write
                  [xself xfields]
                    seq > @
                      seq
                        (((unsupported)).apply)
                xcompiler.write
                  [xself xcompiler_name]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_cache)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).x_cache)) ((((ximport_module)).apply (((xself).xcompiler_module)))))
                        (((unsupported)).apply ((((xgetattr)).apply (((xself).x_cache)) ((xcompiler_name)))))
                xquote_name.write
                  [xself xname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations may require a quote_name() method"))))
                xregex_lookup.write
                  [xself xlookup_type]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations may require a regex_lookup() method"))))
                xsavepoint_create_sql.write
                  [xself xsid]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (("SAVEPOINT %s".mod ((((xself).xquote_name)).apply ((xsid))))))
                xsavepoint_commit_sql.write
                  [xself xsid]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (("RELEASE SAVEPOINT %s".mod ((((xself).xquote_name)).apply ((xsid))))))
                xsavepoint_rollback_sql.write
                  [xself xsid]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (("ROLLBACK TO SAVEPOINT %s".mod ((((xself).xquote_name)).apply ((xsid))))))
                xset_time_zone_sql.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (""))
                xsql_flush.write
                  [xself xstyle xtables xreset_sequences xallow_cascade]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseDatabaseOperations must provide an sql_flush() method"))))
                xexecute_sql_flush.write
                  [xself xsql_list]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((((unsupported)).apply (((xtransaction).xatomic)) ((((xself).xconnection).xalias)) (((((xself).xconnection).xfeatures).xcan_rollback_ddl)))))
                          (((unsupported)).apply ((((((xself).xconnection).xcursor)).apply)) ((xcursor)))
                            (((unsupported)).apply ((xsql)) ((xsql_list)))
                              bogusForceDataize.write ((((xcursor).xexecute)).apply ((xsql)))
                xsequence_reset_by_name_sql.write
                  [xself xstyle xsequences]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply)))
                xsequence_reset_sql.write
                  [xself xstyle xmodel_list]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply)))
                xstart_transaction_sql.write
                  [xself]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ("BEGIN;"))
                xend_transaction_sql.write
                  [xself xsuccess]
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        ((xsuccess).not).if
                          (((unsupported)).apply ("ROLLBACK;"))
                        (((unsupported)).apply ("COMMIT;"))
                xtablespace_sql.write
                  [xself xtablespace xinline]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (""))
                xprep_for_like_query.write
                  [xself xx]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((((((((((((xstr)).apply ((xx))).xreplace)).apply ("\\") ("\\\\")).xreplace)).apply ("%") ("%")).xreplace)).apply ("_") ("_"))))
                xprep_for_iexact_query.write (xprep_for_like_query)
                xvalidate_autopk_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xvalue)))
                xadapt_unknown_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xisinstance)).apply ((xvalue)) (((xdatetime).xdatetime))).if
                          (((unsupported)).apply (((((xself).xadapt_datetimefield_value)).apply ((xvalue)))))
                          (((xisinstance)).apply ((xvalue)) (((xdatetime).xdate))).if
                            (((unsupported)).apply (((((xself).xadapt_datefield_value)).apply ((xvalue)))))
                            (((xisinstance)).apply ((xvalue)) (((xdatetime).xtime))).if
                              (((unsupported)).apply (((((xself).xadapt_timefield_value)).apply ((xvalue)))))
                              (((xisinstance)).apply ((xvalue)) (((xdecimal).xDecimal))).if
                                (((unsupported)).apply (((((xself).xadapt_decimalfield_value)).apply ((xvalue)))))
                                (((unsupported)).apply ((xvalue)))
                xadapt_datefield_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((((xstr)).apply ((xvalue)))))
                xadapt_datetimefield_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((xhasattr)).apply ((xvalue)) ("resolve_expression")).if
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply ((((xstr)).apply ((xvalue)))))
                xadapt_timefield_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((xhasattr)).apply ((xvalue)) ("resolve_expression")).if
                          (((unsupported)).apply ((xvalue)))
                        ((((xtimezone).xis_aware)).apply ((xvalue))).if
                          (((unsupported)).apply ((((xValueError)).apply ("Django does not support timezone-aware times."))))
                        (((unsupported)).apply ((((xstr)).apply ((xvalue)))))
                xadapt_decimalfield_value.write
                  [xself xvalue xmax_digits xdecimal_places]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((((xutils).xformat_number)).apply ((xvalue)) ((xmax_digits)) ((xdecimal_places)))))
                xadapt_ipaddressfield_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xvalue).or "None: is there a None literal in the EO language?")))
                xyear_lookup_bounds_for_date_field.write
                  [xself xvalue xiso_year]
                    memory > xfirst
                    memory > xsecond
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (xiso_year).if
                          seq
                            xfirst.write (((((xdatetime).xdate).xfromisocalendar)).apply ((xvalue)) (1) (1))
                            xsecond.write ((((((xdatetime).xdate).xfromisocalendar)).apply (((xvalue).add 1)) (1) (1)).sub (((unsupported)).apply (((xdatetime).xtimedelta)) (1)))
                          seq
                            xfirst.write ((((xdatetime).xdate)).apply ((xvalue)) (1) (1))
                            xsecond.write ((((xdatetime).xdate)).apply ((xvalue)) (12) (31))
                        xfirst.write ((((xself).xadapt_datefield_value)).apply ((xfirst)))
                        xsecond.write ((((xself).xadapt_datefield_value)).apply ((xsecond)))
                        (((unsupported)).apply ((((unsupported)).apply ((xfirst)) ((xsecond)))))
                xyear_lookup_bounds_for_datetime_field.write
                  [xself xvalue xiso_year]
                    memory > xfirst
                    memory > xsecond
                    memory > xtz
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (xiso_year).if
                          seq
                            xfirst.write (((((xdatetime).xdatetime).xfromisocalendar)).apply ((xvalue)) (1) (1))
                            xsecond.write ((((((xdatetime).xdatetime).xfromisocalendar)).apply (((xvalue).add 1)) (1) (1)).sub (((unsupported)).apply (((xdatetime).xtimedelta)) (1)))
                          seq
                            xfirst.write ((((xdatetime).xdatetime)).apply ((xvalue)) (1) (1))
                            xsecond.write ((((xdatetime).xdatetime)).apply ((xvalue)) (12) (31) (23) (59) (59) (999999))
                        ((xsettings).xUSE_TZ).if
                          seq
                            xtz.write ((((xtimezone).xget_current_timezone)).apply)
                            xfirst.write ((((xtimezone).xmake_aware)).apply ((xfirst)) ((xtz)))
                            xsecond.write ((((xtimezone).xmake_aware)).apply ((xsecond)) ((xtz)))
                        xfirst.write ((((xself).xadapt_datetimefield_value)).apply ((xfirst)))
                        xsecond.write ((((xself).xadapt_datetimefield_value)).apply ((xsecond)))
                        (((unsupported)).apply ((((unsupported)).apply ((xfirst)) ((xsecond)))))
                xget_db_converters.write
                  [xself xexpression]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply)))
                xconvert_durationfield_value.write
                  [xself xvalue xexpression xconnection]
                    seq > @
                      (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                        (((unsupported)).apply (((((xdatetime).xtimedelta)).apply (0) (0) ((xvalue)))))
                xcheck_expression_support.write
                  [xself xexpression]
                    seq > @
                      seq
                        (((unsupported)).apply)
                xconditional_expression_supported_in_where_clause.write
                  [xself xexpression]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (TRUE))
                xcombine_expression.write
                  [xself xconnector xsub_expressions]
                    memory > xconn
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xconn.write (" %s ".mod (xconnector))
                        (((unsupported)).apply (((((xconn).xjoin)).apply ((xsub_expressions)))))
                xcombine_duration_expression.write
                  [xself xconnector xsub_expressions]
                    seq > @
                      (((unsupported)).apply (((((xself).xcombine_expression)).apply ((xconnector)) ((xsub_expressions)))))
                xbinary_placeholder_sql.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ("%s"))
                xmodify_insert_params.write
                  [xself xplaceholder xparams]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xparams)))
                xinteger_field_range.write
                  [xself xinternal_type]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xinteger_field_ranges)) ((xinternal_type)))))
                xsubtract_temporals.write
                  [xself xinternal_type xlhs xrhs]
                    seq > @
                      seq
                        ((((xself).xconnection).xfeatures).xsupports_temporal_subtraction).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xlhs_sql)) ((xlhs_params)))) ((xlhs)))
                            (((unsupported)).apply ((((unsupported)).apply ((xrhs_sql)) ((xrhs_params)))) ((xrhs)))
                            (((unsupported)).apply ((((unsupported)).apply (("(%s - %s)".mod (((unsupported)).apply ((xlhs_sql)) ((xrhs_sql))))) ((((unsupported)).apply ((((unsupported)).apply ((xlhs_params)))) ((((unsupported)).apply ((xrhs_params)))))))))
                        (((unsupported)).apply ((((xNotSupportedError)).apply (("This backend does not support %s subtraction.".mod (xinternal_type))))))
                xwindow_frame_start.write
                  [xself xstart]
                    seq > @
                      seq
                        (((xisinstance)).apply ((xstart)) ((xint))).if
                          ((xstart).less 0).if
                            (((unsupported)).apply (("%d %s".mod (((unsupported)).apply ((((xabs)).apply ((xstart)))) (((xself).xPRECEDING))))))
                            ((xstart).eq 0).if
                              (((unsupported)).apply (((xself).xCURRENT_ROW)))
                          (((unsupported)).apply ((xstart)) ("None: is there a None literal in the EO language?")).if
                            (((unsupported)).apply (((xself).xUNBOUNDED_PRECEDING)))
                        (((unsupported)).apply ((((xValueError)).apply (("start argument must be a negative integer, zero, or None, but got '%s'.".mod (xstart))))))
                xwindow_frame_end.write
                  [xself xend]
                    seq > @
                      seq
                        (((xisinstance)).apply ((xend)) ((xint))).if
                          ((xend).eq 0).if
                            (((unsupported)).apply (((xself).xCURRENT_ROW)))
                            ((xend).greater 0).if
                              (((unsupported)).apply (("%d %s".mod (((unsupported)).apply ((xend)) (((xself).xFOLLOWING))))))
                          (((unsupported)).apply ((xend)) ("None: is there a None literal in the EO language?")).if
                            (((unsupported)).apply (((xself).xUNBOUNDED_FOLLOWING)))
                        (((unsupported)).apply ((((xValueError)).apply (("end argument must be a positive integer, zero, or None, but got '%s'.".mod (xend))))))
                xwindow_frame_rows_start_end.write
                  [xself xstart xend]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((((xself).xconnection).xfeatures).xsupports_over_clause).not).if
                          (((unsupported)).apply ((((xNotSupportedError)).apply ("This backend does not support window expressions."))))
                        (((unsupported)).apply ((((unsupported)).apply (((((xself).xwindow_frame_start)).apply ((xstart)))) (((((xself).xwindow_frame_end)).apply ((xend)))))))
                xwindow_frame_range_start_end.write
                  [xself xstart xend]
                    memory > xfeatures
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xstart_)) ((xend_)))) (((((xself).xwindow_frame_rows_start_end)).apply ((xstart)) ((xend)))))
                        xfeatures.write (((xself).xconnection).xfeatures)
                        (((xfeatures).xonly_supports_unbounded_with_preceding_and_following).and (((xstart).and ((xstart).less 0)).or ((xend).and ((xend).greater 0)))).if
                          (((unsupported)).apply ((((xNotSupportedError)).apply (("%s only supports UNBOUNDED together with PRECEDING and FOLLOWING.".mod (((xself).xconnection).xdisplay_name))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xstart_)) ((xend_)))))
                xexplain_query_prefix.write
                  [xself xformat]
                    memory > xsupported_formats
                    memory > xnormalized_format
                    memory > xmsg
                    seq > @
                      (((unsupported)).apply)
                        (((((xself).xconnection).xfeatures).xsupports_explaining_query_execution).not).if
                          (((unsupported)).apply ((((xNotSupportedError)).apply ("This backend does not support explaining query execution."))))
                        (xformat).if
                          seq
                            xsupported_formats.write ((((xself).xconnection).xfeatures).xsupported_explain_formats)
                            xnormalized_format.write ((((xformat).xupper)).apply)
                            (((unsupported)).apply ((xnormalized_format)) ((xsupported_formats))).if
                              seq
                                xmsg.write ("%s is not a recognized format.".mod (xnormalized_format))
                                (xsupported_formats).if
                                  (((unsupported)).apply ((xmsg)) ((" Allowed formats: %s".mod (((", ".xjoin)).apply ((((xsorted)).apply ((xsupported_formats))))))))
                                (((unsupported)).apply ((((xValueError)).apply ((xmsg)))))
                        (xoptions).if
                          (((unsupported)).apply ((((xValueError)).apply (("Unknown options: %s".mod (((", ".xjoin)).apply ((((xsorted)).apply (((((xoptions).xkeys)).apply))))))))))
                        (((unsupported)).apply (((xself).xexplain_prefix)))
                xinsert_statement.write
                  [xself xon_conflict]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ("INSERT INTO"))
                xon_conflict_suffix_sql.write
                  [xself xfields xon_conflict xupdate_fields xunique_fields]
                    seq > @
                      (((unsupported)).apply (""))