Diff between original (left) and mutated (right) python files
1c1
< def nested_for_break2(): # 1:0-14:57
---
> def nested_for_continue2(): # 1:0-14:57
8c8
<                 break # 8:16-8:20
---
>                 continue # 8:16-8:20

Diff between original (left) and mutated (right) eo files
2,4d1
< +alias goto org.eolang.gray.goto
< +alias stdout org.eolang.io.stdout
< +alias cage org.eolang.gray.cage
6,280c3,29
< 
< [unused] > nested_for_break2
<   [] > apply
<     [stackUp] > @
<       [x] > mkCopy
<         x' > copy
<         copy.< > @
<       [] > newUID
<         memory > cur
<         seq > apply
<           cur.write (cur.is-empty.if 5 (cur.add 1))
<           cur
<       [] > raiseEmpty
<         [] > xclass
<           4 > xid
<       [res] > return
<         res > result
<         [] > xclass
<           3 > xid
<       [] > break
<         [] > xclass
<           2 > xid
<       [] > continue
<         [] > xclass
<           1 > xid
<       [] > raiseNothing
<         [] > xclass
<           0 > xid
<       cage > xcurrent-exception
<       [] > xmyArray
<         [initValue] > apply
<           [stackUp] > @
<             cage > pResult
<             [] > result
<               cage > value
<               [] > xlength
<                 [self] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (self.value.length))
<                       123
<               [] > xget
<                 [self i] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (self.value.get i))
<                       123
<               [] > xappend
<                 [self x] > apply
<                   [stackUp] > @
<                     seq > @
<                       mkCopy (self.value) > tmp
<                       self.value.write (tmp.copy.append x)
<                       stackUp.forward (return 0)
<             seq > @
<               result.value.write initValue
<               pResult.write result
<               stackUp.forward (return pResult)
<       cage > tmp
<       cage > toReturn
<       cage > assertMe
<       cage > xnested_for_break2
<       seq > @
<         stdout "nested_for_break2\n"
<         write.
<           xnested_for_break2
<           []
<             [] > apply
<               [stackUp] > @
<                 cage > tmp
<                 cage > toReturn
<                 cage > lhs18
<                 cage > e23
<                 cage > e1
<                 cage > lhs14
<                 cage > e7
<                 cage > e17
<                 cage > xres
<                 cage > e10
<                 cage > e25
<                 cage > e9
<                 cage > e22
<                 cage > e19
<                 cage > e6
<                 cage > e18
<                 cage > lhs0
<                 cage > e12
<                 cage > xj
<                 cage > lhs4
<                 cage > e5
<                 cage > e0
<                 cage > e20
<                 cage > xarr2
<                 cage > e4
<                 cage > e24
<                 cage > e13
<                 cage > lhs13
<                 cage > xit1
<                 cage > e8
<                 cage > e16
<                 cage > lhs2
<                 cage > lhs8
<                 cage > e3
<                 cage > lhs6
<                 cage > e21
<                 cage > lhs9
<                 cage > e14
<                 cage > xit0
<                 cage > e15
<                 cage > xi
<                 cage > e2
<                 cage > xarr1
<                 cage > e11
<                 seq > @
<                   stdout "xnested_for_break2\n"
<                   tmp.write (goto ((((xmyArray)).apply ((* 1 2 3))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e0).write (tmp.result)
<                   ((e0).<)
<                   mkCopy (e0) > tmp1
<                   (xarr1).write (tmp1.copy)
<                   tmp.write (goto ((((xmyArray)).apply ((* 4 5 6))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e1).write (tmp.result)
<                   ((e1).<)
<                   mkCopy (e1) > tmp2
<                   (xarr2).write (tmp2.copy)
<                   tmp.write (goto ((((xmyArray)).apply ((*))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e2).write (tmp.result)
<                   ((e2).<)
<                   mkCopy (e2) > tmp3
<                   (xres).write (tmp3.copy)
<                   mkCopy (xarr1.x__iter__) > tmp4
<                   (e3).write (tmp4.copy)
<                   ((e3).<)
<                   mkCopy (xarr1) > tmp5
<                   (lhs0).write (tmp5.copy)
<                   tmp.write (goto ((((e3)).apply ((lhs0))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e4).write (tmp.result)
<                   ((e4).<)
<                   mkCopy (e4) > tmp6
<                   (xit0).write (tmp6.copy)
<                   write.
<                     xcurrent-exception
<                     goto
<                       [stackUp]
<                         seq > @
<                           write.
<                             xcurrent-exception
<                             goto
<                               [stackUp]
<                                 seq > @
<                                   TRUE.while
<                                     [unused]
<                                       seq > @
<                                         mkCopy (xit0.x__next__) > tmp7
<                                         (e5).write (tmp7.copy)
<                                         ((e5).<)
<                                         mkCopy (xit0) > tmp8
<                                         (lhs2).write (tmp8.copy)
<                                         tmp.write (goto ((((e5)).apply ((lhs2))).@))
<                                         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                         (e6).write (tmp.result)
<                                         ((e6).<)
<                                         mkCopy (e6) > tmp9
<                                         (xi).write (tmp9.copy)
<                                         mkCopy (xarr2.x__iter__) > tmp10
<                                         (e7).write (tmp10.copy)
<                                         ((e7).<)
<                                         mkCopy (xarr2) > tmp11
<                                         (lhs4).write (tmp11.copy)
<                                         tmp.write (goto ((((e7)).apply ((lhs4))).@))
<                                         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                         (e8).write (tmp.result)
<                                         ((e8).<)
<                                         mkCopy (e8) > tmp12
<                                         (xit1).write (tmp12.copy)
<                                         write.
<                                           xcurrent-exception
<                                           goto
<                                             [stackUp]
<                                               seq > @
<                                                 write.
<                                                   xcurrent-exception
<                                                   goto
<                                                     [stackUp]
<                                                       seq > @
<                                                         TRUE.while
<                                                           [unused]
<                                                             seq > @
<                                                               mkCopy (xit1.x__next__) > tmp13
<                                                               (e9).write (tmp13.copy)
<                                                               ((e9).<)
<                                                               mkCopy (xit1) > tmp14
<                                                               (lhs6).write (tmp14.copy)
<                                                               tmp.write (goto ((((e9)).apply ((lhs6))).@))
<                                                               (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                                               (e10).write (tmp.result)
<                                                               ((e10).<)
<                                                               mkCopy (e10) > tmp15
<                                                               (xj).write (tmp15.copy)
<                                                               [] > tmp16
<                                                                 memory > dddata
<                                                                 dddata.write (((xj).eq 5)) > @
<                                                               (e11).write (tmp16.dddata)
<                                                               ((e11).<)
<                                                               (e11).if
<                                                                 seq
<                                                                   stackUp.forward break
<                                                                   TRUE
<                                                                 seq
<                                                                   TRUE
<                                                               mkCopy (xres.xappend) > tmp17
<                                                               (e12).write (tmp17.copy)
<                                                               ((e12).<)
<                                                               mkCopy (xres) > tmp18
<                                                               (lhs8).write (tmp18.copy)
<                                                               mkCopy (xj) > tmp19
<                                                               (lhs9).write (tmp19.copy)
<                                                               tmp.write (goto ((((e12)).apply ((lhs8)) ((lhs9))).@))
<                                                               (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                                               (e13).write (tmp.result)
<                                                               ((e13).<)
<                                                               TRUE
<                                                         stackUp.forward raiseNothing
<                                                 if.
<                                                   xcurrent-exception.xclass.xid.neq (break.xclass.xid)
<                                                   stackUp.forward xcurrent-exception
<                                                   0
<                                                 stackUp.forward raiseNothing
<                                         seq
<                                           mkCopy (xcurrent-exception.xclass) > tmp20
<                                           (e14).write (tmp20.copy)
<                                           ((e14).<)
<                                           mkCopy (e14.xid) > tmp21
<                                           (e15).write (tmp21.copy)
<                                           ((e15).<)
<                                           mkCopy (xStopIteration.xid) > tmp22
<                                           (e16).write (tmp22.copy)
<                                           ((e16).<)
<                                           [] > tmp23
<                                             memory > dddata
<                                             dddata.write (((e15).eq (e16))) > @
<                                           (e17).write (tmp23.dddata)
<                                           ((e17).<)
<                                           (e17).if
<                                             seq
<                                               TRUE
<                                             seq
<                                               TRUE
<                                           if.
<                                             xcurrent-exception.xclass.xid.eq (raiseNothing.xclass.xid)
<                                             seq
<                                             0
<                                           (xcurrent-exception.xclass.xid.neq (raiseNothing.xclass.xid)).if (stackUp.forward xcurrent-exception) 0
<                                         mkCopy (xres.xappend) > tmp24
<                                         (e18).write (tmp24.copy)
<                                         ((e18).<)
<                                         mkCopy (xres) > tmp25
<                                         (lhs13).write (tmp25.copy)
<                                         mkCopy (xi) > tmp26
<                                         (lhs14).write (tmp26.copy)
<                                         tmp.write (goto ((((e18)).apply ((lhs13)) ((lhs14))).@))
<                                         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                                         (e19).write (tmp.result)
<                                         ((e19).<)
<                                         TRUE
<                                   stackUp.forward raiseNothing
<                           if.
<                             xcurrent-exception.xclass.xid.neq (break.xclass.xid)
<                             stackUp.forward xcurrent-exception
<                             0
<                           stackUp.forward raiseNothing
---
> memory > xStopIteration
> memory > xmyArray
> [] > nested_for_break2
>   [args...] > unsupported
>   [args...] > xunsupported
>   memory > bogusForceDataize
>   memory > xbogusForceDataize
>   memory > xhack
>   seq > @
>     xhack.write
>       []
>         memory > xnested_for_continue2
>         seq > @
>           xnested_for_continue2.write
>             []
>               memory > xarr1
>               memory > xit0
>               memory > xit1
>               memory > xi
>               memory > xarr2
>               memory > xres
>               memory > xj
>               seq > @
>                 seq
>                   xarr1.write (((xmyArray)).apply ((((unsupported)).apply (1) (2) (3))))
>                   xarr2.write (((xmyArray)).apply ((((unsupported)).apply (4) (5) (6))))
>                   xres.write (((xmyArray)).apply ((((unsupported)).apply)))
282,297c31,33
<                     mkCopy (xcurrent-exception.xclass) > tmp27
<                     (e20).write (tmp27.copy)
<                     ((e20).<)
<                     mkCopy (e20.xid) > tmp28
<                     (e21).write (tmp28.copy)
<                     ((e21).<)
<                     mkCopy (xStopIteration.xid) > tmp29
<                     (e22).write (tmp29.copy)
<                     ((e22).<)
<                     [] > tmp30
<                       memory > dddata
<                       dddata.write (((e21).eq (e22))) > @
<                     (e23).write (tmp30.dddata)
<                     ((e23).<)
<                     (e23).if
<                       seq
---
>                     xit0.write ((((xarr1).x__iter__)).apply)
>                     (((unsupported)).apply ((xStopIteration)))
>                       while.
299,325c35,54
<                       seq
<                         TRUE
<                     if.
<                       xcurrent-exception.xclass.xid.eq (raiseNothing.xclass.xid)
<                       seq
<                       0
<                     (xcurrent-exception.xclass.xid.neq (raiseNothing.xclass.xid)).if (stackUp.forward xcurrent-exception) 0
<                   mkCopy (xres) > tmp31
<                   (lhs18).write (tmp31.copy)
<                   tmp.write (goto ((((xmyArray)).apply ((* 4 1 4 2 4 3))).@))
<                   (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<                   (e24).write (tmp.result)
<                   ((e24).<)
<                   [] > tmp32
<                     memory > dddata
<                     dddata.write (((lhs18).eq (e24))) > @
<                   (e25).write (tmp32.dddata)
<                   ((e25).<)
<                   toReturn.write ((e25))
<                   stackUp.forward (return toReturn)
<                   123
<         tmp.write (goto ((((xnested_for_break2)).apply).@))
<         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<         (assertMe).write (tmp.result)
<         toReturn.write ((assertMe))
<         stackUp.forward (return toReturn)
<   (goto (apply.@)).result > @
\ No newline at end of file
---
>                         [unused]
>                           seq > @
>                             seq
>                               xi.write ((((xit0).x__next__)).apply)
>                               seq
>                                 seq
>                                   xit1.write ((((xarr2).x__iter__)).apply)
>                                   (((unsupported)).apply ((xStopIteration)))
>                                     while.
>                                       TRUE
>                                       [unused]
>                                         seq > @
>                                           seq
>                                             xj.write ((((xit1).x__next__)).apply)
>                                             seq
>                                               ((xj).eq 5).if
>                                                 (((unsupported)).apply)
>                                               bogusForceDataize.write ((((xres).xappend)).apply ((xj)))
>                                 bogusForceDataize.write ((((xres).xappend)).apply ((xi)))
>                   (((unsupported)).apply (((xres).eq (((xmyArray)).apply ((((unsupported)).apply (4) (1) (4) (2) (4) (3)))))))
\ No newline at end of file