Diff between original (left) and mutated (right) python files
1c1
< def while_break1(): # 1:0-14:35
---
> def while_continue1(): # 1:0-14:35
11c11
<             break # 11:12-11:16
---
>             continue # 11:12-11:16

Diff between original (left) and mutated (right) eo files
2,4d1
< +alias goto org.eolang.gray.goto
< +alias stdout org.eolang.io.stdout
< +alias cage org.eolang.gray.cage
6,158c3,36
< 
< [unused] > while_break1
<   [] > apply
<     [stackUp] > @
<       [x] > mkCopy
<         x' > copy
<         copy.< > @
<       [] > newUID
<         memory > cur
<         seq > apply
<           cur.write (cur.is-empty.if 5 (cur.add 1))
<           cur
<       [] > raiseEmpty
<         [] > xclass
<           4 > xid
<       [res] > return
<         res > result
<         [] > xclass
<           3 > xid
<       [] > break
<         [] > xclass
<           2 > xid
<       [] > continue
<         [] > xclass
<           1 > xid
<       [] > raiseNothing
<         [] > xclass
<           0 > xid
<       cage > xcurrent-exception
<       [] > xmyArray
<         [initValue] > apply
<           [stackUp] > @
<             cage > pResult
<             [] > result
<               cage > value
<               [] > xlength
<                 [self] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (self.value.length))
<                       123
<               [] > xget
<                 [self i] > apply
<                   [stackUp] > @
<                     seq > @
<                       stackUp.forward (return (self.value.get i))
<                       123
<               [] > xappend
<                 [self x] > apply
<                   [stackUp] > @
<                     seq > @
<                       mkCopy (self.value) > tmp
<                       self.value.write (tmp.copy.append x)
<                       stackUp.forward (return 0)
<             seq > @
<               result.value.write initValue
<               pResult.write result
<               stackUp.forward (return pResult)
<       cage > tmp
<       cage > toReturn
<       cage > assertMe
<       cage > xwhile_break1
<       seq > @
<         stdout "while_break1\n"
<         write.
<           xwhile_break1
<           []
<             [] > apply
<               [stackUp] > @
<                 cage > tmp
<                 cage > toReturn
<                 cage > e1
<                 cage > xf2
<                 cage > e0
<                 cage > xf1
<                 cage > e4
<                 cage > e3
<                 cage > xf0
<                 cage > e2
<                 cage > xii
<                 seq > @
<                   stdout "xwhile_break1\n"
<                   (xf0).write (0)
<                   (xf1).write (1)
<                   (xii).write (0)
<                   write.
<                     xcurrent-exception
<                     goto
<                       [stackUp]
<                         seq > @
<                           TRUE.while
<                             [unused]
<                               seq > @
<                                 [] > tmp1
<                                   memory > dddata
<                                   dddata.write (((xii).less 110)) > @
<                                 (e3).write (tmp1.dddata)
<                                 ((e3).<)
<                                 ((e3).not).if
<                                   seq
<                                     stackUp.forward break
<                                     TRUE
<                                   seq
<                                     TRUE
<                                 [] > tmp2
<                                   memory > dddata
<                                   dddata.write (((xf0).add (xf1))) > @
<                                 (e0).write (tmp2.dddata)
<                                 ((e0).<)
<                                 mkCopy (e0) > tmp3
<                                 (xf2).write (tmp3.copy)
<                                 [] > tmp4
<                                   memory > dddata
<                                   dddata.write (((xii).add 1)) > @
<                                 (e1).write (tmp4.dddata)
<                                 ((e1).<)
<                                 mkCopy (e1) > tmp5
<                                 (xii).write (tmp5.copy)
<                                 mkCopy (xf1) > tmp6
<                                 (xf0).write (tmp6.copy)
<                                 mkCopy (xf2) > tmp7
<                                 (xf1).write (tmp7.copy)
<                                 [] > tmp8
<                                   memory > dddata
<                                   dddata.write (((xii).eq 9)) > @
<                                 (e2).write (tmp8.dddata)
<                                 ((e2).<)
<                                 (e2).if
<                                   seq
<                                     stackUp.forward break
<                                     TRUE
<                                   seq
<                                     TRUE
<                                 TRUE
<                           stackUp.forward raiseNothing
<                   if.
<                     xcurrent-exception.xclass.xid.neq (break.xclass.xid)
<                     stackUp.forward xcurrent-exception
<                     0
<                   [] > tmp9
<                     memory > dddata
<                     dddata.write ((34.eq (xf0))) > @
<                   (e4).write (tmp9.dddata)
<                   ((e4).<)
<                   toReturn.write ((e4))
<                   stackUp.forward (return toReturn)
<                   123
<         tmp.write (goto ((((xwhile_break1)).apply).@))
<         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<         (assertMe).write (tmp.result)
<         toReturn.write ((assertMe))
<         stackUp.forward (return toReturn)
<   (goto (apply.@)).result > @
\ No newline at end of file
---
> [] > while_break1
>   [args...] > unsupported
>   [args...] > xunsupported
>   memory > bogusForceDataize
>   memory > xbogusForceDataize
>   memory > xhack
>   seq > @
>     xhack.write
>       []
>         memory > xwhile_continue1
>         seq > @
>           xwhile_continue1.write
>             []
>               memory > xf2
>               memory > xf1
>               memory > xf0
>               memory > xii
>               seq > @
>                 seq
>                   xf0.write 0
>                   xf1.write 1
>                   xii.write 0
>                   while.
>                     ((xii).less 110)
>                     [unused]
>                       seq > @
>                         seq
>                           xf2.write ((xf0).add (xf1))
>                           xii.write ((xii).add 1)
>                           xf0.write (xf1)
>                           xf1.write (xf2)
>                           ((xii).eq 9).if
>                             (((unsupported)).apply)
>                   (((unsupported)).apply ((34.eq (xf0))))
\ No newline at end of file