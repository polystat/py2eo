+package org.eolang
+alias stdout org.eolang.io.stdout
+alias sprintf org.eolang.txt.sprintf 
+junit

[] > myTestBool
  memory > z
  and. > @
    z.write 15
    stdout "aoeuoeu"
    eq.
      42
      42

[] > myTestInt
  eq. > @
    100
    add.
      11
      89


[] > affine
  [a b x result] > f
    write. > @
      result
      ((x.mul a).add b)
  memory > result
  and. > @
    f 1 2 0 result
    result.eq 2
    f 1 2 1 result
    result.eq 3
    f 1 2 2 result
    result.eq 4

[] > squarePoly
  [a x result] > f
    write. > @
      result
      ((((x.mul (a.get 0)).add (a.get 1)).mul x).add (a.get 2))
  memory > result
  and. > @
    f (* 1 2 3) 0 result
    result.eq 3
    f (* 1 2 3) 1 result
    result.eq 6
    f (* 1 2 3) 2 result
    result.eq 11

[] > poly
  [a x result] > f
    memory > i
    seq > @
      result.write 0
      i.write 0
      while.
        (i.less) (a.length)
        [unused]
          seq > @
            (^.result.write) (((^.a.get) (^.i)).add ((^.result.mul) (^.x)))
            (^.i.write (^.i.add 1))
  memory > result
  and. > @
    f (* 1 2 3) 0 result
    result.eq 3
    f (* 1 2 3) 1 result
    result.eq 6
    f (* 1 2 3) 2 result
    result.eq 11

[] > bubbleSorter
  [a] > sort
    memory > i
    seq > @
      i.write 0
      while. > @
        (i.less) (a.length)
        [unused]
          memory > minpos
          memory > j
          memory > t
          seq > @
            minpos.write (^.i)
            j.write ((^.i.add) 1)
            while.
              (j.less) (^.a.length)
              [unused]
                seq > @
                  if. > @
                    ((^.^.a.get) (^.j)).less ((^.^.a.get) (^.minpos))
                    (^.minpos.write) (^.j)
                    ^.j
                  stdout (sprintf "j = %d\n" (^.j))
                  (^.j.write) ((^.j.add) 1)
            t.write (^.a.get (^.i))
            ((^.a.get) (^.i)).write ((^.a.get) minpos)
            ((^.a.get) minpos).write t
            (^.i.write) ((^.i.add) 1)
            stdout (sprintf "i = %d\n" (^.i))
  [elements...] > mkArr
  (mkArr memory memory memory).elements > arr
  seq > @
    (arr.get 0).write 2
    (arr.get 1).write 1
    (arr.get 2).write 0
    (sort arr)
    arr.each
      [x] (stdout (sprintf "%d " x) > @)

[] > mutablePairTest

  [a b] > mutablePair
    memory > first
    memory > second
    [y] > eq
      (^.first.eq y.first).and (^.second.eq y.second) > @
    seq > @
      first.write a
      second.write b

  mutablePair 0 1 > p01
  memory > devNull
  and. > @
    devNull.write p01
    p01.first.eq 0
    p01.second.eq 1

[] > ifelseifA
  memory > notWritten
  false.if notWritten true > @

[] > ifelseifB
  * > anArray
  false.if (anArray.get 0) true > @

[] > ifelseifC
  [first] > pair

  [] > none
    ^.pair false > @

  seq > @
    if.
      false
      11.cantget
      none


[] > bogus
  memory > a
  seq > @
    write.
      a
      *
        "a"
        "b"
        "c"
    stdout (a.get 0)
    stdout (a.get 1)
    reduce.
      a
      0
      []
        [accum elt] > reduce
          accum > @

[] > trivialMapTester

  [first second] > pair
    [y] > eq
      (^.first.eq y.first).and (^.second.eq y.second) > @

  [key] > tElt
    memory > valid
    memory > value
    [x] > set
      seq > @
        ^.value.write x
        ^.valid.write true
    [] > clear
      ^.valid.write false > @

  [] > none
    [z] > eq
      z.first.not > @
    ^.pair false 0 > @


  [] > trivialMap
    memory > a

    [name] > findElt
      memory > i
      memory > found
      seq > @
        i.write 0
        found.write false
        while.
          (i.less (^.a.length)).and (found.not)
          [unused]
            if.
              (^.^.a.get i).key.eq (^.name)
              found.write true
              i.write (i.add 1)


    [name1] > get
      ^.findElt name1 > found
      memory > bogus
      seq > @
        bogus.write found
        stdout (sprintf "found = %b, i = %d\n" (found.found) (found.i))
        if.
          found.found
          ((^.a.get (found.i)).valid.if (^.^.pair true (^.a.get (found.i)).value) (^.^.none))
          (^.^.none)

    [name value] > set
      ^.findElt name > found
      ^.^.tElt name > newElt
      if. > @
        found.found
        (^.a.get found.i).set value
        seq
          stdout (sprintf "ONE! %s %s\n" name value)
          newElt.set value
          stdout "TWO!\n"
          ^.a.write (^.a.append newElt)
          stdout "THREE!\n"

  and. > @
    write.
      trivialMap.a
      *
    none.eq (trivialMap.get "a")
